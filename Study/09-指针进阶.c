#include <stdio.h>

/*
	字符指针
		1.字符串常量在内存中存储的位置是文字常量区，文字常量区的元素只读不可修改。
		2.字符数组是在内存中是单独开辟的一块栈区内存，数组在被字符串赋值时，其实是将字符串常量的值复制到数组，也就是栈中，这样是可以通过访问内存进行修改的。
		3.当字符指针初始化的值为常量字符串，其实指向的是文字常量区的字符地址，其值不可被修改。
*/

////字符指针示例一
//int main()
//{
//	char arr[] = "Killua Aoki";//本质上是把"Killua Aoki"这个常量字符串的值复制存储在了字符变量数组"arr"的栈区中。
//	char* ptr = "Killua Aoki";//本质上是把"Killua Aoki"这个常量字符串的首字符"K"的地址存储在了指针变量"ptr"中，也就是指向的是常量字符串，指向的是文字常量区；正确写法是在"char"左边加上"const"。
//	
//	//*ptr = 'w';//错误：写入访问权限冲突，因为指针变量"ptr"所指向的是常量字符串的首字符地址，指向内存中的文字常量区，其元素只读不可修改，所以会导致报错，但是指针变量所指向的地址是可以改变的。
//
//	return 0;
//}

////字符指针示例二
//int main()
//{
//	char str1[] = "Killua Aoki";
//	char str2[] = "Killua Aoki";
//	const char* str3 = "Killua Aoki";
//	const char* str4 = "Killua Aoki";
//	if (str1 == str2)//判断为假，因为用相同的常量字符串去初始化不同的数组时会开辟出不同的内存块，其首元素的地址不相同，所以会进入"else"。
//		printf("str1 and str2 are same\n");
//	else
//		printf("str1 and str2 are not same\n");
//	if (str3 == str4)//判断为真，"str3"和"str4"指向的是同一个常量字符串，C/C++会将常量字符串存储到单独的一个内存区域，也就是文字常量区，当几个指针指向同一个字符串的时候，实际上是指向同一块内存。
//		printf("str3 and str4 are same\n");
//	else
//		printf("str3 and str4 are not same\n");
//	return 0;
//}

/*
	指针数组：本质上是数组，存放的是指针，也就是地址。
*/

////使用指针数组模拟二维数组示例：不同于二维数组，二维数组内的元素在内存中是连续存放的，但这种形式是一个数组内的元素是连续存放的，不同数组的地址不连续。
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[] = { 6,7,8,9,10 };
//	int arr3[] = { 11,12,13,14,15 };
//	int* ptr[] = { arr1,arr2,arr3 };
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 5; j++)
//		{
//			//printf("%d ", *(ptr[i] + j));
//			printf("%d ", ptr[i][j]);//等价于上一行的代码。
//		}
//		printf("\n");
//	}
//	return 0;
//}

/*
	数组指针：本质上是指针，指向的是数组的地址。
		1.创建数组指针需注意数组指针变量名先与"*"结合，若与"[]"结合则表明是数组而不是指针，因为"[]"的优先级比"*"高，所以需加上"()"确保"*"先与变量名称结合。
		2.数组名一般表示的是数组首元素的地址，但存在两个例外：
			a.使用"sizeof"计算数组大小中的数组名表示的是整个数组，计算的是数组中所有元素的大小总和，单位是字节。
			b.使用"&"操作符取出数组名的地址，取出的是整个数组的地址，其地址指向的位置依然是数组首元素的地址，但自增操作代表的是越过整个数组。
		3.数组指针多应用于二维数组，应用于一维数组过于麻烦。
		4.数组传参
			a.当一维数组以数组名进行传参，形参为数组，实参可以是数组也可以是指针，但需要注意当数组是指针数组时需要二级指针接收，
			b.当二维数组以数组名进行传参，形参为数组，实参可以是二维数组也可以是数组指针。
				1.当实参为数组时，行可以省略，列不能省略；因为对于一个二维数组来说，可以不知道有多少行，但是必须知道一行有多少元素。
				2.当实参为指针时，不能是一级指针或二级指针，因为二维数组的数组名相当于首行的一维数组，需要数组指针接收。
			
*/

////创建数组指针示例
//int main()
//{
//	int arr1[] = { 0,1,2,3,4,5,6,7,8,9 };//一个整形数组，"int"说明这个数组存放的类型是整型。
//	
//	int* arr2[] = { arr1 };//一个指针数组，其中存放的是整型指针变量，指向的是"arr1"首元素的地址；其中"arr2"先与"[]"进行结合，说明"arr2"是一个数组，"int*"说明数组存放的类型是整型指针。
//	
//	int(*ptr1)[] = &arr1;//一个数组指针，指向的是数组"arr1"的地址；其中"ptr1"先与"*"进行结合，说明"ptr1"是一个指针，"int (*)[]"说明这个指针指向的是存放着整型的数组的地址。
//	
//	int* (*ptr2)[] = &arr2;//一个数组指针，指向的是数组"arr2"的地址；其中"ptr2"先与"*"进行结合，说明"ptr2"是一个指针，"int* (*)[]"说明这个指针指向的是存放着整型指针类型的数组的地址。
//	
//	int(*ptr3[])[] = { &ptr1 };//一个指针数组，其中存放的是数组指针，而数组指针指向的地址是存放着整型的数组。
//	
//	int* (*ptr4[])[] = { &ptr2 };//一个指针数组，其中存放的是数组指针，而数组指针指向的地址是存放着整型指针的数组。
//	
//	return 0;
//}

////数组名示例
//int main()
//{
//	int arr[10] = {0};//整型数组，里面共有10个整型元素。
//
//	int* p1 = arr;//整型指针，将数组"arr"首元素的地址存放在一个整型指针变量中。
//	int (*p2)[10] = &arr;//数组指针，使用取地址操作符将整个数组"arr"的地址存放在一个整形数组指针变量中，其指向的是整个数组"arr"的地址。
//
//	//以下两行打印的结果相同，只能说明两个指针指向的都是同一个位置。
//	printf("%p\n", p1);
//	printf("%p\n", p2);
//	
//	//以下两行打印的结果不相同，也就代表每个指针"+1"的步长不同，说明其两个指针类型不相同。
//	printf("%p\n", p1+1);//相比于"p1"移动了4个字节。
//	printf("%p\n", p2+1);//相比于"p2"移动了40个字节。
//
//	return 0;
//}

////数组指针应用于一维数组示例
//int main()
//{
//	int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
//	int(*ptr)[10] = &arr;
//	for (int i = 0; i < 10; i++)
//	{
//		printf("%d ", *((*ptr) + i));//"(*ptr)"是对数组指针指向的整个数组进行解引用操作就相当于数组名，也就是数组首元素的地址。
//	}
//	return 0;
//}

////数组指针应用于二维数组示例
//void print(int(*ptr)[5], int r, int c)
//{
//	for (int i = 0; i < r; i++)
//	{
//		for (int j = 0; j < c; j++)
//		{
//			printf("%d ", *(*(ptr + i) + j));
//		}
//		printf("\n");
//	}
//}
//int main()
//{
//	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
//	print(arr, 3, 5);//数组名作为传参参数，表示的是数组首元素的地址，而二维数组的首元素就是二维数组的第一行，也就是整个一维数组。
//	return 0;
//}
#include <stdio.h>
#include <Windows.h>

/*
	数组
		1.一维数组
			a.一维数组的创建
			b.变长数组
			c.一维数组的初始化
			d.一维数组的使用
			e.一维数组在内存中的存储
		2.二维数组
			a.二维数组的创建
			b.二维数组的初始化
			c.二维数组的使用
			d.二维数组在内存中的存储
		3. 数组越界访问
		4. 数组作为函数参数传参
			a.冒泡排序
			b.数组名不同情况下的差异
		5. 数组的应用示例项目
			a.三子棋：https://github.com/KilluaAoki/Code/tree/Aoki/C/Project/TicTacToe。
			b.扫雷：https://github.com/KilluaAoki/Code/tree/Aoki/C/Project/Minesweeper。
*/

/*
	一维数组：一组用于存放相同类型元素的集合。
		1.一维数组的创建："type_t arr_name [const_n]"。
			a."type_t"：数组存放元素的元素类型。
			b."arr_name"：数组的名字。
			c."const_n"：常量表达式，用来指定数组的大小(大于零)；若支持C99标准，则可为变量表达式。
		2.变长数组：于C99标准中支持了变长数组的概念，即创建数组时"const_n"可以为变量表达式。
			a.变长数组在C99标准之前并不受支持，故C99前"const_n"只能为常量表达式。
			b.变长数组是不能在创建时同时被初始化的。
		3.一维数组的初始化：在创建数组的同时给数组中的内容赋值，若在数组创建时不进行初识化，则"const_n"必须给出明确的值。
			a.完全初始化：将数组内的所有元素全进行赋值。
				1.若在数组创建时进行初始化，则"const_n"可以省略，编译器将根据初始化的元素个数确定"const_n"，此为完全初始化。
			b.不完全初始化：将数组内的部分元素进行赋值。
				1.不完成初始化剩余未被赋值的元素会被编译器进行自动初始化，但因不同编译器、不同操作系统、不同元素类型等原因造成自动初始化的值并不唯一。
		4.一维数组的使用
			a."[]"：下标引用操作符，此操作符可用于访问数组下标对应的元素，从而获取数组元素的值和更改数组元素的值。
			b.数组是使用下标来访问的，下标是从"0"开始的。
			c.数组的大小可以通过计算得到。
		5.一维数组在内存中的存储
			a.数组在内存中是连续存放的。
			b.随着数组下标的增长，元素的地址也在有规律的递增，故数组内的元素是由低地址至高地址存放的。
*/

////一维数组创建和初始化示例
//int main()
//{
//	//整型数组
//	int arr1[] = { 1,2,3 };//完全初始化：根据后面的内容初始化元素个数。
//	int arr2[5] = { 1,2,3 };//不完全初始化：未初始化的内容补充为"0"(整型)。
//	
//	//字符数组
//	char ch1[] = { 'A','o','k','i' };//根据后面的内容初始化元素个数(4个元素个数)，没有"\0"，若以字符串格式化数据打印此数组可能会出现乱码。
//	char ch2[5] = { 'A','o','k','i' };//不完全初始化，未初始化的内容会自动补充"\0"(对应ASCII码值为"0")，故以字符串格式化数据会打印出"Aoki"。
//	char ch3[] = "Aoki";//字符串默认隐藏"\0"，故元素个数为5个，故以字符串格式化数据会打印出"Aoki"。
//	char ch4[4] = "Aoki";//指定了数组的大小，没有了"\0"，故以字符串格式化数据打印此数组可能会出现乱码。
//	
//	return 0;
//}

////一维数组的使用示例
//int main()
//{
//	int arr[10] = { 0 };
//	arr[5] = 10;//访问数组下标为"5"对应的元素，并且赋值为"10"。
//	int size = sizeof(arr) / sizeof(arr[0]);//计算数组的大小(元素个数)。
//	for (int i = 0; i < size; i++)//循环打印出数组的每一个元素，因数组的下标是从"0"开始的，若是"10"个元素，则下标最大为"9"。
//	{
//		printf("%d ", arr[i]);//此处"[]"为下标引用操作符，可使用变量访问数组的不同元素，"arr[i]"等价于"*(arr+i)"。
//	}
//	return 0;
//}

////一维数组在内存中的存储示例
//int main()
//{
//	int arr1[10] = { 0 };
//	for (int i = 0; i < sizeof(arr1) / sizeof(arr1[0]); i++)
//	{
//		printf("&arr[%d] = %p\n", i, &arr1[i]);//"%p"：以指针为格式化数据打印，即打印地址；可发现随着数组下标的增长，地址也在有规律的递增。
//	}
//	
//	int arr2[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr2;//数组名是数组首元素的地址。
//	for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0]); i++)
//	{
//		printf("%d ", *p);//正是因为数组在内存中是连续存放的，所以才能以指针访问到元素。
//		p++;//根据指针的类型，得出指针的步长为"4"，即每次自增"4"个字节。
//	}
//	
//	return 0;
//}

/*
	二维数组
		1.二维数组的创建："type_t arr_name [const_x][const_y]"。
			a."type_t"：二维数组中存放的元素的元素类型。
			b."arr_name"：二维数组的名字。
			c."const_x"和"const_y"可以理解为一个带有"const_x"行和"const_x"列的表格。
		2.二维数组的初始化：多维数组可以通过在"{}"内，再利用"{}"分别为每行指定值，从而进行初始化。
		3.二维数组的使用
			a.二维数组中的元素也是通过使用下标(可理解为数组的行索引和列索引)来访问的，同时下标也是从"0"开始的。
			b.可以将二维数组理解成一维数组的数组，即二维数组的每一行都是一个一维数组，同时二维数组的首元素的地址第一行元素的地址。
		4.二维数组在内存中的存储
			a.二维数组在内存中也是连续存储的。
			b.因为二维数组在内存中是连续存储的，所以必须确定列数，否则一行有几个元素是未知的(第二行不知道放在哪里)，故行索引可以被省略，列索引不行。
*/

////二维数组创建和初始化示例
//int main()
//{
//	int arr1[3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };//完全初始化，每列有"4"个元素，一共有"3"行，共"12"个元素。
//	int arr2[3][4] = { {0,1,2,3},{4,5,6,7},{8,9,10,11} };//内部嵌套的括号是可选的，与"arr1"相同。
//	int arr3[3][4] = { 0,1,2,3,4,5,6,7 };//不完全初始化：未初始化的内容补充为"0"(整型)。
//	int arr4[3][4] = { {0,1},{4,5},{8,9} };//不完全初始化；等同于"int arr4[3][4] = { 0,1,0,0,4,5,0,0,8,9,0,0 };"。
//	int arr5[][4] = { {0,1},{4,5},{8,9} };//行是可以省略的，会自动根据初始化内容确定。
//	return 0;
//}

////二维数组的使用示例
//int main()
//{
//	int arr[3][4] = { {0,1},{4,5},{8,9} };
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			printf("arr[%d][%d]=%d\t", i, j, arr[i][j]);//"arr[i][j]"等价于"*(*(arr+i)+j)"。
//		}
//		printf("\n");
//	}
//	return 0;
//}

////二维数组在内存中的存储示例
//int main()
//{
//	int arr1[][4] = { {0,1},{4,5},{8,9} };
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			printf("&arr1[%d][%d]=%p\n", i, j, &arr1[i][j]);//可以观察出二维数组在内存中也是连续存储的。
//		}
//	}
//
//	int arr2[][4] = { {0,1},{4,5},{8,9} };
//	int* p = &arr2[0][0];
//	for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0][0]); i++)
//	{
//		printf("%d ", *p);//正是因为数组在内存中是连续存放的，所以才能以指针访问到元素。
//		p++;//根据指针的类型，得出指针的步长为"4"，即每次自增"4"个字节。
//	}
//
//	return 0;
//}

/*
	数组越界访问
		1.数组的下标规定是从"0"开始的，并且数组的下标是有范围限制的。
		2.当数组有"N"个元素，那么最后一个元素的下标就是"N-1"。
		3.数组的下标如果小于"0"或者大于"N-1"，并且访问了元素，就会造成数组的越界访问，即超出了数组的合法空间进行访问。
*/

////数组越界访问示例
//int main()
//{
//	printf("↓如下为一维数组的越界访问例子↓\n");
//	int arr1[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (int i = 0; i <= 10; i++)
//	{
//		printf("arr1[%d]=%d\n", i, arr1[i]);//当"i"等于"10"的时，即越界访问。
//	}
//	system("pause");
//	system("cls");
//	printf("↓如下为二维数组的越界访问例子↓\n");
//	int arr2[3][4] = { {0,1},{4,5},{8,9} };
//	for (int i = 0; i <= 3; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			printf("arr2[%d][%d]=%d\t", i, j, arr2[i][j]);//当"i"等于"3"的时，即越界访问。
//		}
//		printf("\n");
//	}
//	return 0;
//}

/*
	数组作为函数参数传参
		1.冒泡排序：https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F。
			a.数组在进行传参时有两种形式，可以为数组形式，也可以为指针形式。
			b.不能在传参后计算数组的元素个数，因为计算的是指针的大小。
		2.数组名不同情况下的差异
			a."sizeof(arr_name)"：意为计算整个数组的大小，此时的"arr_name"(数组名)表示整个数组。
			b."&arr_name"：意为取出整个数组的地址，此时的"arr_name"(数组名)表示整个数组。
			c.除"sizeof(arr_name)"和"&arr_name"两种情况，其余的数组名都表示为数组的首元素的地址。
			d.当数组名表示为整个数组的情况时，其地址依旧是首元素的地址，但是类型与数组名表示为首元素的地址的情况并不相同。
*/

////冒泡排序示例
//void bubble_sort(int arr[], int sz)
//{
//	for (int i = 0; i < sz - 1; i++)
//	{
//		for (int j = 0; j < sz - 1 - i; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//			}
//		}
//	}
//}
//
//int main()
//{
//	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	bubble_sort(arr, sz);
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);//经过排序后数组变成了升序。
//	}
//	return 0;
//}

////数组名不同情况下的差异示例
//int main()
//{
//	int arr1[10] = { 1,2,3,4,5 };
//	printf("%p\n", arr1);//此时的数组名为数组的首元素的地址。
//	printf("%p\n", &arr1[0]);//取出"arr1"下标为"0"的元素的地址，可以发现和"printf("%p\n", arr1);"结果相同。
//	printf("%d\n", *arr1);//对"arr1"首元素的地址进行解引用，获取到首元素，等价于"arr[0]"。
//
//	int arr2[10] = { 0 };
//	printf("%p\n", &arr2);//此时的数组名表示为整个数组，取出的是数组的地址，但其地址依旧是首元素的地址，即整个数组的地址和首元素地址相同，但类型不同。
//	printf("%zu\n", sizeof(arr2));//计算的是整个数组的大小。
//
//	return 0;
//}
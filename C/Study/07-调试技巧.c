#include <stdio.h>
#include <assert.h>

/*
	调试技巧
		1.调试介绍
		2.笔试题
		3."coust"关键字
		4."Debug"调试版本和"Release"发布版本
		5.程序常见错误
*/

/**
	调试介绍
		1.调试又称为除错，是发现和减少计算机程序或电子仪器设备中程序错误的一个过程。
		2."VS2022"与调试相关的常用快捷键
			a."F5"：启动调试，经常用来直接跳到下一个断点处。
			b."F9"：创建断点和取消断点。
			c."F10"：逐过程，通常用来处理一个过程，一个过程可以是一次函数调用或者是一条语句。
			d."F11"：逐语句，每次都执行一条语句，并且可以进入函数内部。
			e."CTRL+F5"：开始执行而不调试。
		3."VS2022"中启动调试可以使用各类窗口查看程序当前的各种信息。
*/

////调试例题：使用调试，观察以下代码计算的阶乘总和存在什么问题。
//int main()
//{
//	int i = 0;
//	int sum = 0;
//	int n = 0;
//	int ret = 1;
//	scanf("%d", &n);
//	for (i = 1; i <= n; i++)
//	{
//		int j = 0;
//		for (j = 1; j <= i; j++)
//		{
//			ret *= j;
//		}
//		sum += ret;
//	}
//	printf("%d\n", sum);//因变量"ret"在计算变量"i"的阶乘时没有重置，导致结果错误。
//	return 0;
//}

/**
	笔试题
		a.因为局部变量是存放在栈区上的，并且栈区内存的使用习惯是先使用高地址再使用低地址，如下代码中"i"比"arr"先创建，故"i"的地址高于"arr"，又因为数组随着下标的增长，地址是由低到高变化的，所以当循环体循环次数超过数组下标，就有可能访问到"i"的地址，将"i"重置成0，重新开始循环造成死循环。
		b.不同编译器以及不同环境下创建变量的地址间隔不相同。
*/

////笔试题：在"VS2022"及"x86"环境下，下面的程序会出现什么问题？运⾏结果是什么？为什么？
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (i = 0; i <= 12; i++)
//	{
//		arr[i] = 0;
//		printf("Aoki\n");
//	}
//	return 0;
//}

/**
	"const"关键字
		1.当使用"const"修饰变量，这个变量就被称之为常变量，因具有常属性，故不能被修改，但是其本质上还是变量。
		2.当使用"const"修饰指针变量
			a."const"放在"*"的左边，修饰的是指针指向的内容，表示指针变量所指向的内容不能通过指针变量来改变，但是指针变量本身所指向的地址可以被修改。
			b."const"放在"*"的右边，修饰的是指针变量本身，表示指针变量的内容不能被修改，也就是其本身不能被修改，但是指针变量所指向的内容可以被修改。
			c."const"分别位于"*"的两边，表示指针变量所指向的内容以及指针变量本身都不能修改。
*/

////"const"关键字使用示例
//int main()
//{
//	////"const"修饰变量使用示例
//	//int a = 0;//变量"a"。
//	//const int b = 0;//常变量"b"。
//	//a = 100;//修改成功。
//	//b = 100;//修改失败，编译器报错：表达式必须是可修改的左值。
//
//	////"const"修饰指针变量使用示例一："const"放在"*"的左边。
//	//int	arr1[5] = { 1,2,3,4,5 };
//	//int	arr2[5] = { 1,2,3,4,5 };
//	//int* pa = arr1;
//	//const int* pb = arr1;
//	//*pa = 0;//修改成功：数组下标为"0"的元素被修改成整型"0"。
//	//*pb = 0;//修改失败：经过"const"修饰的"*pb"不能修改所指向的内容；编译器报错：表达式必须是可修改的左值。
//	//pb = arr2;//修改成功：指针变量"pb"所指向的地址被修改成数组"arr2"首元素的地址。
//
//	////"const"修饰指针变量使用示例二："const"放在"*"的右边。
//	//int	arr1[5] = { 1,2,3,4,5 };
//	//int	arr2[5] = { 1,2,3,4,5 };
//	//int* pa = arr1;
//	//int* const pb = arr1;
//	//*pa = 0;//修改成功：数组下标为"0"的元素被修改成整型"0"。
//	//*pb = 1;//修改成功：数组下标为"0"的元素被修改成整型"1"。
//	//pb = arr2;//修改失败：经过"const"修饰的"pb"不能修改所指向的地址；编译器报错：表达式必须是可修改的左值。
//
//	////"const"修饰指针变量使用示例三："const"分别位于"*"的两边。
//	//int	arr1[5] = { 1,2,3,4,5 };
//	//int	arr2[5] = { 1,2,3,4,5 };
//	//int* pa = arr1;
//	//const int* const pb = arr1;
//	//*pa = 0;//修改成功：数组下标为"0"的元素被修改成整型"0"。
//	//*pb = 1;//修改失败：经过"const"修饰的"*pb"不能修改所指向的内容；编译器报错：表达式必须是可修改的左值。
//	//pb = arr2;//修改失败：经过"const"修饰的"pb"不能修改所指向的地址；编译器报错：表达式必须是可修改的左值。
//
//	return 0;
//}

////"const"关键字例题一：模拟实现"strcpy"函数。(https://zh.cppreference.com/w/c/string/byte/strcpy)
//char* MyStrcpy(char* dest, const char* src)//使用"const"修饰"*src"保证指针指向的内容不能通过指针来改变(具体见"const"解析)。
//{
//	assert(dest != NULL && src != NULL);//"assert"宏：意为断言，若表达式为假便会终止程序并报错，当表达式为真则继续执行程序。
//	char* tmp = dest;//使用临时指针变量记录下"dest"的起始地址。
//	while (*dest++ = *src++);//当"*src"为"\0"时，将"\0"赋值给"*dest"，同时表达式的结果为假，循环会停止。
//	return tmp;//返回目标空间的起始地址。
//}
//
//int main()
//{
//	char arr1[20] = "XXXXXXXXXX";
//	char arr2[] = "KilluaAoki";
//	printf("%s\n", MyStrcpy(arr1, arr2));
//	return 0;
//}

////"const"关键字例题二：模拟实现"strlen"函数。
//size_t MyStrlen(const char* str)
//{
//	assert(str);
//	const char* tmp = str;
//	while (*str++);
//	return (str - tmp - 1);
//}
//
//int main()
//{
//	char arr[] = "Aoki";
//	printf("%zu\n", MyStrlen(arr));
//	return 0;
//}

/**
	"Debug"调试版本和"Release"发布版本
		1."Debug"：即调试版本，它包含了调试信息，并且不作任何优化，便于程序员调试程序。
		2."Release"：即发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。
*/

////"Release"发布版本示例("VS2022"需切换至"Release"解决方案配置)
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for ( i = 0; i <= 12; i++)
//	{
//		arr[i] = 0;
//		printf("Aoki\n");//运行发现没有死循环，因为"Release"发布版本进行了优化，使程序不会死循环。
//	}
//	return 0;
//}

/**
	程序常见错误
		1.编译型错误：无法通过编译，通常为语法错误等，常规情况下编译器能够提示出错信息以及修复方法。
		2.链接型错误：编译通过，错误出现在链接期间，运行程序可能会出错，通常为标识符名不存在等。
		3.运行时错误：编译通过，但程序内隐含着错误，通常是逻辑错误等，需使用调试观察并解决。
*/

////程序常见错误例题：以下程序会发生链接型错误吗？如果不会请解答并给出程序运行的结果，注意分文件执行。
//
////以下为"foo.c"文件的内容
//int a;
//
//void foo()
//{
//	a = 100;
//}
//
////以下为"main.c"文件的内容
//int a = 10;
//
//void foo();
//
//int main()
//{
//	foo();
//	printf("%d", a);//结果为：100；解析参见：https://stackoverflow.com/questions/4476169/is-int-a-a-declaration-or-definition-in-c-and-in-c。
//	return 0;
//}
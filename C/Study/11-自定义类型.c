#include <stdio.h>
#include <stddef.h>
#include <Windows.h>

/*
	结构体
		1.结构体类型的声明与定义
		2.结构体的自引用
		3.结构体变量的定义和初始化
		4.结构体内存对齐
		5.结构体传参
		6.结构体实现位段
*/

/*
	结构体类型的声明与定义
		1.结构体是一些值的集合，这些值称为成员变量；结构体内的每个成员可以是不同类型的变量。
		2.结构体内的成员可以是标量、数组、指针，甚至是其他结构体。
		3.特殊的声明：在声明结构的时候，可以不完全的声明(省略掉了结构体标签(名称))，即创建匿名结构体类型，但匿名结构体类型具有局限性(只可使用一次(无法再创建新变量))。
*/

////结构体类型的声明与定义示例一：创建常见结构体类型。
//struct Student//声明一个类型"struct Student"。
//{
//	//以下为成员变量的声明。
//	char name[10];//名称。
//	int age;//年龄。
//	char id[20];//学号。
//};
//
//int main()
//{
//	return 0;
//}

////结构体类型的声明与定义示例二：创建匿名结构体类型。
//struct
//{
//	int a;
//	char b;
//	float c;
//}x;
//
//struct
//{
//	int a;
//	char b;
//	float c;
//}*ptr;
//
//int main()
//{
//	ptr = &x;//未定义行为：编译器会把上面的两个变量"ptr"和"x"当成两个完全不同的类型，故此行代码非法。
//	return 0;
//}

////结构体类型的声明与定义示例三：在一个结构体类型中包含另一个结构体类型变量。
//struct Privacy//声明一个类型"struct Privacy"。
//{
//	char Sexual_orientation[5];//性取向。
//	char Phone_number[20];//手机号。
//};
//
//struct Student//声明一个类型"struct Student"。
//{
//	//以下为成员变量的声明。
//	char name[10];//名称。
//	int age;//年龄。
//	char id[20];//学号。
//	struct Privacy A;//隐私；结构体包含其他结构体类型：包含了结构体类型"struct Privacy"。
//}A1, A2;
//
//int main()
//{
//	struct Student Aoki = { "Aoki",19,"2020412505XX",{"保密","186XXXXXXXX"} };
//	printf("%s %d %s %s %s\n", Aoki.name, Aoki.age, Aoki.id, Aoki.A.Sexual_orientation, Aoki.A.Phone_number);
//	return 0;
//}

/*
	结构体的自引用：在结构中包含一个类型为该结构本身的成员。
		1.结构体中包含一个类型为该结构体本身的成员，包含同类型的结构体指针(不是包含同类型的结构体变量)。
		2.结构体不能自己包含自己，即不能包含同类型的结构体变量，但可以包含同类型的指针。
		3.结构体自引用时，不可使用匿名结构体。
*/

////结构体自引用示例一
//struct Node
//{
//	int data;
//	struct Node* Next;//自引用正确方法。
//	//struct Node Next;//自引用错误方法：无限套娃死循环，编译器报错("Next"使用未定义的 struct"Node")，无法计算此结构体类型的大小。
//};
//
//int main()
//{
//	struct Node X = { 0 };
//	return 0;
//}

////结构体自引用示例二：结合"typedef"将结构体类型重命名，并自引用。
//typedef struct Node//使用"typedef"将"struct Node"重命名为"Node"。
//{
//	int data;
//	struct Node* Next;
//}Node;
//
//int main()
//{
//	Node X = { 0 };
//	return 0;
//}

/*
	结构体变量的定义和初始化
*/

////结构体变量的定义和初始化示例
//struct Privacy
//{
//	char Sexual_orientation[5];//性取向。
//	char Phone_number[20];//手机号。
//};
//
//struct Student
//{
//	char name[10];//名称。
//	int age;//年龄。
//	char id[20];//学号。
//	struct Privacy A;//隐私。
//}A1, A2 = { 0 };//创建结构体对象的第一种方式：使用"struct Student"类型创建"A1"和"A2"对象，这两个变量为全局变量；"struct Student A2 = { 0 }"定义结构体变量并进行初始化(嵌套)。
//
//int main()
//{
//	//如下为创建结构体对象的第二种方式：使用"struct Student"类型创建"B1"对象并进行初始化，此变量为局部变量。
//	struct Student B1 = { "Aoki",19,"2020412505XX",{"保密","186XXXXXXXX"} };
//	
//	//如下是将"B1"的地址存放到结构体类型为"struct Student"的指针变量"pa"中。
//	struct Student* pa = &B1;
//	
//	//结构体成员访问(使用"."操作符)
//	printf("%s\n", B1.name);
//	printf("%d\n", (*pa).age);
//	
//	//结构体成员访问(使用"->"操作符)："->"操作符的左操作数应为指针变量。
//	printf("%s\n", pa->id);
//	printf("%s\n", pa->A.Sexual_orientation);
//	printf("%s\n", pa->A.Phone_number);
//
//	return 0;
//}

/*
	结构体内存对齐：拿空间换取时间。
		1.结构体内存对齐规则
			a.结构体的第一个成员在与结构体变量偏移量为"0"的地址处存放。
			b.结构体的其他成员要存放到对齐数(取成员类型大小与默认对齐数的较小值)的整数倍的地址处。
			c.在"VS2022"中默认对齐数为"8"，"Linux"无默认对齐数的概念。
			d.结构体的总大小为当前已存放的总内存大小扩展到结构体中每个成员的对齐数的最大对齐数的整数倍。
			e.如果出现嵌套结构体的情况，则嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。
		2.内存对齐存在的原因
			a.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
			b.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐，原因在于为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存访问仅需要一次访问。
		3.高质量设计结构体
			a.既要满足对齐，又要节省空间。
			b.做法：让占用空间小的成员尽量集中在一起。
		4.修改默认对齐数：结构在对齐方式不合适的时候，我们可以自己更改默认对齐数。
			a.使用"#pragma pack()"修改默认对齐数，当"()"内无值则恢复默认对齐数，当"()"内有值则修改对齐数为对应对齐数。
*/

////结构体内存对齐示例与练习：探讨如何计算结构体类型的大小(在64位平台下)。
//struct S1
//{
//	int x;
//	char y;
//	int z;
//};
//
//struct S2
//{
//	int x;
//	char y;
//	struct S2* ptr;
//};
//
//struct S3
//{
//	double x;
//	char y;
//	int z;
//};
//
//struct S4
//{
//	char x;
//	struct S3 y;
//	double z;
//};
//
//int main()
//{
//	printf("%zu\n", sizeof(struct S1));
//	//"struct S1"第一个成员变量类型为"int"，大小为"4"个字节，存放在偏移量为"0"的地址处。
//	//"struct S1"第二个成员变量类型为"char"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"4"的地址处。
//	//"struct S1"第三个成员变量类型为"int"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"4"的整数倍的地址处，即偏移量为"8"的地址处。
//	//"struct S1"的总大小，是当前已存放的总内存大小("12")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"4"的整数倍，即大小为"12"字节。
//	//故"struct S1"的总大小是"12"个字节。
//
//	printf("%zu\n", sizeof(struct S2));
//	//"struct S2"第一个成员变量类型为"int"，大小为"4"个字节，存放在偏移量为"0"的地址处。
//	//"struct S2"第二个成员变量类型为"char"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"4"的地址处。
//	//"struct S2"第三个成员变量类型为"struct S2*"，大小为"8"个字节(指针类型的大小不再赘述)，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"8"的整数倍的地址处，即偏移量为"8"的地址处。
//	//"struct S2"的总大小，是当前已存放的总内存大小("16")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"8"的整数倍，即大小为"16"字节。
//	//故"struct S2"的总大小是"16"个字节。
//
//	printf("%zu\n", sizeof(struct S3));
//	//"struct S3"第一个成员变量类型为"double"，大小为"8"个字节，存放在偏移量为"0"的地址处。
//	//"struct S3"第二个成员变量类型为"char"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"8"的地址处。
//	//"struct S3"第三个成员变量类型为"int"，大小为"4"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"4"的整数倍的地址处，即偏移量为"12"的地址处。
//	//"struct S3"的总大小，是当前已存放的总内存大小("16")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"8"的整数倍，即大小为"16"字节。
//	//故"struct S3"的总大小是"16"个字节。
//
//	printf("%zu\n", sizeof(struct S4));
//	//"struct S4"第一个成员变量类型为"char"，大小为"1"个字节，存放在偏移量为"0"的地址处。
//	//"struct S4"第二个成员变量类型为"struct S3"，出现结构体嵌套，则嵌套的结构体对齐到自己最大对齐数的整数倍的地址处，即偏移量为"8"的地址处。
//	//"struct S4"第三个成员变量类型为"double"，大小为"8"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"8"的整数倍的地址处，即偏移量为"24"的地址处。
//	//"struct S4"的总大小，是当前已存放的总内存大小("32")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"8"的整数倍，即大小为"32"字节。
//	//故"struct S4"的总大小是"32"个字节。
//
//	return 0;
//}

////修改默认对齐数示例
//#pragma pack(2)//修改默认对齐数为"2"。
//struct S1
//{
//	char x;
//	int y;
//	char z;
//};
//#pragma pack()//恢复初始默认对齐数"8"。
//
//#pragma pack(1)//修改默认对齐数为"1"。
//struct S2
//{
//	char x;
//	int y;
//	char z;
//};
//#pragma pack()//恢复初始默认对齐数"8"。
//
//int main()
//{
//	printf("%zu\n", sizeof(struct S1));
//	//"struct S1"第一个成员变量类型为"char"，大小为"1"个字节，存放在偏移量为"0"的地址处。
//	//"struct S1"第二个成员变量类型为"int"，大小为"4"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"2"的整数倍的地址处，即偏移量为"2"的地址处。
//	//"struct S1"第三个成员变量类型为"char"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"6"的地址处。
//	//"struct S1"的总大小，是当前已存放的总内存大小("7")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"2"的整数倍，即大小为"8"字节。
//	//故"struct S1"的总大小是"8"个字节。
//
//	printf("%zu\n", sizeof(struct S2));
//	//"struct S1"第一个成员变量类型为"char"，大小为"1"个字节，存放在偏移量为"0"的地址处。
//	//"struct S1"第二个成员变量类型为"int"，大小为"4"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"1"的地址处。
//	//"struct S1"第三个成员变量类型为"char"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"5"的地址处。
//	//"struct S1"的总大小，是当前已存放的总内存大小("6")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"1"的整数倍，即大小为"6"字节。
//	//故"struct S1"的总大小是"6"个字节。
//
//	return 0;
//}

/*
	"offsetof"宏：用于求结构体中一个成员在该结构体中的偏移量。
		1.头文件："stddef.h"。
		2.宏声明：#define offsetof(type, member)。
			a.宏返回值是一个"size_t"类型的值，即无符号整型类型；在此宏意为返回从指定类型对象的开头到其指定子对象的偏移量(以字节为单位)，包括填充(如果有)。
			b.宏参数"type"表示类型，在C中应为结构或联合类型。
			c.宏参数"member"表示类型的成员；不限制"member"为直接成员，它能指代给定成员的子对象，例如数组成员的元素。
		3.未定义情况
			a.给定拥有静态存储期的"type"类型对象"o"，"&(o.member)"应当为地址常量表达式并指向"o"的子对象，否则行为未定义。
			b.若将"offsetof"应用到位域(位段)成员，因为不能取位域(位段)的地址，所以行为未定义。
			c.C23起，若在"type"中定义新类型，则行为未定义，但"offsetof(struct Foo { int a; }, a)"通常支持，"offsetof(struct Foo { int a, b; }, a)"不支持，因为"struct Foo"定义中的逗号。
*/

////使用"offsetof"宏示例
//struct Test
//{
//	int x;
//	char y;
//	int z;
//};
//int main()
//{
//	printf("%zu\n", offsetof(struct Test, x));//得出"struct Test"类型的成员"x"的偏移量是"0"。
//	printf("%zu\n", offsetof(struct Test, y));//得出"struct Test"类型的成员"y"的偏移量是"4"。
//	printf("%zu\n", offsetof(struct Test, z));//得出"struct Test"类型的成员"z"的偏移量是"8"。
//	return 0;
//}

/*
	结构体传参
		1.函数传参的时候，参数是需要压栈的(栈：一种数据结构，先进的后出，后进的先出，类似电梯)。
		2.若传递的结构体对象过大，参数压栈的系统开销比较大，会导致性能的下降。
		3.结构体传参时，需传结构体的地址。
*/

////结构体传参示例
//struct Privacy
//{
//	char Sexual_orientation[5];//性取向。
//	char Phone_number[20];//手机号。
//};
//
//struct Student
//{
//	char name[10];//名称。
//	int age;//年龄。
//	char id[20];//学号。
//	struct Privacy A;//隐私。
//}A1, A2;
//
//void print(struct Student B1_A, struct Student* B1_B)
//{
//	printf("\n%s %d %s %s %s\n", B1_A.name, B1_A.age, B1_A.id, B1_A.A.Sexual_orientation, B1_A.A.Phone_number);
//	printf("\n%s %d %s %s %s\n", B1_B->name, B1_B->age, B1_B->id, B1_B->A.Sexual_orientation, B1_B->A.Phone_number);
//}
//
//int main()
//{
//	struct Student B1 = { "Aoki",19,"2020412505XX",{"保密","186XXXXXXXX"} };
//	
//	struct Student* pa = &B1;
//
//	print(B1, &B1);//参数"B1"是将结构体作为形参传递给了子函数(传值调用)；参数"&B1"是将结构体的地址传递给了子函数(传址调用)。
//
//	return 0;
//}

/*
	结构体实现位段(位段的填充&可移植性)：C语言允许在一个结构体中以位为单位来指定其成员所占内存长度，这种以位为单位的成员称为"位段"或"位域"(bit field)。
		1.位段的声明和定义
			a.位段的成员必须是整型家族类型(包含"char")。
			b.位段的成员名后边有一个冒号和一个数字。
			c.可以定义无名位段。
			d.位段的长度不能大于存储单元的长度，也不能定义位段数组。
			e.位段定义的第一个位段长度不能为"0"。
			f.位域不能是静态类型。不能使用"&"对位域做取地址运算，因此不存在位域的指针，编译器通常不支持位域的引用(reference)。
		2.位段的内存分配
			a.一个位段必须存储在同一存储单元中，不能跨两个单元；如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。
			b.长度为"0"的位段，其作用是使下一个位段从下一个存储单元开始存放。
		3.位段的跨平台问题：位域这种数据结构其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。
			a.机器位数不同导致位段分配的存储单元就不同，如十六位机器的"int"类型大小为"2"个字节。
			b."int"类型的位段被当成有符号数还是无符号数是不确定的。
			c.位段在某些机器上跨分配存储单元，而在其他机器上不跨。
			d.位段在某些机器上从右到左分配，在其他机器上从左到右分配。
		4.位段的应用：当需要节省储存空间时就可使用位段。
			a.可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。
			b.位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。
*/

////位段的声明和定义示例
//struct Bit_Field//声明一个类型"struct Bit_Field"。
//{
//	int _a : 2;//存储"2"个比特位。
//	int _b : 5;//存储"5"个比特位。
//	int _c : 10;//存储"10"个比特位。
//	int _d : 30;//存储"30"个比特位。
//};
//
//int main()
//{
//	printf("%zu\n", sizeof(struct Bit_Field));//得出结果是"8"。
//	//首先编译器先在内存中开辟出一个"int"的空间，也就是"4"个字节作为一个存储单元。
//	//当存储"a"的"2"个比特位后发现可以在一个存储单元中继续存放下"b"的"5"个比特位以及"c"的"10"个比特位，所以"a"和"b"以及"c"都存储在一个存储单元中。
//	//当存储"d"时发现无法在先前开辟的一个存储单元中剩余的空间存储下"30"个比特位，所以会再开辟出一个"int"的空间，再将"d"的"30"个比特位数据存储在这个存储单元中。
//	//故"struct Bit_Field"的总大小为"8"个字节。
//
//	return 0;
//}

////位段的内存分配示例
//struct Bit_Field
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//};
//
//int main()
//{
//	struct Bit_Field A = { 0 };
//	
//	A.a = 10;//十进制的"10"转换为二进制是"1010"，因位段中定义了"a"存储"3"个比特位，故会将"010"存放进存储单元。
//	A.b = 12;//十进制的"12"转换为二进制是"1100"，因位段中定义了"b"存储"4"个比特位，故会将"1100"存放进存储单元。
//	A.c = 3;//十进制的"3"转换为二进制是"11"，因位段中定义了"c"存储"5"个比特位，故会将"00011"存放进存储单元。
//	A.d = 4;//十进制的"4"转换为二进制是"100"，因位段中定义了"d"存储"4"个比特位，故会将"0100"存放进存储单元。
//	
//	printf("%zu\n", sizeof(struct Bit_Field));//得出结果是"3"。
//	//首先编译器先在内存中开辟出一个"char"的空间，也就是"1"个字节作为一个存储单元。
//	//当存储"a"的"3"个比特位后发现可以在一个存储单元中继续存放下"b"的"4"个比特位，所以"a"和"b"都存储在一个存储单元中。
//	//当存储"c"时发现无法在先前开辟的一个存储单元中剩余的空间存储下"5"个比特位，所以会再开辟出一个"char"的空间，再将"c"的"5"个比特位数据存储在这个存储单元中。
//	//当存储"d"时发现无法在先前开辟的一个存储单元中剩余的空间存储下"4"个比特位，所以会再开辟出一个"char"的空间，再将"d"的"4"个比特位数据存储在这个存储单元中。
//	//故"struct Bit_Field"的总大小为"3"个字节。
//
//
//	//假设数值存储进存储单元的规则是将数值从低位到高位进行存储。
//	//从位段定义可知：一个位段必须存储在同一存储单元中，不能跨两个单元；如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。
//	//故第一个存储单元应存储二进制"01100010"，也就是十六进制的"62"。
//	//故第二个存储单元应存储二进制"00000011"，也就是十六进制的"03"。
//	//故第三个存储单元应存储二进制"00000100"，也就是十六进制的"04"。
//	//调试观察"A"在内存存放的数值可以发现三个字节存放的数据分别是"62"、"03"、"04"(十六进制)，假设成立。
//
//	return 0;
//}

/*
	枚举：对一个对象的所有可能取到的值的集合。
		1.枚举的声明与定义
			a.枚举中每个成员(标识符)结束符是","而不是";"，最后一个成员可省略","。
			b.枚举中每个成员(标识符)的取值称为枚举常量，默认从"0"开始，初始化时可以赋值，以后的标识符仍依次加"1"。
			c.枚举变量只能取枚举说明结构中的某个标识符常量。
		2.枚举的优点
			a.增加代码的可读性和可维护性。
			b.和"#define"宏定义的标识符相比较，枚举具有类型检查，更加严谨。
			c.防止了命名污染(封装)。
			d.便于调试。
			e.使用方便，一次可以定义多个常量。
		3.枚举的使用
*/

////枚举的声明与定义示例
//enum Color//声明一个类型"enum Color"。
//{
//	//以下为枚举成员的声明(标识符)
//	RED = 0,
//	GREEN = 47,
//	BLUE = 167
//}R = RED;//创建枚举变量的第一种方式：使用"enum Color"类型创建"R"变量，此为全局变量；"enum Color R = RED"定义枚举变量并进行初始化(嵌套)。
//
//int main()
//{
//	enum Color G = GREEN;//创建枚举变量的第二种方式：使用"enum Color"类型创建"G"变量，此为局部变量。
//	enum Color B = BLUE;
//	printf("克莱因蓝->RGB(%d,%d,%d)\n", R, G, B);
//	return 0;
//}

////枚举的使用示例：计算器。
//enum Option
//{
//	Option_Exit,
//	Option_Add,
//	Option_Sub,
//	Option_Mul,
//	Option_Div
//};
//void Menu()
//{
//	printf("**************************************\n");
//	printf("**********   1.Add  2.Sub   **********\n");
//	printf("**********   3.Mul  4.Div   **********\n");
//	printf("**********      0.Exit      **********\n");
//	printf("**************************************\n");
//}
//int Add(int x, int y)
//{
//	return x + y;
//}
//int Sub(int x, int y)
//{
//	return x - y;
//}
//int Mul(int x, int y)
//{
//	return x * y;
//}
//int Div(int x, int y)
//{
//	return x / y;
//}
//int main()
//{
//	int input = 0, x = 0, y = 0;
//	do
//	{
//		Menu();
//		printf("Please Enter>>");
//		scanf_s("%d", &input);
//		switch (input)
//		{
//		case Option_Add:
//			printf("请输入两个正整数>>");
//			scanf_s("%d %d", &x, &y);
//			printf("%d\n", Add(x, y));
//			break;
//		case Option_Sub:
//			printf("请输入两个正整数>>");
//			scanf_s("%d %d", &x, &y);
//			printf("%d\n", Sub(x, y));
//			break;
//		case Option_Mul:
//			printf("请输入两个正整数>>");
//			scanf_s("%d %d", &x, &y);
//			printf("%d\n", Mul(x, y));
//			break;
//		case Option_Div:
//			printf("请输入两个正整数>>");
//			scanf_s("%d %d", &x, &y);
//			printf("%d\n", Div(x, y));
//			break;
//		case Option_Exit:
//			printf("Exit!");
//			break;
//		default:
//			printf("Input Error,Please Enter Again!\n");
//			break;
//		}
//		if (input)
//		{
//			system("pause");
//			system("cls");
//		}
//	} while (input);
//	return 0;
//}

/*
	联合体(共用体)：一种具有多个类型或格式的值或者把它定义为一种由具有这样的值的变量形成的数据结构。
		1.联合体的声明与定义
		2.联合体的特点：与枚举和结构体不同的是，一个联合体的长度等于其内部长度最大的成员的长度，并且它们都共享着同一段内存。
		3.联合体大小的计算
			a.联合体的大小至少是最大成员的大小。
			b.当最大成员的大小不是最大对齐数的整数倍时，就要对齐到最大对齐数的整数倍。
		4.联合体的使用
*/

////联合体的声明与定义示例
//union MyUnion//声明一个类型"union MyUnion"。
//{
//	//以下为联合体成员变量的声明。
//	char x;
//	int y;
//}X = { 0 };//创建联合体变量的第一种方式：使用"union MyUnion"类型创建"X"变量，此为全局变量；"union MyUnion X = { 0 }"定义联合体变量并进行初始化(嵌套)。
//
//int main()
//{
//	union MyUnion Y = { 0 };//创建联合体变量的第二种方式：使用"union MyUnion"类型创建"Y"变量，此为局部变量。
//	printf("%zu\n", sizeof(X));//因为联合体的大小至少是最大成员的大小，并且最大成员的大小是最大对齐数的整数倍，所以得出结果是"4"。
//	return 0;
//}

////联合体的特点示例
//union MyUnion
//{
//	int x;
//	char y;
//};
//
//int main()
//{
//	union MyUnion X = { 5 };//调试发现"X"中的"x"与"y"的值都为"5"，说明联合体的成员是共用同一块内存空间的。
//
//	//因为联合体的成员是共用同一块内存空间的，所以以下输出的结果都相同。
//	printf("%p\n", &X);
//	printf("%p\n", &(X.x));
//	printf("%p\n", &(X.y));
//
//	X.x = 1000;
//	//调试发现当执行完代码"X.x = 1000;"后，"x"被赋值为"1000"、"y"被赋值为"-24"。
//	//十进制"1000"的二进制值为"00000000000000000000001111101000"。
//	//当以"X.x"赋值，即以"int"类型赋值，能赋值"32"位比特位的数据给联合体的存储单元，读取也是"32"位，故"x"为"1000"(十进制)。
//	//因为"y"为"char"类型，读取存储单元会发生截断，也就是只能读取二进制的"111101000"，其中最高位是符号位，转换为原码后得出结果为"-24"(十进制)。
//
//	X.y = 100;
//	//调试发现当执行完代码"X.y = 100;"后，"x"被赋值为"868"，"y"被赋值为"100"。
//	//十进制"100"的二进制值为"00000000000000000000000001100100"。
//	//当以"X.y"赋值，即以"char"类型赋值，只能赋值"8"位比特位的数据给联合体的存储单元，也就是赋值二进制"01100100"，故联合体的存储单元低八位被赋值，其余位不变。
//	//因为"y"为"char"类型，读取存储单元会发生截断，也就是只能读取二进制的"01100100"，故"y"为"100"(十进制)。
//	//联合体的存储单元只有低八位被改变，其余位不变，故此时联合体存储单元的二进制值为"00000000000000000000001101100100"，"x"读取"32"位数据，故"x"为"868"。
//
//	return 0;
//}

////联合体大小的计算示例
//union MyUnion
//{
//	char x[5];
//	int y;
//};
//
//int main()
//{
//	printf("%zu\n", sizeof(union MyUnion));//得出的结果是"8"。
//	//"union MyUnion"联合体的类型的大小取其联合体最大成员的大小，即"char [5]"类型。
//	//但"char [5]"类型的大小为"5"字节，不是最大对齐数的整数倍，故会扩展联合体的大小到联合体成员的最大对齐数的整数倍。
//	//即以"int"类型的对齐数"4"作为最大对齐数，故扩展到"8"对齐数，所以此联合体的大小为"8"字节。
//
//	return 0;
//}

////联合体的使用示例：判断当前计算机的大小端存储。
//int Check_System()
//{
//	union MyUnion
//	{
//		char x;
//		int y;
//	};
//	union MyUnion X = { 0 };
//	X.y = 1;
//	return X.x;
//}
//
//int main()
//{
//	if (Check_System() == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//
//	return 0;
//}
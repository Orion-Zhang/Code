#include <stdio.h>
#include <stdbool.h>

/*
	操作符
		01.算术操作符
		02.移位操作符
		03.按位操作符
		04.赋值操作符
		05.单目操作符
		06.关系操作符
		07.逻辑操作符
		08.三目操作符
		09.逗号操作符
		10.下标引用操作符
		11.函数调用操作符
		12.结构体相关操作符
		13.表达式
		14.运算符重载
*/

/**
	算术操作符："+"(加)、"-"(减)、"*"(乘)、"/"(除)、"%"(取模)。
		1.除了"%"(取模)操作符之外，其他的算术操作符都可以用作于整数以及浮点数。
		2.对于用于浮点数的运算来说，算术操作符的两个操作数至少有一个操作数要为浮点数(执行浮点数除法)，否则结果为整数(执行整数除法)。
		3."%"(取模)操作符的两个操作数必须为整数，运算后的结果为余数，即求余运算。
		4."%"(取模)操作符的两个操作数可以为负数，并且运算后的结果的符号与左操作数相同。
		5.C语言中的默认取整方式是向零取整，并非向负无穷大取整，即向零舍入，并且在C语言的数学标准函数库中具有多种方式的取整函数(头文件："math.h")。
*/

////算术操作符使用示例
//int main()
//{
//	////"/"(除)
//	//int a = 0;
//	//a = 5 / 2;
//	//printf("当两个操作数都是整数，并且变量类型为整型时：5 / 2 = %d。\n", a);
//	//
//	//int b = 0;
//	//b = -5 / 2;
//	//printf("当两个操作数都是整数，并且变量类型为整型时：-5 / 2 = %d。\n", b);//可发现结果为"-2"，故可得知C语言是默认向零取整的。
//	//
//	//double c = 0;
//	//c = 5 / 2;
//	//printf("当两个操作数都是整数，并且变量类型为双精度浮点型时：5 / 2 = %lf。\n", c);
//	//
//	//double d = 0;
//	//d = 5.0 / 2;
//	//printf("当两个操作数有浮点数，并且变量类型为双精度浮点型时：5.0 / 2 = %lf。\n", d);
//
//	////"%"(取模)
//	//int a = 0;
//	//a = -5 % 2;//取模操作符两个操作数必须为整数。
//	//printf("-5 %% 2 = %d。\n", a);//结果为："-1"，故可得知取模操作符是进行求余运算的；"printf"函数若要打印出"%"符号，需要再添加一个"%"符号。
//	//
//	//int b = 0;
//	//b = 5 % -2;
//	//printf("5 %% -2 = %d。\n", b);//结果为："1"，故可得知取模操作符结果的符号是与左操作数相同的。
//
//	return 0;
//}

/**
	移位操作符："<<"(左移)、">>"(右移)。
		1.原码、反码、补码：都为数值的二进制表示形式，计算机中数值一律以补码的形式进行存储。
			a.正整数：原码、反码、补码皆相同。
			b.负整数：原码即一个数值原本的二进制(最高位为"1"表示负数，即符号位)、反码是由原码的符号位不变其他位按位取反得来的、补码是在反码的基础上再加"1"得来的。
			c.原码补码相互转换：符号位不变其他位按位取反再加"1"。
		2.移位操作符移动的是二进制位，并且移位操作符的两个操作数只能是整数。
		3."<<"(左移)：分为逻辑移位和算术移位。
			a.逻辑移位与算术移位相同，数值的最高位抛弃，最低位补"0"。
			b.对于数值的变化：当一个数左移"N"位时，相当于这个数乘以"2"的"N"次方。(适用于移位后被抛弃的所有高位里面没有"1")
		4.">>"(右移)：分为逻辑移位和算术移位。
			a.逻辑移位：数值的最高位补"0"，最低位抛弃。
			b.算术移位：数值的最高位由原符号位补充，最低位抛弃。
			c.对于无符号的数来说，编译器通常采取逻辑右移，因算术右移对无符号数无意义。
			d.对于数值的变化：除了负奇数外，当一个数右移"N"位时，相当于这个数除以"2"的"N"次方。(若数为奇数则结果默认向零取整)
				1.当数为非负数时，右移一位等价于除以二。
				2.当数为负数并且为偶数时，右移一位等价于除以二。
				3.当数为负数并且为奇数时，负数的奇数除以二会比右移一位大一。
		5.未定义行为：对于移位操作符移动负数位，这是标准未定义的。
*/

////移位操作符使用示例
//int main()
//{
//	////"<<"(左移)示例
//	//int a = 1;
//	//int b = a << 1;//不会改变"a"的值。
//	//printf("%d << 1 = %d\n", a, b);
//	////"a"的补码：00000000000000000000000000000001。
//	////"b"的补码：00000000000000000000000000000010。
//
//	////">>"(右移)正奇数示例
//	//int a = 3;
//	//printf("%d >> 1 = %d\n", a, a >> 1);
//	//printf("%d / 2 = %d\n", a, a / 2);//奇数则结果默认向零取整。
//	////"a"右移前补码：00000000000000000000000000000011。
//	////"a"右移后补码：00000000000000000000000000000001。
//	
//	////">>"(右移)负奇数示例
//	//int a = -3;
//	//printf("%d >> 1 = %d\n", a, a >> 1);
//	//printf("%d / 2 = %d\n", a, a / 2);//奇数则结果默认向零取整。
//	////"a"右移前原码：10000000000000000000000000000001。
//	////"a"右移前反码：11111111111111111111111111111110。
//	////"a"右移前补码：11111111111111111111111111111101。
//	////"a"右移后原码：10000000000000000000000000000010。
//	////"a"右移后反码：11111111111111111111111111111101。
//	////"a"右移后补码：11111111111111111111111111111110。
//
//	////">>"(右移)正偶数示例
//	//int a = 4;
//	//printf("%d >> 1 = %d\n", a, a >> 1);
//	//printf("%d / 2 = %d\n", a, a / 2);
//	////"a"右移前补码：00000000000000000000000000000100。
//	////"a"右移后补码：00000000000000000000000000000010。
//
//	////">>"(右移)负偶数示例
//	//int a = -4;
//	//printf("%d >> 1 = %d\n", a, a >> 1);
//	//printf("%d / 2 = %d\n", a, a / 2);
//	////"a"右移前原码：10000000000000000000000000000100。
//	////"a"右移前反码：11111111111111111111111111111011。
//	////"a"右移前补码：11111111111111111111111111111100。
//	////"a"右移后原码：10000000000000000000000000000010。
//	////"a"右移后反码：11111111111111111111111111111101。
//	////"a"右移后补码：11111111111111111111111111111110。
//
//	////无符号数逻辑右移示例
//	//unsigned int a = 0x80000001;//十进制："2147483649"。
//	//printf("%u >> 1 = %u\n", a, a >> 1);
//	//printf("%u / 2 = %u\n", a, a / 2);
//	////"a"右移前补码：10000000000000000000000000000001。
//	////"a"右移后补码：01000000000000000000000000000000。//十进制："1073741824"。
//
//	return 0;
//}

/**
	按位操作符："&"(按位与)、"|"(按位或)、"^"(按位异或)。
		1."&"(按位与)：两操作数对应的二进制位进行按位与，都为"1"则为"1"，否则为"0"。
		2."|"(按位或)：两操作数对应的二进制位进行按位或，若有一边为"1"则为"1"，否则为"0"。
		3."^"(按位异或)：对应的二进制位进行按位异或，相同为"0"，相异为"1"。
*/

////按位操作符使用示例
//int main()
//{
//	int a = 0;
//	
//	//"&"(按位与)
//	a = 06 & 10;
//	printf("06 & 10=%d\n", a);
//	//"06"的补码：00000000000000000000000000000110。
//	//"10"的补码：00000000000000000000000000001010。
//	//"06&10"为：00000000000000000000000000000010。(即"2"的二进制)
//
//	//"|"(按位或)
//	a = 06 | 10;
//	printf("06 | 10=%d\n", a);
//	//"06"的补码：00000000000000000000000000000110。
//	//"10"的补码：00000000000000000000000000001010。
//	//"06|10"为：00000000000000000000000000001110。(即"14"的二进制)
//
//	//"^"(按位异或)
//	a = 06 ^ 10;
//	printf("06 ^ 10=%d\n", a);
//	//"06"的补码：00000000000000000000000000000110。
//	//"10"的补码：00000000000000000000000000001010。
//	//"06^10"为：00000000000000000000000000001100。(即"12"的二进制)
//
//	return 0;
//}

////按位操作符例题一：使用按位异或的方法，不创建临时变量，实现两个数的交换。
//int main()
//{
//	int a = 3, b = 5;
//	
//	printf("交换前：a = %d，b = %d。\n", a, b);
//	
//	//方法一
//	//a = a ^ b;
//	////"a"的补码：00000000000000000000000000000011。("3"的二进制)
//	////"b"的补码：00000000000000000000000000000101。("5"的二进制)
//	////异或结果为：00000000000000000000000000000110。("6"的二进制)
//	//
//	//b = a ^ b;
//	////"a"的补码：00000000000000000000000000000110。("6"的二进制)
//	////"b"的补码：00000000000000000000000000000101。("5"的二进制)
//	////异或结果为：00000000000000000000000000000011。("3"的二进制)
//	//
//	//a = a ^ b;
//	////"a"的补码：00000000000000000000000000000110。("6"的二进制)
//	////"b"的补码：00000000000000000000000000000011。("3"的二进制)
//	////异或结果为：00000000000000000000000000000101。("5"的二进制)
//
//	//方法二
//	//(a ^ b) && (b ^= a ^= b, a ^= b);
//	
//	printf("交换后：a = %d，b = %d。\n", a, b);
//	
//	return 0;
//}

////按位操作符例题二：求一个整数存储在内存中的二进制中"1"的个数。
//int main()
//{
//	int num = -1, count = 0;
//	//"-1"的原码：10000000000000000000000000000001。
//	//"-1"的反码：11111111111111111111111111111110。
//	//"-1"的补码：11111111111111111111111111111111。
//	
//	while (num)
//	{
//		num = num & (num - 1);
//		count++;
//	}
//	
//	printf("count = %d\n", count);
//	
//	return 0;
//}

////按位操作符例题三：打印出输入的数的二进制位。
//void PrintBinary(int x)
//{
//	printf("%d(Binary):", x);
//	for (int i = 31; i >= 0; i--)
//	{
//		printf("%c", (x & (1 << i)) == 0 ? '0' : '1');//必须判断是否为"0"。
//	}
//	printf(".\n");
//}
//int main()
//{
//	int input = 0;
//	printf("Please Enter>>");
//	scanf_s("%d", &input);
//	PrintBinary(input);
//	return 0;
//}

/**
	赋值操作符
		1.单独赋值符："="(等于)。
			a.赋值符的左操作数必须为变量，不可为常量或表达式(必须可修改)。
			b.可以连续赋值，并且赋值操作符是从右向左结合，即从右向左进行赋值的。
			c.注意赋值操作符"="(等于)和关系操作符"=="(判断是否相等)的区分。
			d.在C语言中，初始化和赋值并没有真正的区分，但两者是有微妙的区别的，初始化在创建变量时为变量提供初始值，赋值在变量创建后的某个时刻给变量一个值。
			e.赋值操作符是在两个已经存在的对象间进行的，而初始化是要创建一个新的对象，并且其初值的来源是于另一个已存在的对象。
		2.复合赋值符："+="(加等)、"-="(减等)、"*="(乘等)、"/="(除等)、"%="(模等)、"<<="(左移等)、">>="(右移等)、"&="(按位与等)、"|="(按位或等)、"^="(按位异或等)。
			a.在赋值符"="之前加上其它二目运算符构成复合赋值符，并且复合赋值符就是单独赋值符的左操作数与右操作数进行运算并赋值给左操作数的操作符。
			b.利于编译处理，能提高编译效率并产生质量较高的目标代码。
*/

////赋值操作符例题：使用复合赋值符，不创建临时变量，实现两个数的交换。
//int main()
//{
//	int a = 3, b = 5;
//	
//	printf("交换前：a = %d，b = %d。\n", a, b);
//
//	(a ^ b) && (b ^= a ^= b, a ^= b);//等价于"(a ^ b) && (b = b ^ (a = a ^ b), a = a ^ b);"。
//	
//	printf("交换后：a = %d，b = %d。\n", a, b);
//	
//	return 0;
//}

/**
	单目操作符：只有一个操作数的操作符。
		1.逻辑反操作操作符："!"。
		2.正负值操作符："+"、"-"。
		3.取地址操作符："&"。
		4.计算操作数类型大小操作符："sizeof"。(结果单位为字节)("sizeof"同样也是关键字)
		5.取反操作符："~"。
		6.前后置自增自减操作符：前置"++"、后置"++"、前置"--"、后置"--"。
		7.间接访问操作符(解引用操作符)："*"。
		8.强制类型转换操作符："(type)"。("type"表示类型)
*/

////逻辑反操作操作符示例
//int main()
//{
//	bool flag = true;
//
//	if (flag)
//	{
//		printf("flag = true\n");
//	}
//
//	flag = false;
//
//	if (!flag)//进行了逻辑反操作，当"flag = false"时，进行逻辑反操作后将"false"反操作为"true"，故表达式整体为真进入"if"语句。
//	{
//		printf("flag = false\n");
//	}
//
//	int a = -1;
//
//	printf("!a = %d\n", !a);//"-1"表示为真，进行逻辑反操作后变成假，即"0"。
//
//	return 0;
//}

////正负值操作符示例
//int main()
//{
//	int a = +10;//正值操作符("+")是可以省略的。
//
//	int b = -10;
//
//	int c = -b;//负负得正。
//
//	printf("a = %d\nb = %d\nc = %d\n", a, b, c);
//
//	return 0;
//}

////取地址操作符示例
//int main()
//{
//	int a = 0;
//
//	int* ptr = &a;//取出变量"a"的地址，将其存放到指针变量中。
//
//	printf("&a = %p\n", &a);
//
//	printf("ptr = %p\n", ptr);
//
//	return 0;
//}

////计算操作数类型大小操作符示例
//int main()
//{
//	int a = 0;
//
//	printf("sizeof(a) = %zu\n", sizeof(a));//计算的是"a"变量所占空间的大小，单位是字节(不再重复)。
//
//	printf("sizeof a = %zu\n", sizeof a);//括号是可以在计算变量所占空间的大小时省略的。
//
//	printf("sizeo(int) = %zu\n", sizeof(int));//计算的是"int"类型所创建的变量占据空间的大小，注意当计算类型大小时不可以省略"sizeof"后面的括号。
//
//	printf("a = %d\nsizeof(a++) = %zu\na = %d\n", a, sizeof(a++), a);//除了C99标准中的柔性数组外，"sizeof"是在编译时进行求值，故此处只计算变量"a"所占空间的大小，但不会改变变量"a"的值。
//
//	char arr1[] = "KiiluaAoki";
//
//	int arr1_size = (int)sizeof(arr1) / (int)sizeof(arr1[0]);//在"VS2022"中"sizeof"计算后的返回值类型为"size_t"，此处进行了强制类型转换(详见强制类型转换操作符示例)。
//
//	printf("arr1_size = %d\n", arr1_size);//当计算字符串的字符个数时，会将"\0"一起计算。
//
//	int arr2[] = { 1,2,3,4,5,6,7,8,9,10 };
//
//	printf("sizeof(arr2) = %zu\n", sizeof(arr2));//当"sizeof"括号内只有数组名是，计算的是整个数组的大小。
//
//	printf("sizeof(arr2 + 0) = %zu\n", sizeof(arr2 + 0));//此处计算的是指针(地址)所占空间的大小，在不同位数的平台结果不相同。
//
//	short b = 0;
//
//	int c = 10;
//
//	printf("sizeof(b = c + 2) = %zu\n", sizeof(b = c + 2));//变量具有值属性与类型属性，"sizeof"会推算出表达式中变量的类型属性，所以此处计算的是短整型类型的大小，并且不会改变变量"b"的值。
//
//	return 0;
//}

////取反操作符示例
//int main()
//{
//	int a = -1;
//
//	printf("~a = %d\n", ~a);//取反操作符是对变量中存放的数值进行按位取反。
//	//"-1"的原码：10000000000000000000000000000001。
//	//"-1"的反码：11111111111111111111111111111110。
//	//"-1"的补码：11111111111111111111111111111111。
//	//"-1"取反后：00000000000000000000000000000000。
//
//	return 0;
//}

////取反操作符例题：将"12"的二进制位的最低位前一位置成"1"并打印结果，打印结果后将其还原为"0"再打印结果。
//int main()
//{
//	int num = 12;
//
//	num |= (1 << 1);
//
//	printf("%d\n", num);
//
//	num &= (~(1 << 1));
//
//	printf("%d\n", num);
//
//	return 0;
//}

////前后置自增自减操作符示例
//int main()
//{
//	int a = 0;
//	
//	printf("%d\n", a++);//后置"++"：先使用，再自增。
//	printf("%d\n", ++a);//前置"++"：先自增，再使用。
//	printf("%d\n", a--);//后置"--"：先使用，再自减。
//	printf("%d\n", --a);//前置"--"：先自减，再使用。
//	
//	return 0;
//}

////间接访问操作符(解引用操作符)示例
//int main()
//{
//	int a = 10;
//
//	int* ptr = &a;
//
//	printf("*ptr = %d\n", *ptr);//通过解引用操作符从整型指针变量"ptr"所存放变量"a"的地址间接访问到变量"a"。
//
//	printf("++(*ptr) = %d\n", ++(*ptr));//注意是前置"++"。
//
//	return 0;
//}

////强制类型转换操作符示例
//int main()
//{
//	int a = (int)3.14;//将双精度浮点数类型强制转换为整型。
//
//	printf("a = %d\n", a);
//
//	return 0;
//}

/**
	关系操作符：">"、">="、"<"、"<="、"!="、"=="。
		1.注意赋值操作符"="(等于)和关系操作符"=="(判断是否相等)的区分。
		2.比较两个字符串是否相等需要使用函数，不可以直接使用"=="判断相等。
*/

////关系操作符示例
//int main()
//{
//	int a = 0, b = 0;
//
//	if (a == b)//当变量"a"与变量"b"相等时，则"a == b"表达式的结果为真。
//	{
//		printf("%d == %d\n", a, b);
//	}
//	else
//	{
//		printf("%d != %d\n", a, b);
//	}
//
//	return 0;
//}

/**
	逻辑操作符："&&"(逻辑与)、"||"(逻辑或)、"!"(逻辑反)。
		1.注意与按位操作符进行区分。
		2."&&"(逻辑与)是从左操作数到右操作数遍历代码的，一旦为假，则不会再向右操作数执行。
		3."||"(逻辑或)是从左操作数到右操作数遍历代码的，一旦为真，则不会再向右操作数执行。
		4.C语言中，非"0"表示真，"0"表示假，但需注意逻辑操作符的结果只有"0"或者"1"。
		5.在C99标准中，C语言引入了布尔类型，使用时需要引用头文件："stdbool.h"，故C99标准前无布尔类型。(详见分支和循环语句)
*/

////逻辑操作符示例一
//int main()
//{
//	int a = 0, b = 0, c = 0, d = 0;
//	
//	a = 0, b = 2, c = 3, d = 4;
//	a++ && ++b && d++;
//	printf("a = %d b = %d c = %d d = %d\n", a, b, c, d);
//
//	a = 0, b = 2, c = 3, d = 4;
//	a++ || ++b || d++;
//	printf("a = %d b = %d c = %d d = %d\n", a, b, c, d);
//
//	return 0;
//}

////逻辑操作符示例二
//int main()
//{
//	int a = 0;
//
//	int b = 1;
//
//	printf("a && b = %d\na || b = %d\n!a = %d\n", a && b, a || b, !a);//逻辑操作符的结果只有"0"或者"1"。
//
//	return 0;
//}

/**
	三目操作符："exp1 ? exp2 : exp3"，即条件操作符，是唯一具有三个操作数的操作符。
		1."exp1 ? exp2 : exp3"，其中"exp1"、"exp2"和"exp3"为表达式。
		2.若只有"exp1 ? exp2 : exp3"，先执行"exp1"表达式，然后进行判断，若结果为真，则执行"exp2"表达式，整体结果为"exp2"表达式的结果，否则则执行"exp3"表达式，整体结果就为"exp3"表达式的结果。
		3.一个条件表达式不会同时执行三个表达式，即"exp1 ? exp2 : exp3"只会执行"exp1"以及"exp2"(真)或者"exp3"(假)。
		4.条件表达式可以嵌套使用，条件表达式一般是右结合的，即当有多组条件表达式会从右向左分组执行条件表达式。
*/

////三目操作符示例：使用三目操作符实现找两个数中较大值。
//int main()
//{
//	int a = -1, b = 1;
//	printf("%d\n", a > b ? a : b);//如果"a > b"为真，则输出"a"，否则输出"b"。
//	return 0;
//}

/**
	逗号操作符：在C语言和C++语言中，可以把多个表达式用逗号操作符联接起来或者说把这些表达式用逗号分开，构成一个更大的表达式，即逗号表达式。
		1.逗号表达式中用逗号分开的表达式分别求值，从左向右依次执行，整个表达式的结果是最后一个表达式的结果。
		2.注意赋值运算符的优先级高于逗号运算符。
*/

////逗号操作符示例一
//int main()
//{
//	int a = 1, b = 2;
//	
//	int c = (a > b, a = b + 10, a, b = a + 1);
//
//	printf("%d\n", c);
//
//	return 0;
//}

////逗号操作符示例二
//int main()
//{
//	int a = 0, b = 0, c = 0, d = 0;//使用逗号操作符初始化多个局部变量，类型都为"int"。
//	
//	int* pa = &a, * pb = &b, * pc = &c, * pd = &d;//若是指针则需要在变量名前加上"*"表示指针变量。
//
//	if (a = b + 1, c = a / 2, d > 0)
//	{
//		printf("Aoki\n");
//	}
//	else
//	{
//		printf("Killua\n");
//	}
//
//	printf("a = %d\nb = %d\nc = %d\nd = %d\n", *pa, *pb, *pc, *pd);
//	
//	return 0;
//}

/**
	下标引用操作符："[]"。
		1.通过下标访问操作符可以访问到数组对应下标的元素，从而获取或修改数组对应下标元素的值。
		2.需要区分创建数组时的方括号，创建数组时的方括号是数组的语法格式，与下标引用操作符无关。
		3.下标引用操作符属于双目操作符，一般情况下，下标引用操作符的左操作数是一个数组名，右操作数是一个索引值，但相反也是可以的。
*/

////下标引用操作符示例
//int main()
//{
//	int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };//此处的方括号是创建数组时的语法格式。
//
//	for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
//	{
//		printf("%d\n", i[arr]);//通过下标引用操作符获取数组的值，因"arr[i]"等价于"*(arr + i)"，并且"*(arr + i)"可以写成"*(i + arr)"，故"arr[i]"等价于"i[arr]"。
//	}
//
//	return 0;
//}

/**
	函数调用操作符："()"。
		1.调用函数必须加上"()"。
		2.函数调用操作符可接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。
*/

////函数调用操作符示例：以下程序的运行结果是什么？
//void Test1(int arr[])
//{
//	printf("%zu\n", sizeof(arr));//结果为：4/8。
//}
//
//void Test2(char ch[])
//{
//	printf("%zu\n", sizeof(ch));//结果为：4/8。
//}
//
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	
//	printf("%zu\n", sizeof(arr));//结果为：40。
//	
//	printf("%zu\n", sizeof(ch));//结果为：10。
//	
//	Test1(arr);
//	
//	Test2(ch);
//	
//	return 0;
//}

/**
	结构体相关操作符
		1."."：以结构体访问结构体成员，即左操作数为结构体，右操作数为结构体成员名。
		2."->"：以结构体指针访问结构体成员，即左操作数为结构体的指针，右操作数为结构体成员名。
*/

////结构体相关操作符示例
//struct Book
//{
//	char name[20];
//	int price;
//};
//
//int main()
//{
//	struct Book a = {"C", 55};
//	struct Book* pa = &a;
//
//	printf("书名：%s\n", a.name);//通过结构体使用"."操作符访问成员。
//	printf("定价：%d\n", a.price);
//	printf("书名：%s\n", pa->name);//通过结构体的指针使用"->"操作符访问成员，蕴含着对指针的解引用。
//	printf("定价：%d\n", pa->price);
//	printf("书名：%s\n", (*pa).name);//将结构体的指针解引用，再通过"."操作符也可以访问成员。
//	printf("定价：%d\n", (*pa).price);
//
//	return 0;
//}

/**
	表达式
		1.表达式求值
			a.表达式求值的顺序一部分是由操作符的优先级与操作符的结合性决定的。
			b.有些表达式的操作数在求值的过程中可能需要转换为其他类型。
		2.隐式类型转换
			a.整型提升
				1.C语言的整型算术运算总是至少以缺省整型类型的精度来进行的。
				2.为了获得精度，表达式中的字符类型操作数和短整型操作数在使用之前类型会被转换为普通整型，这种转换称为整型提升。
				3.处理器内的"ALU"(整型运算器)的操作数的字节长度一般就是整型类型"int"的字节长度，同时也是处理器的通用寄存器的长度。
				4.整型提升是按照变量的数据类型的符号位来提升的。
				5.若是无符号数的整型提升，则为高位补"0"。
			b.算术转换
				1.若操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。
				2.如果某个操作数的类型在层次体系中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
				3.层次体系："long double > double > float > unsigned long int > long int > unsigned int > int"。
		3.操作符的属性
			a.影响复杂表达式求值的三个影响因素：操作符的优先级、操作符的结合性、是否控制求值顺序。
			b.表达式中相邻的操作符先执行哪个是取决于优先级的，如果优先级相同，则取决于结合性。
			c.逻辑操作符、三目操作符、逗号表达式可以控制操作符的求值顺序，具体请看对应操作符解析。
		4.问题表达式：表达式如果不能通过操作符的属性确定唯一的计算路径，那么这类表达式在不同环境下可能有不同的执行结果，这样的表达式就是问题表达式。
*/

////整型提升示例一
//int main()
//{
//	char a = 3;
//	//"int"类型中完整的"a"的补码：00000000000000000000000000000011。
//	//"char"类型中发生截断后"a"的补码：00000011。
//	
//	char b = 127;
//	//"int"类型中完整的"b"的补码：00000000000000000000000001111111。
//	//"char"类型中发生截断后"b"的补码：01111111。
//	
//	char c = a + b;//"a"与"b"都为字符类型，没有达到普通整型大小，计算会发生整型提升。
//	//"int"类型中完整的"a"的补码：00000000000000000000000000000011。
//	//"int"类型中完整的"b"的补码：00000000000000000000000001111111。
//	//"int"类型中完整的"c"的补码：00000000000000000000000010000010。(还未发生截断)
//	//存入"char"类型会发生截断，"char"类型中完整的"c"的补码：：10000010。
//	
//	printf("%d\n", c);//打印的结果为：-126。
//	//发现要以整型为格式化数据打印，故"c"会进行整型提升再打印。
//	//"c"整型提升后的补码：11111111111111111111111110000010。
//	//"c"整型提升后的反码：11111111111111111111111110000001。
//	//"c"整型提升后的原码：10000000000000000000000001111110。
//	//故打印的结果为：-126。
//
//	return 0;
//}

////整型提升示例二
//int main()
//{
//	char a = 0xb6;
//	//以十六进制赋值，转换为二进制为：10110110。
//	
//	short b = 0xb600;
//	//以十六进制赋值，转换为二进制为：1011011000000000。
//	
//	int c = 0xb6000000;
//	//以十六进制赋值，转换为二进制为：10110110000000000000000000000000。
//
//	if (a == 0xb6)
//		printf("a");//无法打印：经过了整型提升，"a"变成了负数，故不相同。
//	
//	if (b == 0xb600)
//		printf("b");//无法打印：经过了整型提升，"b"变成了负数，故不相同。
//	
//	if (c == 0xb6000000)
//		printf("c");//打印成功：没有经过整型提升。
//
//	return 0;
//}

////整型提升示例三
//int main()
//{
//	char c = 1;
//	printf("%zu\n", sizeof(c)); //打印结果为：1。
//	printf("%zu\n", sizeof(+c));//因"sizeof"是在编译时进行运算，故"c"会进行整型提升后再由"sizeof"推断出类型大小从而计算，故打印结果为：4。
//	printf("%zu\n", sizeof(-c));//因"sizeof"是在编译时进行运算，故"c"会进行整型提升后再由"sizeof"推断出类型大小从而计算，故打印结果为：4。
//	printf("%zu\n", sizeof(!c));//不同环境结果不同：于"VS2022"编译运行，结果为：1，若使用"GCC"编译运行，则结果为：4。
//	return 0;
//}

////算术转换示例
//int main()
//{
//	int a = 4;
//	float b = 4.5f;
//	printf("%f\n", a + b);//类型不相同，会发生算术转换；由精度较低的"int"类型转换为精度较高的"float"类型，再以"float"类型为格式化数据打印。
//	
//	float c = 3.14;
//	int num = c;//编译器发生警告，故算术转换需合理，否则会有一些潜在的问题，如：丢失精度等。
//	printf("%d\n", num);
//
//	return 0;
//}

////影响复杂表达式求值的三个影响因素示例：具体请查阅"操作符优先级"表格。
//int main()
//{
//	int a = 4;
//	int b = 5;
//
//	int c = a + b * 7;//决定计算顺序因素：优先级。
//	int d = a + b + 7;//决定计算顺序因素：结合性。
//
//	printf("a + b * 7 = %d\n", c);
//	printf("a + b + 7 = %d\n", d);
//	
//	return 0;
//}

////问题表达式示例
//int main()
//{
//	int a = 0, b = 0;
//	
//	a * a + a * a + a * a;//由于"*"比"+"的优先级高，只能保证"*"的计算比"+"早，但优先级并不能决定第三个"*"比第一个"+"早。
//		
//	b + --b;//操作符的优先级只能决定"--"的运算在"+"的运算的前面，但"+"的左操作数的获取在右操作数求值之前还是之后是不得而知的。
//	
//	return 0;
//}

////问题表达式例题一
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i = %d\n", i);//在不同环境下运行，会产生不同的结果。
//	return 0;
//}

////问题表达式例题二
//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();//函数的调用先后顺序无法通过操作符的优先级确定的。
//	printf("%d\n", answer);
//	return 0;
//}

////问题表达式例题三
//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);//可调试查看汇编代码，得知当前环境下的执行顺序。
//	printf("%d\n%d\n", ret, i);//在不同环境下运行，会产生不同的结果。
//	return 0;
//}

/**
	运算符重载
		1.不难发现，在C语言中有许多相同符号但是功能并不相同的符号，这是因为发生了运算符重载。
		2.通过运算符重载，同一个运算符将有不同的含义，编译器可通过上下文来确定运算符的含义。
		3.在C++语言中，扩展了运算符重载的概念，允许为用户定义的类型(类)重新定义运算符的含义。
*/

////运算符重载示例
//int main()
//{
//	int a = 10;
//
//	printf("0 & a = %d\n&a = %p\n", 0 & a, &a);//这里的"&"符号相同，但功能不同，即运算符重载。
//
//	return 0;
//}
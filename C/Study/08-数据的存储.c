#include <stdio.h>

/*
	数据类型的归类
		1.整型类型：char字符数据类型、short短整型、int整型、long长整型、long long更长的整型。
			a.char字符数据类型：通过ASCII字符集中的字母数值编码存储字符，常用来存储字符，但也可以把它当做比short更小的整型。
			b.每个整型类型都可分为无符号类型和有符号类型，char字符数据则由编译器决定。
		2.浮点类型：float单精度浮点类型、double双精度浮点类型、long double多精度浮点类型。
		3.构造类型：数组类型、struct结构体类型、enum枚举类型、union联合类型。
		4.指针类型：可使用各种类型。
		5.空类型：void空类型(无类型)。
			a.通常应用于函数的返回类型、函数的参数、指针类型。
*/

////整型类型和浮点类型的大小示例(各种类型的存储大小与系统位数有关)
//int main()
//{
//	printf("char\t\t存储大小:%zu byte\n", sizeof(char));
//	printf("short\t\t存储大小:%zu byte\n", sizeof(short));
//	printf("int\t\t存储大小:%zu byte\n", sizeof(int));
//	printf("long\t\t存储大小:%zu byte\n", sizeof(long));
//	printf("long long\t存储大小:%zu byte\n", sizeof(long long));
//	printf("float\t\t存储大小:%zu byte\n", sizeof(float));
//	printf("double\t\t存储大小:%zu byte\n", sizeof(double));
//	printf("long double\t存储大小:%zu byte\n", sizeof(long double));
//	return 0;
//}

/*
	整型类型在内存中的存储：整数中在内存中存储的是补码。
		1.整数的二进制有三种表示方法：原码(按照数据的数值直接写出的二进制序列就是原码)、反码、补码。
			a.对于正整数来说，原码、反码、补码相同。
			b.对于负整数来说，原码最高位为符号位(用1来表示负)；反码为原码按位取反后的值(符号位不变)；补码为反码+1。
			c.使用补码进行运算，可以将符号位和数值域统一处理。
			d.加法和减法也可以统一处理(CPU只有加法器)，并且补码和原码的相互转换运算过程是相同的，不需要额外的硬件电路。
		2.大端存储模式和小端存储模式：把数据的低位字节序的内容存放在高地址处，高位字节序的内容存放在低地址处，为大端存储模式；把数据的低位字节序的内容存放在低地址处，高位字节序的内容存放在高地址处，为小端存储模式;
			a.为什么会有大小端模式之分呢？
				(1).在计算机系统中，是以字节为单位的，每个地址单元都对应着一个字节，在C语言中存在超过一个字节的数据类型。
				(2).对于计算机位数大于8位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。
			b.常用的X86结构是小端模式，而51单片机则为大端模式。通常ARM、DSP都为小端模式，有些ARM处理器可以由硬件来选择大端模式还是小端模式。
		3.自行推算或查阅各类型的取值范围，包括有符号以及无符号类型。
			a.如"char"类型：当"char"值为"127"时，再加"1"会变成"-128"，自行推算、画图(轮回圈)并解释。
*/

////整型在内存中的存储示例
//int main()
//{
//	int a = -10;//调试观察"a"在内存中的存储，发现值为：f6ffffff，表示的是十六进制，并且是小端存储模式。
//	//"-10"原码：10000000000000000000000000001010。
//	//"-10"反码：11111111111111111111111111110101。
//	//"-10"补码：11111111111111111111111111110110。
//	
//	int b = 1 - 1;//通用CPU中只有加法器，减法是通过加法器进行运算的，故此行意为："1+(-1)"。
//	//"-1"原码：10000000000000000000000000000001。
//	//"-1"反码：11111111111111111111111111111110。
//	//"-1"补码：11111111111111111111111111111111。
//	//"1"补码 + "-1"补码 = (1)00000000000000000000000000000000(二进制最高位"1"被截断)。
//	
//	return 0;
//}

////大端存储模式和小端存储模式示例
//int check_system()
//{
//	int a = 1;
//	return (*(char*)&a);
//}
//int main()
//{
//	////通过调试观察是大端存储模式还是小端存储模式。
//	//int num = 0x700F0001;//内存中存储为：01000f70，为小端字节序。
//
//	////通过指针识别地址打印是大端存储模式还是小端存储模式。
//	//int a = 1;
//	//char* pa = (char*)&a;
//	//if (*pa == 1)
//	//{
//	//	printf("小端存储模式\n");
//	//}
//	//else
//	//{
//	//	printf("大端存储模式\n");
//	//}
//
//	////设计一个函数来判断当前机器的字节序。
//	//if (check_system())
//	//{
//	//	printf("小端存储模式\n");
//	//}
//	//else
//	//{
//	//	printf("大端存储模式\n");
//	//}
//
//	return 0;
//}	

////练习示例一
//int main()
//{
//	char a = -1;//将整数"-1"，放入"char"中，由编译器自行决定是有符号"char"还是无符号"char"，C语言无规定。
//	//"-1"原码：10000000000000000000000000000001。
//	//"-1"反码：11111111111111111111111111111110。
//	//"-1"补码：11111111111111111111111111111111。
//	//放入"char"中发生截断：11111111。
//	
//	signed char b = -1;//将整数"-1"，放入有符号"char"中，原理同上。
//	
//	unsigned char c = -1;//将整数"-1"，放入无符号"char"中，符号位变为数值位。
//	//"-1"原码：10000000000000000000000000000001。
//	//"-1"反码：11111111111111111111111111111110。
//	//"-1"补码：11111111111111111111111111111111。
//	//放入无符号"char"中发生截断：11111111，因为是无符号"char"，所以符号位变为数值位，正整数原码反码补码相同，故得出结果为：255，同时也是无符号"char"的最大值。
//	
//	printf("a=%d,b=%d,c=%d", a, b, c);//打印的结果为：a=-1,b=-1,c=255。
//	
//	return 0;
//}

////练习示例二
//int main()
//{
//	char a = -128;//将整数"-128"，放入"char"中。
//	//"-128"原码：10000000000000000000000010000000。
//	//"-128"反码：11111111111111111111111101111111。
//	//"-128"补码：11111111111111111111111110000000。
//	//放入"char"中发生截断：10000000。
//	
//	printf("%u\n", a);//以无符号整型的视角进行打印，会发生整型提升，并且符号位变为数值位。
//	//整型提升后：11111111111111111111111110000000。
//	//转换为十进制为：4294967168。
//	
//	return 0;
//}

////练习示例三
//int main()
//{
//	char a = 128;
//	//"128"补码：00000000000000000000000010000000。
//	//放入"char"中发生截断：10000000，会被直接解析成"-128"。
//	
//	printf("%d\n", a);//以无符号整型的视角进行打印，会发生整型提升，并且符号位变为数值位。
//	//整型提升后：11111111111111111111111110000000。
//	//转换为十进制为：4294967168。
//	return 0;
//}

////练习示例四
//int main()
//{
//	int i = -20;
//	//"-20"原码：10000000000000000000000000010100。
//	//"-20"反码：11111111111111111111111111101011。
//	//"-20"补码：11111111111111111111111111101100。
//	
//	unsigned int j = 10;
//	//"10"补码：00000000000000000000000000001010。
//	
//	printf("%d\n", i + j);//以有符号整型的视角进行打印。
//	//"10+(-20)"补码：11111111111111111111111111110110。
//	//"10+(-20)"反码：11111111111111111111111111110101。
//	//"10+(-20)"原码：10000000000000000000000000001010。
//	//转换为十进制为：-10。
//	
//	return 0;
//}

////练习示例五
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)//判断表达式恒成立，当无符号整型类型由"0"再减去一时，会变为"4294967295"，造成无限循环。
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}

////练习示例六
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));//"strlen"寻找字符串的结束标志"\0"，其ASCII值为"0",故只要找到"a"数组中的"0"即输出结果。
//	return 0;
//}

////练习示例七
//int main()
//{
//	unsigned char i = 0;
//	for (i = 0; i <= 255; i++)//判断表达式恒成立，当无符号"char"类型由"255"再加一时，会变为"0"，造成无限循环。
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}

/*
	浮点类型在内存中的存储：根据国际标准IEEE(电气和电子工程协会)754规定了浮点数在内存中存储的规则。
		1.根据规定，任意一个二进制浮点数可以表示为：(-1)^S * M * 2^E。
			a."S"表示符号位，若"S=0"则为正数，若"S=1"则为负数。
			b."M"表示有效数字位，并且"1<=M<2"。
			c."E"表示指数位。
		2.对于32/64位的浮点数，最高的1位是符号位"S"，接着的8/11位是指数位"E"，剩下的23/52位为有效数字位"M"。
		3.关于有效数字位"M"：因为计算机内部保存"M"时，默认这个数的第一位总是为：1，因此可以被舍去，这样做可以多出1位有效数字，待到读取时再把"M"第一位的1加上去。
		4.关于指数位"E"：存入内存"E"为无符号整数，但取出会分为三种情况："E"不全为0或不全为1、"E"全为0、"E"全为1。
			a.存入时"E"为无符号整数：8/11位取值范围为0~255/0~2047，因为科学计数法指数位是有可能出现负数的，所以754规定存入内存时"E"的真实值必须先加上一个中间数127/1023(十进制)，再转换成二进制存入内存。
			b.取出时"E"不全为0或不全为1时：反推即可，注意各进制的转换和运算以及"M"舍去的1需要加上。
			c.取出时"E"全为0时：规定"E"的真实值为1-127/1-1023、"M"不再加上舍去的1，而是还原为以0为首的小数(0.x)、这样做是为了表示0以及接近于0的值。
			d.取出时"E"全为1时：如果有效数字M全为0，表示值无穷大。
*/

////浮点类型在内存中的存储示例
//int main()
//{
//	float num = 5.5f;
//	//"5.5"二进制：101.1。
//	//"5.5"二进制转换为科学计数：1.011*2^2。(注意是二进制而不是十进制)
//	//根据规定将科学计数进行转换：(-1)^0 * 1.011 * 2^2，初步得出"S=0"、"M=1.011"、"E=2"。
//	//存入内存时："S"不变、"E"的真实值将加上中间数再转换为二进制存入、"M"的第一位1被舍去再存入。
//	//故存入内存中的值为：(S)0(E)10000001(M)01100000000000000000000。
//	//转换为十六进制进行展示：40B00000，又因为是小端存储模式，故为：0000B040。
//	
//	return 0;
//}

////浮点类型练习示例
//int main()
//{
//	int n = 9;//"9"补码：00000000000000000000000000001001。
//	
//	float* pFloat = (float*)&n;
//	
//	printf("n的值为：%d\n", n);//正常打印。
//	
//	printf("*pFloat的值为：%f\n", *pFloat);//将存入内存中的二进制序列以单精度浮点类型进行打印，即将内存中整型值"9"的二进制序列认为是浮点数的二进制序列，分析得出是一个非常小的数。
//
//	*pFloat = 9.0;
//	
//	printf("num的值为：%d\n", n);//将存入内存中的二进制序列以整型类型进行打印，即将内存中浮点数值"9.0"的二进制序列认为是整型值的二进制序列，分析得出值为：1091567616。
//	
//	printf("*pFloat的值为：%f\n", *pFloat);//正常打印。
//	
//	return 0;
//}
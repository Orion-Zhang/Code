#include <stdio.h>

/*
	指针
		1.指针介绍及使用
		2.指针变量的类型
		3.野指针
		4.指针运算
		5.指针和数组
		6.二级指针
		7.指针数组
*/

/**
	指针介绍及使用
		1.指针是内存中一个最小单元的编号，也就是地址，地址是用来唯一标示一块内存空间的，一个内存单元的大小是一个字节，一个字节对应了一个地址。
		2.指针通常指的是指针变量，是用来存放内存地址的变量，可通过取地址操作符取出变量的内存起始地址，将其存放到指针变量中。
		3.在"32"位机器中，地址是由"32"个"0"或"1"组成二进制序列，那么地址就得用"4"个字节的空间来存储，故一个指针变量的大小就是"4"个字节。
		4.在"64"位机器中，地址是由"64"个"0"或"1"组成二进制序列，那么地址就得用"8"个字节的空间来存储，故一个指针变量的大小就是"8"个字节。
*/

////指针使用示例
//int main()
//{
//	int a = 10;//在内存中开辟出一块空间，存储变量"a"占用了"4"个字节的空间，即占用了四个内存单元。
//	
//	int* p = &a;//将变量"a"的"4"个字节的第一个字节地址(内存起始地址)使用取地址操作符将地址取出并存放在指针变量"pa"中。
//	
//	printf("&a = %p\n", p);
//	
//	printf("当前机器为：%d位机器。\n", sizeof(p) == 4 ? 32 : 64);
//	
//	return 0;
//}

/**
	指针变量的类型
		1.指针变量的类型决定了指针变量的解引用权限，也就是指针变量解引用后能访问几个字节。
		2.指针变量的类型决定了指针变量每走一步能走多远，即步长或距离，也就是每次移动能移动几个字节。
		3.指针变量的类型不同，但解引用权限和步长相同，如："int*"和"float*"，这并不代表它们能够混用，因为它们的存储方式不同。
*/

////指针变量的类型示例一
//int main()
//{
//	int a = 0x11223344;//一位十六进制位为四位二进制位。
//	int arr[10] = { 0 };
//	
//	//解引用权限示例
//	char* pa = (char*)&a;
//	*pa = 0;//调试发现只有一个字节变成了"00"。
//	int* pb = &a;
//	*pb = 0;//调试发现四个字节都变成了"00"，说明了指针变量的类型决定了指针的解引用权限。
//	
//	//步长示例
//	int* pc = arr;
//	char* pd = (char*)arr;//发现"char*"类型的指针变量同样可以存放下数组首元素的地址。
//	printf("%p\n", pc);
//	printf("%p\n", pd);//打印发现和"pc"存放的地址相同。
//	printf("%p\n", pc + 1);
//	printf("%p\n", pd + 1);//打印发现和"pc + 1"表达式所得出的结果不同，因为"char*"类型决定了这个指针的步长为一个字节。
//	
//	return 0;
//}

////指针变量的类型示例二
//int main()
//{
//	int arr1[10] = { 0 };
//	int arr2[10] = { 0 };
//	char* pa = (char*)arr1;
//	int* pb = arr2;
//	for (int i = 0; i < 10; i++)
//	{
//		*(pa + i) = 1;//调试发现每次循环跳过一个字节，并且前十个字节的内容更改了。
//		*(pb + i) = 1;//调试发现每次循环跳过四个字节，并且每个数组元素都改为了"1"。
//	}
//	return 0;
//}

////指针变量的类型示例三
//int main()
//{
//	int a = 10;
//	int b = 10;
//
//	float* pa = (float*)&a;
//	int* pb = &b;
//
//	*pa = 100.0f;//指针变量"pa"是以单精度浮点型的方式存放进变量"a"中的。
//	*pb = 100;//指针变量"pb"是以整型的方式存放进变量"b"中的。
//
//	printf("a = %d\nb = %d\n", a, b);//因为单精度浮点型和整型在内存中存储的方式不同，导致了结果不同。
//
//	return 0;
//}

/**
	野指针：野指针就是指针指向的位置是不可知的(随机的、不正确的、没有明确限制的)。
		1.野指针成因：非法访问、越界访问、指针指向的空间释放。
		2.注意指针越界，C语言本身是不会检查数据的越界行为的，需自行注意。
		3.规避野指针：指针初始化为"NULL"(空值)或有效地址、小心指针越界、指针指向空间释放及时置成空值、避免返回局部变量的地址、使用指针前检查其有效性。
		4.规避野指针的好处是要么指针指向的是空值是空指针，要么指针指向的就是有效的地址，这样再检查其有效性就能尽量规避野指针减少错误。
*/

////野指针示例一：野指针的形成。
//int* Test()
//{
//	int a = 0;
//	return &a;
//}
//
//int main()
//{
//	////非法访问错误示例一
//	//int* p;//未初始化的局部指针变量，默认存放的是随机值，即野指针。
//	//*p = 1;//使用了未初始化的局部指针变量"p"，造成非法访问内存。
//	
//	////非法访问错误示例二
//	//int* p = Test();//局部变量或临时变量离开所在函数体后会被释放，造成野指针。
//	//*p = 20;//对野指针进行解引用操作，造成非法访问。
//
//	////越界访问错误示例
//	//int arr[10] = { 0 };
//	//int* p = arr;
//	//for (int i = 0; i <= 10; i++)
//	//{
//	//	*(p + i) = 1;//编译器报错并崩溃：变量"arr"周围的堆栈已损坏；因为当"i"为"10"时，指针所指向的位置非数组范围，造成越界访问。
//	//}
//
//	return 0;
//}

////野指针示例二：规避野指针。
//int main()
//{
//	NULL;//对"NULL"(空值)右键转到定义会发现其实是将"0"强制类型转换为"void*"无类型指针。
//	
//	int* pa = NULL;//指针初始化：当不知道指针变量应初始化为什么的时候，应直接初始化为"NULL"(空值)。
//	*pa = 10;//调试发现会引发异常"写入访问权限冲突，pa是nullptr"，所以要检查其有效性规避此问题。
//	
//	int* pb = NULL;
//	if (*pb != NULL)//使用指针前检查有效性，但并不能确保一定没有问题，如：局部变量或临时变量离开所在函数体后会被释放，但返回的地址并不是"NULL"(空值)。
//	{
//		*pb = 10;
//	}
//	
//	return 0;
//}

/**
	指针运算
		1.指针与整数运算。
			a.可以使用算术运算符"+"让指针与整数相加，整数会和指针所指向类型的大小(以字节为单位)相乘，然后把结果与初始地址相加。
			b.可以使用算术运算符"-"让指针与整数相减，确保指针是被减数，整数会和指针所指向类型的大小(以字节为单位)相乘，再与指针进行相减。
		2.指针与指针运算。
			a.可以使用算术运算符"-"让指针与指针相减，意为计算两个指针的差值，比如：计算两指针指向的数组元素之间有多少元素个数。
			b.若无特殊情况，指针与指针相加将是无意义行为。
		3.指针的关系运算。
			a.指针的关系运算常与指向相同类型数据的指针之间进行的关系运算，但不同类型的指针进行关系比较是无意义行为。
			b.指针与非零(即除"NULL"外)整数进行关系比较是无意义的。
*/

////指针运算示例
//void PrintfArray(int arr[], int size)
//{
//	for (int i = 0; i < size; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//}
//
//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//	int size = sizeof(arr) / sizeof(arr[0]);
//
//	//指针与整数运算示例
//	for (int* pa = arr; pa < &arr[5]; pa++)//"pa++"进行了指针与整数相加的运算，指针每次向高地址移动四个字节(指针的类型为"int*")；"&arr[5]"没有进行访问，所以并不构成越界访问。
//	{
//		*pa = 0;
//	}
//
//	PrintfArray(arr, size);
//
//	for (int* pa = &arr[4]; pa >= &arr[0]; pa--)//"pa--"进行了指针与整数相减的运算，指针每次向低地址移动四个字节(指针的类型为"int*")。
//	{
//		*pa = 1;
//	}
//
//	PrintfArray(arr, size);
//
//	//指针与指针运算示例
//	int* pa = &arr[0];//取出数组首元素的地址。
//	
//	int* pb = &arr[4];//取出数组最后一个元素的地址。
//	
//	printf("%lld\n", pb - pa);//结果为：4，也就是说指针减去指针得到结果是两个指针之间的元素个数。
//
//	//指针的关系运算示例
//	int* ptr = NULL;
//	if (ptr == NULL)//"ptr == NULL"即指针的关系运算。
//	{
//		printf("Pointer is NULL.\n");
//	}
//
//	return 0;
//}

////指针运算例题：使用指针运算，模拟实现"strlen"函数。
//size_t MyStrlen(char* ptr)
//{
//	char* tmp = ptr;
//	while (*tmp++);
//	return tmp - 1 - ptr;
//}
//
//int main()
//{
//	printf("%zu\n", MyStrlen("Aoki"));
//	return 0;
//}

/**
	指针和数组
		1.当原指针和结果指针都指向同一数组中的元素或该数组的尾后一位置，行为才有定义。
		2.注意若指针指向数组首元素时，执行指针减整数运算，使指针指向数组首元素前的地址是未定义行为，并且在某些平台上可能失败。
*/

////指针和数组示例一
//int main()
//{
//	int arr[10] = { 0 };
//	
//	printf("%p\n", arr);//此处的数组名是首元素的地址。
//	
//	printf("%p\n", &arr[0]);//此处为取出数组首元素的地址，等价于"&(*(arr + 0))"。
//
//	int* pa = arr;
//
//	for (int i = 0; i < 10; i++)
//	{
//		printf("%p <===> %p\n", &arr[i], pa + i); //可见打印结果相同说明："pa + i"就是数组下标为"i"的元素的地址。
//	}
//
//	for (int i = 0; i < 10; i++)
//	{
//		*(pa + i) = i;//利用指针将数组各元素赋值成变量"i"对应的数值。
//		printf("%d ", *(pa + i));//利用指针将数组各元素打印出来。
//	}
//
//	return 0;
//}

////指针与数组示例二
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	
//	int* pa = arr;
//	
//	printf("\narr[2] <==> *(arr+2) <==> *(2+arr) <==> 2[arr]\n");
//
//	printf("\narr[2] <==> *(arr+2) <==> *(pa+2) <==> pa[2]\n");
//
//	printf("\npa[2] <==> *(pa+2) <==> *(2+pa) <==> 2[pa]\n");
//
//	printf("\narr[2] = %d <==> pa[2]= %d\n", arr[2], pa[2]);
//	
//	printf("\n2[arr]= %d <==> 2[pa]= %d\n", 2[arr], 2[pa]);
//
//	return 0;
//}

/**
	二级指针：一级指针变量有着属于它自己的地址，那它的地址就可以用另一个指针变量存放地址，这就是二级指针。
*/

////二级指针示例
//int main()
//{
//	int a = 0;
//	
//	int* pa = &a;//"pa"是整型指针变量，指向整型变量"a"，属于一级指针，可以发现只有一颗"*"符号。
//	
//	int** ppa = &pa;//因为"pa"整型指针变量也是变量，同样是在内存中开辟一块内存空间存放它，故也可以把变量"pa"的地址用取地址操作符取出存放在另一个指针变量"ppa"中，此处"ppa"就属于二级指针。
//	
//	**ppa = 10;//通过"*ppa"找到"pa"，再通过解引用操作符从而找到"a"，即"**ppa"。
//	
//	return 0;
//}

/**
	指针数组：用于存放指针的数组。
*/

////指针数组示例
//int main()
//{
//	int arr1[5] = { 0 };//整型数组：存放整型的数组。
//	
//	char arr2[5] = "Aoki";//字符数组：存放的是字符。
//	
//	int* parr1[5] = { &arr1[0],&arr1[1],&arr1[2],&arr1[3],&arr1[4] };//整型指针数组：存放整型指针的数组。
//	
//	return 0;
//}

/*
	结构体
		1.结构体与数组
			a.数组是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型。
			b.结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。
		2.结构体类型的声明
			a.结构体是一些值的集合，这些值称为成员变量；结构体内的每个成员可以是不同类型的变量。
			b.结构体内的成员可以是标量、数组、指针，甚至是其他结构体。
		3.结构体初始化
		4.结构体成员访问：使用操作符"."以及"->"达到结构体访问成员名。
		5.结构体传参
			a.函数传参的时候，参数是需要压栈的(栈：一种数据结构，先进的后出，后进的先出，类似电梯，此处的栈指系统栈，类似于数据结构栈)。
			b.若传递的结构体对象过大，参数压栈的系统开销比较大，会导致性能的下降。
			c.结构体传参时，需传结构体的地址。
*/

////结构体示例
//struct Privacy//声明一个类型"struct Privacy"。
//{
//	char Sexual_orientation[5];//性取向。
//	char Phone_number[20];//手机号。
//};
//
//struct Student//声明一个类型"struct Student"。
//{
//	//以下为成员变量的声明。
//	char name[10];//名称。
//	int age;//年龄。
//	char id[20];//学号。
//	struct Privacy A;//隐私：包含了结构体类型"struct Privacy"。
//}A1, A2;//创建结构体对象的第一种方式：使用"struct Student"类型创建"A1"和"A2"对象，这两个变量为全局变量。
//
//void print(struct Student B1_A, struct Student* B1_B)
//{
//	printf("\n%s %d %s %s %s\n", B1_A.name, B1_A.age, B1_A.id, B1_A.A.Sexual_orientation, B1_A.A.Phone_number);
//	printf("\n%s %d %s %s %s\n", B1_B->name, B1_B->age, B1_B->id, B1_B->A.Sexual_orientation, B1_B->A.Phone_number);
//}
//
//int main()
//{
//	//如下为创建结构体对象的第二种方式：使用"struct Student"类型创建"B1"对象并进行初始化，此变量为局部变量。
//	struct Student B1 = { "Aoki",19,"2020412505XX",{"保密","186XXXXXXXX"} };
//	
//	//如下是将"B1"的地址存放到结构体类型为"struct Student"的指针变量"pa"中。
//	struct Student* pa = &B1;
//	
//	//结构体成员访问(使用"."操作符)
//	printf("%s\n", B1.name);
//	printf("%d\n", (*pa).age);
//	
//	//结构体成员访问(使用"->"操作符)
//	printf("%s\n", pa->id);
//	printf("%s\n", pa->A.Phone_number);//"->"操作符的左操作数应为指针变量。
//	printf("%s\n", pa->A.Sexual_orientation);
//
//	//结构体传参
//	print(B1, &B1);//参数"B1"是将结构体作为形参传递给了子函数(传值调用)；参数"&B1"是将结构体的地址传递给了子函数(传址调用)。
//
//	return 0;
//}
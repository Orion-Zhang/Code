#include <iostream>

/*
	模板初阶
		1.泛型编程
		2.模板
		3.函数模板
		4.类模板
*/

/**
	泛型编程：一种计算机编程风格，它将算法与数据类型分离，使得算法可以适用于多种数据类型，而不需要重新编写针对每一种数据类型的算法。
		1.泛型是指允许类型成为方法、类和接口的参数的想法。
		2.术语"泛型编程"，用来描述一种编程范式，其中对类型的基本要求从算法和数据结构的具体示例中抽象出来，并形式化作为概念，具有根据这些概念实现的通用功能。
		3.泛型编程的优点：代码复用、易于维护等。
*/

/**
	模板：模板是一种用来创建泛型类或函数的蓝图或公式，C++中的模板有很多种，最常见的是函数模板和类模板。
		1.使用"template"关键词可以声明模板，例如：template <形参列表> 声明。
			a.形参列表是一个非空的模板形参的逗号分隔的列表。
			b.声明可以是函数的声明或是类的声明等等。
		2.每个模板都会由一个或多个模板形参参数化，它们在模板声明语法中的"<>"中指定。
		3.形参列表中的每个形参都是一个模板参数，它们可以是模板类型形参、模板非类型形参和模板模板形参。(此阶段仅介绍模板类型形参)
			a.模板类型形参是用来指定类型的模板形参，是使用"class"关键词或"typename"关键词声明的模板类型参数，其关键词后还附有可选的名字，通常为"T"。
			b."class"关键词和"typename"关键词，在模板类型形参声明中没有区别。
*/

/**
	函数模板：函数模板定义一族函数，即函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被实例化，根据实参类型产生函数的特定类型版本。
		1.常见的语法形式：template <形参列表> 函数声明。
			a.函数声明中所声明的函数名成为函数模板名。
		2.函数模板的原理：在编译器的编译阶段，对于函数模板的使用，编译器会根据传入的实参类型来推演生成一个对应形参列表类型的函数。
		3.函数模板的实参：模板在实例化时，它的每个形参(包含模板类型形参、模板非类型形参和模板模板形参)都必须被一个对应的模板实参替换。
			a.对于函数模板，模板实参可以被显式提供，或从语境推导，或为默认。(指定的模板实参具有相关规则，暂不考虑)
				a'.显式提供：使用函数模板时，可在函数名后面的"<>"中指定模板实参，其中包含一个或多个模板实参(根据模板声明的形参列表决定)，用逗号分隔，例如：func<int>(a, b)。
				b'.语境推导：使用函数模板时，可省略在函数名后面的"<>"，例如：func(a, b)。
				c'.默认：在函数模板声明中，可以在形参列表中指定默认实参类型。(类似缺省参数)(C++11起)
					a''.当使用函数模板时，可在函数名后面的"<>"中不指定模板实参或部分显式提供。
					b''.例如："template <typename T = int>"(此处忽略函数声明)，这将使得函数模板的模板实参默认为"int"。
					c''.默认值可能总是会被语境推导的类型覆盖，并且对跟在默认实参之后的形参没有限制。
			b.模板类型形参的模板实参必须是类型标识。(其他形参暂不讨论)
		4.模板实参推导：为了实例化一个函数模板，需要知晓但不需要指定每个模板调用时的实参，编译器会尽可能从函数实参中推导缺失的模板实参，从而生成对应的函数。
			a.模板实参推导具有不同情况，它能根据不同的语境进行推导，大致区分为：函数调用推导、类型推导、特殊语境推导和不推导语境。
			b.模板实参推导在不同的语境下具有不同的规则。
		5.函数模板实例化
			a.函数模板自身并不是类型、函数或任何其他实体，它不会从只包含模板定义的源文件生成任何代码，只有实例化才会有代码的出现。
			b.当在使用函数模板时，编译器会根据实参来推演生成一个对应形参列表类型的函数，这个过程称为函数模板的实例化。
			c.当函数模板实例化时，必须确定各模板实参，使得编译器能生成实际的函数(或从类模板生成类)。
			d.若不使用函数模板，编译器将不会生成函数模板的实例化版本，但如果函数模板被显式实例化，那么编译器将会生成对应的函数模板的实例化版本。
			e.函数模板的实例化可分为显式实例化和隐式实例化。
				a'.显式实例化：在函数模板定义之后，使用"template"关键词可声明或定义一个函数模板的显式实例化，定义能使编译器生成一个函数模板的实例化版本。(在一些库中常会使用显式实例化)
					a''.使用"template 返回类型 名字 <实参列表> (形参列表);"语句，进行显式实例化定义，意为显式指定所有无默认值的模板形参时不会推导模板实参。
					b''.使用"template 返回类型 名字 (形参列表);"语句，进行显式实例化定义，意为对所有形参进行模板实参推导。
					c''.显式实例化定义强制实例化它所指代的函数或成员函数，所以当存在显式实例化时，即使没有调用函数模板，编译器也会生成函数模板的实例化版本。
				b'.隐式实例化：当代码在要求存在函数定义的语境中指涉某个函数，而这个特定函数尚未被显式实例化时，发生隐式实例化。
					a'.如果模板实参列表能从语境推导，那么不必提供模板实参列表。
		6.函数模板匹配机制
			a.一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数。
			b.对于非模板函数和同名函数模板，如果其他条件都相同，在调用时会优先调用非模板函数而不会从该模板产生出一个实例，如果模板可以产生一个具有更好匹配的函数，那么将选择函数模板。
*/

////函数模板示例一：通用的交换函数。
//template <typename T>//声明模板，其中形参列表包含了以"typename"关键词声明的模板类型形参"T"，下行为函数模板的声明(定义)。
//void Swap(T& a, T& b)//函数模板的定义，其中函数模板的名字为"Swap"，函数模板的形参列表包含了两个以引用方式传递的模板类型形参"T"，函数模板的返回类型为"void"。
//{
//	T temp = a;//创建模板类型形参"T"的变量"temp"，并初始化为"a"的值。
//	a = b;//将"b"的值赋给"a"。
//	b = temp;//将"temp"的值赋给"b"。
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	Swap(a, b);
//	std::cout << "a = " << a << std::endl;
//	std::cout << "b = " << b << std::endl;
//
//	double c = 1.1;
//	double d = 2.2;
//	Swap(c, d);//此处调用的函数模板的实例化版本与上面的函数模板的实例化版本不同。
//	std::cout << "c = " << c << std::endl;
//	std::cout << "d = " << d << std::endl;
//
//	return 0;
//}

////函数模板示例二：通用的加法函数。
//template<typename T>
//T Add(const T x, const T y)
//{
//	return x + y;
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	std::cout << "a + b = " << Add(a, b) << std::endl;
//
//	double c = 1.1;
//	double d = 2.2;
//	std::cout << "c + d = " << Add(c, d) << std::endl;
//
//	return 0;
//}

////函数模板示例三：不匹配的模板实参推导。
//template<typename T>
//T Add(const T x, const T y)
//{
//	return x + y;
//}
//
//int main()
//{
//	int a = 10;
//	double b = 10.0;
//	//Add(a, b);//错误，模板类型推导通过类型进行推导，此处"a"变量为"int"类型，"b"变量为"double"类型，但没有匹配的函数模板进行实例化。
//	Add(a, (int)b);//通过强制类型转换，将"b"变量的类型转换为"int"类型，从而匹配到函数模板进行实例化。
//	return 0;
//}

////函数模板示例四：显式提供模板实参。
//template<typename T>
//T Add(const T x, const T y)
//{
//	return x + y;
//}
//
//int main()
//{
//	int a = 10;
//	double b = 10.0;
//	Add<int>(a, b);//显式提供模板实参，将模板类型形参"T"的类型指定为"int"类型，从而匹配到函数模板进行实例化。
//	Add<double>(a, b);
//	return 0;
//}

////函数模板示例五：函数模板的显式实例化以及隐式实例化。
//template<typename T>
//void f(T s)
//{
//	std::cout << s << '\n';
//}
//
//template void f<double>(double);//显式实例化函数模板"f"，其中模板类型形参"T"被显式实例化为"double"类型，即实例化为"f<double>(double)"。
//template void f<>(char);//显式实例化函数模板"f"，此处的模板实参为默认，推导出模板实参类型为"char"类型，即实例化为"f<char>(char)"。
//template void f(int);//显式实例化函数模板"f"，推导出模板实参类型为"int"类型，即实例化为"f<int>(int)"。
//
//int main()
//{
//	//以下调用的函数是通过函数模板进行显式实例化出的函数。
//	f(1);
//	f('a');
//	f(1.1);
//
//	//以下调用的函数是通过函数模板进行隐式实例化出的函数。
//	f(1.0f);
//	f("hello");
//	f(1.0L);
//
//	return 0;
//}

////函数模板示例六：函数模板匹配机制。
//int Add(int x, int y)
//{
//	std::cout << "Add(int x, int y)" << std::endl;
//	return x + y;
//}
//
//template<class T1, class T2>
//T1 Add(T1 x, T2 y)
//{
//	std::cout << "T1 Add(T1 x, T2 y)" << std::endl;
//	return x + y;
//}
//
//int main()
//{
//	Add(1, 2);//与非模板函数匹配，编译器不需要实例化函数模板。
//	Add<int>(1, 2);//显式提供模板实参，通过函数模板实例化函数并调用。
//	Add(1, 1.0);//模板函数可以生成更加匹配的版本，编译器会选择使用模板函数实例化出的函数。
//	return 0;
//}

/**
	类模板：类模板定义一族类，如同函数模板，类模板在类定义独立于数据类型的内容时很有用。
		1.语法形式：template <形参列表> 类声明。
			a."类声明"：使所声明的类名成为模板名。
			b."形参列表"：非空的模板形参的逗号分隔列表，每项可以是非类型形参、类型形参、模板形参。(C++11起以任何这些形参的形参包之一也被支持)
		2.类模板的实参：与函数模板一样，类模板在实例化时，它的每个形参必须被一个对应的模板实参替换。
			a.对于类模板，实参可以被显式提供或为默认。(C++17起可从初始化器推导)(指定的模板实参具有相关规则，暂不考虑)
				a'.显式提供实参：在模板名后面紧跟一对尖括号"<>"，其中包含一个或多个模板实参(根据模板声明的形参列表决定)，用逗号分隔。(指定的模板实参具有相关规则，暂不考虑)
				b'.默认：在类模板声明中，可以在形参列表中指定默认实参类型。
					a''.当使用类模板时，可在模板名后面的"<>"中不指定模板实参或部分显式提供(根据给出的默认实参决定，并具有相关限定)。(类似缺省参数)
					b''.如果为主类模板形参指定默认实参，那么它后面的所有模板形参都必须有默认实参。(C++11起最后一个可以是模板形参包)
			b.模板类型形参的模板实参必须是类型标识。(其他形参暂不讨论)
		3.类模板的实例化
			a.类模板自身并不是类型、对象或任何其他实体，它不会从只包含模板定义的源文件生成任何代码，模板只有实例化才会有代码出现。
			b.当类模板实例化时，必须提供模板实参，使得编译器能生成实际的类(或从函数模板生成函数)。
			c.类模板的实例化也分为隐式实例化和显式实例化。
				a'.显式实例化：在类模板定义之后，使用"template"关键词可声明或定义一个类模板的显式实例化，定义将强制实例化其所指代的"class"、"struct"、"union"。
					a''.使用"template 类关键词 模板名 <实参列表>;"语句，进行显式实例化定义。
				b'.隐式实例化：当代码在要求完整定义的类型的语境中涉指某个模板时，或当类型的完整性对代码有影响，而这个特定类型尚未被显式实例化时，发生隐式实例化。
			d.如果类模板已经声明但尚未定义，那么它的实例化会在实例化点产生不完整的类类型。
			e.类模板一般没有推演时机，通常进行显式实例化，它们是同一个类模板实例化出来的，但若类模板参数(成员)不同，它们就是不同类型。(双胞胎兄弟)
		4.关于类模板和模板类的区别
			a.类模板通常指代由模板定义的类，也就是类的模板，是用于生成类的模板。
			b.实际上并没有模板类这样的术语，但也有一些人用模板类来指代实例化的或显式特化的类模板，这将使其等同于类模板特化，即从类模板生成的类称为模板类，专门定义为模板类名的类也称为模板类。
			c.Bjarne Stroustrup认为不必在类模板和模板类上进行语义的区分，这些术语实际上可以互换语义，同样的，函数模板与模板函数也同样可以进行语义上的互换。
*/

////类模板示例一：创建类模板。
//template<typename T1, typename T2>
//class A
//{
//public:
//	A(T1 a, T2 b) : m_a(a), m_b(b)
//	{
//	}
//
//	void print()
//	{
//		std::cout << "m_a = " << m_a << ", m_b = " << m_b << '\n';
//	}
//
//	T1 m_a;
//	T2 m_b;
//};
//
//int main()
//{
//	A<double, int> a(1.1, 2);//显式提供模板实参。
//	a.print();
//	return 0;
//}

////类模板示例二：类模板的默认实参。
//template<typename T1, typename T2 = char>
//class A
//{
//public:
//	A(T1 a, T2 b) : m_a(a), m_b(b)
//	{
//	}
//
//	void print()
//	{
//		std::cout << "m_a = " << m_a << '\n';
//		std::cout << "m_b = " << m_b << '\n';
//		std::cout << typeid(m_a).name() << '\n';
//		std::cout << typeid(m_b).name() << '\n';
//	}
//
//	T1 m_a;
//	T2 m_b;
//};
//
//int main()
//{
//	A a(1.1, 94);
//	a.print();
//
//	A<double> b(1.1, 94);
//	b.print();//此处可发现，"b"对象的"m_b"成员的类型为"char"，而不是"int"。
//
//	return 0;
//}
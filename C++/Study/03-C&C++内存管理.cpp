#include <iostream>
#include <cstring>
#include <cstdlib>

/*
	C&C++内存管理
		1.C/C++内存分布
		2.C语言中动态内存管理方式
		3.C++中动态内存管理
		4.operator new与operator delete函数
		5.new和delete的实现原理
		6.定位new表达式(placement-new)
		7.常见面试题
*/

/**
	C/C++内存分布：C/C++程序在虚拟进程地址空间中的内存分布，即C/C++程序的内存布局(内存区域划分)。(仅介绍主要内存区域)(以下规则可能在不同操作系统或编译器(链接器)中有所不同)
		1.栈区：即"Stack"内存区域，又被称为堆栈。(注意与数据结构的栈进行区分)
			a.栈区以后进先出(LIFO)的方式添加或删除数据，通常位于内存的较高部分(地址)，在标准的计算机架构中，栈区的地址从高到低增长。
			b.栈区由编译器自动分配释放，并且用于存放或构造非静态局部对象(具有自动存储期的对象)、调用函数时的参数和其他与函数相关的信息等数据。
			c.栈区分配内存的方式是发生在连续的内存块上的，访问数据速度快(相对于堆而言)。
			d.栈区的存储空间较小(相对于堆而言)，若栈区内存不足，会导致程序崩溃(栈溢出)。
		2.堆区：即"Heap"内存区域。(注意与数据结构的堆进行区分)
			a.堆区通常被用于存放程序运行时动态分配的内存，是供程序员分配和释放的内存空间，通常位于栈区的下方(即相对于栈区较低的部分(地址))，但堆区的地址是从低到高增长的。
			b.堆区分配的内存的方式是以随机顺序分配在内存块上的，并且堆上的数据也可能存储为不连续的内存块(已使用的内存块位于未使用的内存块之间)，导致存储在内存块的数据变得碎片化，访问数据速度慢(相对于栈而言)。
			c.堆区的存储空间较大(相对于栈而言)，若堆区内存不足，会导致分配失败。
			d.C/C++中堆区的数据需要程序员以编程的方式进行手动分配和释放，若分配后不释放，则会导致内存泄漏(保持运行的情况下)，直到程序结束才会被操作系统回收。
 		3.未初始化的数据段：即"Block Started by Symbol"段(简称为"BSS"段)。
			a."BSS"段通常存放着未初始化的静态变量(包括全局和局部)和全局变量，并且通常也存放着初始化为零的全局变量和静态变量(指针类型则为空指针)。(对于内置类型而言)
			b.在程序开始执行之前(进入主函数前)，该段中的数据将被初始化为零(指针类型则为空指针)，包含所有初始化为零或在源代码中没有显式初始化的全局变量和静态变量。
			c.存放在"BSS"段中的数据不会被写入到目标文件中，但会记录未初始化数据在程序装载时所需空间的大小。
			d."BSS"段存在于堆区的下方(相对于堆区较低的部分(地址))。
			e.通常情况下，"BSS"段并不存储以"const"限定符修饰的变量，除非是C语言中未初始化(不包含以隐式或显式的零初始化)的全局常变量(注意不是静态变量)。
				a'.在C语言中，被"const"关键词修饰的变量称之为常变量，实际上是变量而非常量，其只是在语法层面上限制不能被修改，并且在定义时可以不显式初始化。
				b'.在C语言中，若全局的常变量(非静态变量)没有被初始化，则其会被存储在"BSS"段中，但当其被初始化时(包括初始化为零)，则会被存储在已初始化数据段中。
				c'.在C++中，被"const"关键词修饰的变量必须在定义时初始化，所以其通常不会在"BSS"段中存储，即使它们被隐式或显式初始化为零。
		4.已初始化的数据段：即"Initialized Data Segment"段，通常简称为数据段(即"Data Segment"段或"Data"段)。
			a.已初始化的数据段存放着已被初始化的静态变量和全局变量(对于内置类型而言)。
			b.此段在内存区域所占的空间大小将由源代码中的初始化数据的大小决定，并且在运行时不会再改变。
			c.数据段是只读或可读写的，因为变量的值可以在运行时更改，所以该段又可以分为初始化只读区和初始化读写区。
				a'.初始化只读区存放的是由"const"限定符修饰的：静态变量、全局常变量，并且还存放着只读字符串常量等数据。
				b'.初始化读写区存放的是非"const"限定符修饰的：静态变量、全局变量。
			d.该段存在于未初始化的数据段的下方(相对于未初始化的数据段较低的部分(地址))。
		5.代码段：即"Text"段，又被称为文本段。
			a.代码段存放着程序的机器指令，即可执行的指令，即要执行的程序步骤的机器语言表示，其中包括了函数体的二进制代码等。
			b.代码段的大小通常是固定的，并且不可写入，以避免其他内存区域溢出等编程错误覆盖的风险。
*/

////C/C++内存分布示例一：以下为包含多种情况测试代码，请结合"size"命令、"objdump"命令以及编译器编译选项(链接选项)分步测试观测内存分布的情况。(不同操作系统或编译器(链接器)的结果可能不同)
////以零初始化的全局静态常变量：存储于已初始化的数据段中的初始化只读区中。
//const static int csg1 = 0;
//const static int csg2 = 0;
//
////已初始化的全局静态常变量：存储于已初始化的数据段中的初始化只读区中。
//const static int csg3 = 100;
//const static int csg4 = 100;
//
//////未初始化的全局静态常变量(C语言中允许，C++中不允许)：存储于已初始化的数据段中的初始化只读区中(仅对于C语言)。
////const static int csg5;
////const static int csg6;
//
////以零初始化的全局常变量：存储于已初始化的数据段中的初始化只读区中。
//const int cg1 = 0;
//const int cg2 = 0;
//
////已初始化的全局常变量：存储于已初始化的数据段中的初始化只读区中。
//const int cg3 = 100;
//const int cg4 = 100;
//
//////未初始化的全局常变量(C中允许，C++中不允许)：存储于未初始化的数据段中(仅对于C语言)。
////const int cg5;
////const int cg6;
//
////以零初始化的全局静态变量：存储于未初始化的数据段中。
//static int sg1 = 0;
//static int sg2 = 0;
//
////已初始化的全局静态变量：存储于已初始化的数据段中的初始化读写区中。
//static int sg3 = 100;
//static int sg4 = 100;
//
////未初始化的全局静态变量：存储于未初始化的数据段中。
//static int sg5;
//static int sg6;
//
////以零初始化的全局变量：存储于未初始化的数据段中。
//int g1 = 0;
//int g2 = 0;
//
////已初始化的全局变量：存储于已初始化的数据段中的初始化读写区中。
//int g3 = 100;
//int g4 = 100;
//
////未初始化的全局变量：存储于未初始化的数据段中。
//int g5;
//int g6;
//
////字符串常量：存储于已初始化的数据段中的初始化只读区中。
//const char* cstrg1 = "hello world";//此处的指针为全局变量，存储于已初始化的数据段中的初始化读写区中。
//char* const strcg2 = "hello world";//此处的指针为全局常变量，存储于已初始化的数据段中的初始化只读区中。
//
//int main()
//{
//	//以零初始化的局部静态常变量：存储于已初始化的数据段中的初始化只读区中。
//	const static int csp1 = 0;
//	const static int csp2 = 0;
//
//	//已初始化的局部静态常变量：存储于已初始化的数据段中的初始化只读区中。
//	const static int csp3 = 100;
//	const static int csp4 = 100;
//
//	////未初始化的的局部静态常变量(C中允许，C++中不允许)：存储于已初始化的数据段中的初始化只读区中(仅对于C语言)。
//	//const static int csp5;
//	//const static int csp6;
//
//	//以零初始化的局部常变量：存储于栈中。
//	const int cp1 = 0;
//	const int cp2 = 0;
//
//	//已初始化的局部常变量：存储于栈中。
//	const int cp3 = 100;
//	const int cp4 = 100;
//
//	////未初始化的局部常变量(C中允许，C++中不允许)：存储于栈中(仅对于C语言)。
//	//const int cp5;
//	//const int cp6;
//
//	//以零初始化的局部静态变量：存储于未初始化的数据段中。
//	static int sp1 = 0;
//	static int sp2 = 0;
//
//	//已初始化的局部静态变量：存储于已初始化的数据段中的初始化读写区中。
//	static int sp3 = 100;
//	static int sp4 = 100;
//
//	//未初始化的局部静态变量：存储于未初始化的数据段中。
//	static int sp5;
//	static int sp6;
//
//	//以零初始化的局部变量：存储于栈中。
//	int p1 = 0;
//	int p2 = 0;
//
//	//已初始化的局部变量：存储于栈中。
//	int p3 = 100;
//	int p4 = 100;
//
//	//未初始化的局部变量：存储于栈中。
//	int p5;
//	int p6;
//
//	//字符串常量：存储于已初始化的数据段中的初始化只读区中。
//	const char* cstrp1 = "hello world";//此处的指针为局部变量，存储于栈中。
//	char* const strcp2 = "hello world";//此处的指针为局部常变量，存储于栈中。
//
//	return 0;
//}

////C/C++内存分布示例二：关于指针是否带"const"修饰符的区别。
//int main()
//{
//	const int* ptr1;//注意"const int*"和"int* const"的区别，前者修饰的是指针所指向的值，代表不可通过指针修改其指向的值，而后者修饰的是指针本身，代表指针本身不可修改其指向。
//	int const* ptr2;//此处的"int const*"等价于"const int*"，都代表不可通过指针修改其指向的值，并且此处都为局部的指针变量，而不是局部的指针常变量，都存储于栈中。
//	//int* const ptr3;//错误，指针常变量"ptr3"必须进行初始化，但若是在C语言中，则允许这样的做法，C++中由"const"修饰符修饰的变量必须进行初始化。
//	int* const ptr4 = nullptr;//正确，此处的局部指针常变量"ptr4"进行了初始化，代表指针本身不可修改其指向，存储于栈中。
//	//const int* const ptr5;//错误，需要进行初始化。
//	const int* const ptr6 = nullptr;//正确，此处的局部指针常变量"ptr6"进行了初始化，代表指针本身不可修改其指向，且此处的指针所指向的值也被限定为不可通过指针修改。
//	return 0;
//}

////C/C++内存分布示例三：关于字符串字面量。
//int main()
//{
//	//字符串字面量：无前缀字符串字面量的类型为"const char[N]"，其中"N"代表了字符串字面量的元素个数，并且包括了字符串字面量的空终止符。(字符串字面量类型不同于C语言中的"char[N]")
//	const char* cstrp1 = "hello world";//此处字符串字面量的类型为"const char[12]"，并且其具有静态存储期，故存储于已初始化的数据段中的初始化只读区中。
//
//	//试图修改字符串字面量会导致未定义行为，它们通常存储于初始化只读区或与其他字符串字面量合并。
//	const char* cstrp2 = "Hello";
//	char* ptr1 = const_cast<char*>(cstrp2);//将字符串字面量的类型转换为"char*"，并将其赋值给指针变量"ptr"。
//	//ptr1[0] = 'A';//未定义行为。
//
//	//C++11前：字符串字面量可转换为且可赋值(初始化)给非"const"的指向"char"类型指针，以与C兼容，因为C中字符串字面量类型为"char[N]"，但在C++11起这种隐式转换被弃用。
//	//C++11起：字符串字面量不可转换为或赋值(初始化)给非"const"的指向"char"类型指针，若想要这种转换则需使用显式转型(例如：const_cast)。
//	//但是，因为有很多现有代码依赖于该隐式转换，若强制禁止该隐式转换则会导致大量的编译错误(破坏代码)，并且不兼容C语言。
//	char* ptr2 = "Hello";//警告，严格意义上为错误：C++11起不允许从字符串字面量转换为"char*"。
//	char* ptr3 = const_cast<char*>("Hello");//正确，使用显式转型，但并不安全。
//	const char* cstrp3 = "Hello";//正确，标准做法。
//
//	//计算字符串字面量的长度例一
//	const char* cstrp4 = "Hello";
//	size_t cstrp4_len = std::strlen(cstrp4);//计算字符串字面量的长度，不包括空终止符。
//	size_t cstrp4_size1 = sizeof(cstrp4);//注意此处的"sizeof"计算的是指针变量的大小，而非字符串字面量的大小。
//	size_t cstrp4_size2 = sizeof("Hello");//计算字符串字面量的大小，包括空终止符。
//	std::cout << "cstrp4_len = " << cstrp4_len << std::endl;//结果为：5。
//	std::cout << "cstrp4_size1 = " << cstrp4_size1 << std::endl;//结果为：4/8。(取决于平台)
//	std::cout << "cstrp4_size2 = " << cstrp4_size2 << std::endl;//结果为：6。
//
//	//计算字符串字面量的长度例二
//	const char* cstrp5 = "abc\0def";
//	size_t cstrp5_len = std::strlen(cstrp5);
//	size_t cstrp5_size = sizeof("abc\0def");
//	std::cout << "cstrp5_len = " << cstrp5_len << std::endl;//"strlen"函数遇到空终止符结束，并且不计入空终止符，故结果为：3。
//	std::cout << "cstrp5_size = " << cstrp5_size << std::endl;//结果为：8。
//
//	return 0;
//}

/**
	C语言中动态内存管理方式
		1.C语言中的动态内存管理相关函数：即通过"malloc"函数、"calloc"函数、"realloc"函数和"free"函数来进行动态内存管理，不再赘述，详见C语言中的"动态内存管理"章节。
		2.关于"malloc"函数、"calloc"函数和"realloc"函数的区别
			a.通常来说，"malloc"函数和"calloc"函数的功能都是在堆区分配内存。
			b.首先就是其使用方法不同，传递参数的意义类似，但"malloc"函数只需传递一个参数，即要分配的内存块的字节数，而"calloc"函数需传递两个参数，即要分配的每个元素的大小和要分配的元素个数。
			c.其次是"calloc"函数会在分配内存后将以零初始化所有分配存储中的字节，即进行"memset"函数的以零填充内存块，而"malloc"函数则不会。
			d.当"malloc"函数与"calloc"函数分配相同大小的内存块时，若在进行"malloc"函数后进行"memset"以零填充内存块，也不代表两函数等价。
			e.比如"calloc(n, sizeof(int))"和"calloc(n * sizeof(int), 1)"并不是等价的，若当"n"小于或等于"SIZE_MAX / sizeof(int)"时确实等价，但一旦当"n"大于"SIZE_MAX / sizeof(int)"时，不等价。
			f.当"n"大于"SIZE_MAX / sizeof(int)"时，"calloc(n, sizeof(int))"会正确设置"errno"为"ENOMEM"并返回"NULL"，即分配失败。
			g.当"n"大于"SIZE_MAX / sizeof(int)"时，"calloc(n * sizeof(int), 1)"会返回"n * sizeof(int)"被截断后(即截断成"64"位的整数)大小的内存块，即分配成功。
			h.这也就说明了其实"malloc(n * sizeof(int))"是不安全的，一旦当"n"为"2 ^ 62"，相乘后变为"2 ^ 64"，超过"SIZE_MAX"，并且截断后为零，故会返回"NULL"或不可用于访问存储的非空指针(根据库定义)，即分配成功，但一旦试图写入而不传递给"free"函数，则会导致出错。
			i.而"calloc"函数设置为两个参数，而不是让用户预先使用"n * sizeof(int)"把它乘起来，是因为"calloc"函数会自动检测两个参数，判断两个参数相乘后是否会溢出，若溢出会正确设置"errno"为"ENOMEM"并返回"NULL"，即分配失败。
			j.所以，"calloc"函数不仅仅具有"memset"函数的以零填充内存块的功能，而且还具有乘法溢出安全检测的功能，但不要以为只要数值不大就无所谓，对于"Linux"内核而言，"n"是来着用户态的数据，可以是任意值，但如果用户态程序恶意输入值，内核可能会崩溃，甚至可能被窃取数据。
			k."relloc"函数的功能不再赘述，关于对于C以及C++不同标准下相关动态内存函数的区别，请参考相关文档，但大致相同。
		3.C语言中的动态内存函数相关文档
			a."malloc"函数：https://zh.cppreference.com/w/c/memory/malloc。
			b."calloc"函数：https://zh.cppreference.com/w/c/memory/calloc。
			c."realloc"函数：https://zh.cppreference.com/w/c/memory/realloc。
			d."free"函数：https://zh.cppreference.com/w/c/memory/free。
		4.C++语言中"malloc"函数、"calloc"函数、"realloc"函数和"free"函数的相关文档
			a."malloc"函数：https://zh.cppreference.com/w/cpp/memory/c/malloc。
			b."calloc"函数：https://zh.cppreference.com/w/cpp/memory/c/calloc。
			c."realloc"函数：https://zh.cppreference.com/w/cpp/memory/c/realloc。
			d."free"函数：https://zh.cppreference.com/w/cpp/memory/c/free。
*/

////C语言中动态内存管理方式示例一：关于"size_t"类型溢出的问题。
//int main()
//{
//	std::cout << SIZE_MAX << std::endl;//结果为：18,446,744,073,709,551,615。
//	std::cout << SIZE_MAX / sizeof(int) << std::endl;//结果为：4,611,686,018,427,387,903。(向零取整)
//	std::cout << (SIZE_MAX / sizeof(int) + 1) * sizeof(int) << std::endl;//结果为：0。
//	return 0;
//}

////C语言中动态内存管理方式示例二：C++中使用C语言中的动态内存函数。
//int main()
//{
//	int* p1 = (int*)std::malloc(sizeof(int) * 10);
//	std::free(p1);
//
//	int* p2 = (int*)std::calloc(10, sizeof(int));
//	std::free(p2);
//
//	int* p3 = (int*)std::realloc(nullptr, sizeof(int) * 10);//此处相当于"malloc"函数。
//	p3 = (int*)std::realloc(p3, sizeof(int) * 100);//对"p3"指针指向的内存块进行扩容，并重新赋值给"p3"。
//	std::free(p3);
//
//	return 0;
//}

/**
	C++中动态内存管理
		1.C++中对于动态内存的分配和释放：C语言的动态内存管理方式在C++中可以继续使用，但是C++中也提供了自己的动态内存管理方式，即"new"运算符和"delete"运算符。(当前阶段为不全面介绍，即有些规定是需要通过后续的学习才能了解的)
			a."new"运算符和"delete"运算符将以更好、更简单的方式执行分配和释放动态内存的任务。并在已申请的存储空间上，
			b."new"运算符：尝试在堆上申请存储空间，若有足够的空间(即申请成功)，那么"new"运算符会尝试构造(初始化)一个无名的对象或对象数组，并将处理完毕的内存空间的地址返回给指针变量，否则抛出异常。(暂列举两种使用方式)
				a'.使用方式一：通过":: new (类型) 初始化器"方式使用"new"运算符，其中"类型"可以是任意数据类型(已存在)，包括内置类型、自定义类型和数组类型，其中的"::"作用域限定符和"初始化器"是可选的(某些情况下必需提供)。
				b'.使用方式二：通过":: new new类型 初始化器"方式使用"new"运算符，与上述的"a'"相同，但是"new类型"是不包含括号的，这种方式的好处是可以省略括号，类似于"sizeof int"的写法。
					a''.这种方式会有一些副作用，比如在创建一个复合的数据类型的对象时，可能会被解析成这种形式，导致语法错误，所以需要显式的加上括号变为"a'"的使用形式。
					b''.这种方式的"new"运算符是贪心的，它将尽量包含能够成为类型标识一部分的所有记号，直到遇到一个不能成为类型标识的记号为止。
				c'."初始化器"是可选的，但在某些情况下是必需的，比如方式一中的"类型"和方式二中的"new类型"都是数组类型时，并且是未知边界(即"[]")数组时，必须提供"初始化器"。
			c."delete"运算符：销毁先前由"new"表达式分配的对象，并释放获得的内存区域，即从堆上释放已分配的内存。
				a'.使用方式一：通过":: delete 表达式"方式使用"delete"运算符，表示销毁"new"创建的单个非数组对象，其中的"::"作用域限定符是可选的。
					a''."表达式"必须是指向对象类型的指针或是可以按语境隐式转换到这种类类型的指针，且它的值必须为空或指向"new"所创建的非数组对象的指针，也可以是"new"所创建的对象的基类子对象的指针(暂不考虑)，否则行为未定义。
					b''."表达式"的被指向类型必须与该对象(或基类子对象(暂不考虑))的类型匹配，即如果"表达式"是其他不相干的值，包括它是通过"new"表达式的数组形式获得的指针的情况(应该使用方式二)，那么行为未定义。
				b'.使用方式二：通过":: delete[] 表达式"方式使用"delete"运算符，与上述的"a'"类似，但其是表示销毁"new"创建的数组。
					a''."表达式"必须是空指针值或是先前由"new"所创建的数组形式所获得的指针值。
					b''."表达式"的被指向类型必须与数组对象的元素类型匹配，即如果"表达式"是其他不相干的值，包括它是通过"new"表达式的非数组形式获得的指针的情况(应该使用方式一)，那么行为未定义。
				c'."delete"运算符的返回值是"void"类型，即不返回任何值。
			d.关于"new"运算符和"delete"运算符中，使用方式中的"::"作用域限定符具有的作用，包括"new"运算符和"delete"运算符在此阶段的更多细节，将会在下方进行介绍。
		2.分配函数和解分配函数(仅讲解重要部分)
			a.分配函数：即"operator new"和"operator new[]"全局函数，它们具有多种形式的变体，用于尝试分配请求数量的字节，而且分配请求可能会失败(即使请求分配的字节数为零)。
				a'.分配函数会被"new"运算符调用，以分配将被初始化的对象或对象数组所在的内存，它们也可以通过常规函数调用语法调用，并且标准实现中多种形式变体的分配函数的第一个参数总是一个"size_t"类型的值，表示要分配的字节数。
				b'.分配函数是由库中的实现提供的，被包含于"new"头文件中，但即使不包含该头文件，它们也会被编译器隐式声明，并且也可以自定义和重载这些函数，从而替换掉原有的标准库默认实现(需符合规定，并且有一些形式的分配函数不能被替换)。
				c'.程序中可提供这些分配函数的全局和类特有替换函数，而::"作用域限定符就是用于忽略这些替换函数的。
				e'.分配函数的行为类似于"malloc"函数，甚至在一些库实现中会在分配函数中调用"malloc"函数，但是标准规定中是否产生任何对"malloc"函数的调用是未指定的。
				f'.通常情况下，分配函数会在分配失败时抛出异常，而不是返回空指针，但这仅是分配函数众多形式的一部分，也有其他形式的分配函数会返回空指针。(异常处理机制将在后续章节中进行介绍)
			b.解分配函数：即"operator delete"和"operator delete[]"全局函数，它们也具有多种形式的变体，用于解分配先前由匹配的分配函数所分配的存储空间。
				a'.解分配函数会被"delete"运算符与"new"运算符调用，以在析构(或构造失败)拥有动态存储期的对象后解分配内存，它们也可以用常规函数调用语法调用，并且标准实现中多种形式变体的解分配函数的第一个参数总是一个指向要解分配的内存块的无类型指针(即"void*")。
				b'.解分配函数同样被包含于"new"头文件中，并且于分配函数一样，也可以被自定义和重载，从而替换掉原有的标准库默认实现(需符合规定，并且有一些形式的解分配函数不能被替换)。
				c'.在库实现的解分配函数的所有形式中，如果解分配函数接收的是空指针，那么标准库解分配函数不做任何事情，并且如果传递给标准库解分配函数的指针不是从对应的标准库分配函数取得的指针，那么行为未定义。
				d'.在标准库解分配函数返回后，所有指向被解分配存储空间的任何部分的指针都变为非法，并且通过已因此方式变为非法的指针解引用，以及将它传递给解分配函数(双重"delete")是未定义行为。
*/
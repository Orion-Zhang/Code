#include <iostream>

/*
	类和对象
		01.面向过程和面向对象的初步认识
		02.类的引入和定义
		03.类的访问限定符及封装
		04.类的作用域
		05.类的实例化和对象模型
		06.类成员函数的"this"指针
		07.类的六个默认成员函数
		08.构造函数
		09.析构函数
		10.拷贝构造函数
		11.赋值运算符重载
		12."const"成员函数
		13.取地址及"const"取地址操作符重载
		14.再谈构造函数
		15."static"成员
		16.友元
		17.内部类
		18.匿名对象
		19.拷贝对象时的一些编译器优化
		10.再次理解封装
*/

/**
	面向过程和面向对象的初步认识
		1.C与C++
			a.C是面向过程的语言，其注重的是过程，即分析解决问题所需的步骤，从而通过函数逐步解决问题。
			b.C++严格意义上是面向过程与面向对象混合型语言，可理解为面向对象的语言，其注重的是对象，即分析解决问题所需的对象，从而通过对象之间的交互来解决问题。
		2.思维上的面向过程和面向对象
			a.无论是面向过程还是面向对象，都是一种思维方式，即分析解决问题所需的步骤或对象，从而通过函数或对象之间的交互来解决问题。
			b.汇编语言是面向机器的语言，也可说是面向细节的语言，其需要通过一条条指令操作来解决问题，是人脑模拟计算机的一种思维方式。
		3.语言上的面向过程和面向对象
			a.面向过程和面向对象并不决定于语言，而是取决于思维，是一种编程思想，而语言是可以实现这种思想的工具。
			b.C语言并非不可以实现面向对象的思想，仅是在面向对象方面，C语言提供的语法支持较为薄弱，但C语言的结构体、函数指针可以实现面向对象的思想，事实上，使用C语言实现的多数编程框架、库、驱动等都是具有面向对象思想的。
			c.C++在语法层面上提供了对面向对象编程更好的支持，能让使用它的人更加优雅的面向对象编程。
		4.面向对象的三大特性：封装、继承、多态。(封装将在本章的"03"小节介绍，而其它特性将会在之后的章节中介绍)(并非仅有这三大特性)
*/

/**
	类的引入和定义
		1.C++对C语言结构体的升级
			a.C++升级了C语言的结构体，其兼容了C语言中结构体的所有用法，并使其具有了面向对象的特征，称之为类。
			b.C语言中的结构体只允许有变量(数据成员)，不能有函数(函数成员)，而C++中的结构体允许有变量(数据成员)和函数(函数成员)。
			c.C++中将结构体的名称称之为类名，将结构体中的数据成员称之为成员变量或类的属性，将结构体中的函数成员称之为成员函数或类的方法。
			d.对象是指类的实例，使用已经定义的类去说明它的实例变量，即通过类创建的变量，称之为对象。
			e.一个对象是类的一个实例，类中具有的成员变量和成员函数，对于对象来说也是对象的属性和对象的方法。
			f.C++使用类实例化对象时是可以直接使用类名加对象名实例化的，而C语言使用结构体类型定义结构体变量时，必须在变量名前加上"struct"关键词(除非使用"typedef"关键词)。
		2."class"关键词
			a.使用"class"关键词定义类的格式如下：
				class 类头名
				{
					成员说明(类体)
				};
			b.除了默认成员访问和默认基类访问之外(将在本章的"03"小节中介绍)，可以认为"class"关键词与"struct"关键词在类的声明上是等同的。
			c.C++11前，类体中不可声明的同时初始化非静态数据成员(除非是常量静态数据成员)，而C++11后，非静态数据成员可以在类体中声明的同时初始化，但其依旧是声明而不是定义。
			d.类体中的函数成员的定义实际上也是一种声明，定义是包含了函数体的实现，而声明只是声明了函数的原型，而不包含函数体的实现。(不同于数据成员)
		3.类的两种定义方式
			a.在类体中声明成员变量和直接定义成员函数。
			b.在类体中声明静态成员变量和成员函数，然后在类体外定义静态成员变量和成员函数。(暂不考虑静态成员函数)(声明和定义分离的一种体现)
				a'.类体中并不能直接定义静态成员变量，因为定义需要分配内存，静态成员变量是随着类的，静态成员变量属于类级别高于普通成员变量的对象级别，不能随着对象的创建再申请静态成员变量的内存，所以需要单独在类的外部定义。
				b'.在类体外定义静态成员变量或成员函数时，需在静态成员变量定义的变量名或成员函数定义的函数名前加上类名和作用域解析运算符"::"。
		4."struct"关键词和"class"关键词的编程规范(不一定遵守)
			a.通常情况下仅当只有数据成员时使用"struct"关键词，其它一概使用"class"关键词，因为这两个关键词的含义几乎相同，所以我们为这两个关键字添加我们自己的语义理解，以便为定义的数据类型选择合适的关键字。
			b."class"类体中的成员变量命名是具有多种不同的命名规范的，通常会在成员变量名前加上"m_"前缀或直接以下划线结尾，以区别于普通的变量名。
			c.结构体数据成员与普通变量命名规范一致即可。
*/

////类的引入和定义示例一：使用"struct"关键词定义类。
//struct Rectangle
//{
//	//成员变量
//	int length;
//	int width;
//
//	//成员函数(不同于C语言中的结构体，C++中的结构体允许有函数成员)
//	int Area()
//	{
//		return length * width;
//	}
//};
//
//int main()
//{
//	Rectangle rect;//直接可以使用类名加对象名实例化对象"rect"。
//	rect.length = 10;//通过对象名访问成员变量。
//	rect.width = 20;//通过对象名访问成员变量。
//	std::cout << "Area = " << rect.Area() << std::endl;//通过对象名访问成员函数。
//	return 0;
//}

////类的引入和定义示例二：使用"class"关键词定义类。
//class Rectangle
//{
//public://公有成员访问权限，将在本章的"03"小节中介绍。
//	//成员变量
//	int length;
//	int width;
//
//	//成员函数
//	int Area()
//	{
//		return length * width;
//	}
//};
//
//int main()
//{
//	Rectangle rect;
//	rect.length = 10;
//	rect.width = 20;
//	std::cout << "Area = " << rect.Area() << std::endl;
//	return 0;
//}

////类的引入和定义示例三：在类体外定义的静态成员变量和成员函数。
//class Test
//{
//public:
//	//成员变量
//	int m_a;//声明成员变量，属于对象级别。
//	static int m_b;//声明静态成员变量，属于类级别。
//
//	//成员函数
//	void Func();//声明成员函数，属于对象级别。
//};
//
//int Test::m_b = 10;//在类体外定义已在类中声明的静态成员变量。
//
//void Test::Func()//在类体外定义已在类中声明的成员函数。
//{
//	std::cout << "Func()" << std::endl;
//}
//
//int main()
//{
//	Test test;
//
//	test.m_a = 10;//通过对象名访问成员变量。
//
//	test.Func();//通过对象名访问成员函数。
//
//	std::cout << "test.m_a = " << test.m_a << std::endl;//通过对象名访问成员变量。
//
//	std::cout << "Test::m_b = " << Test::m_b << std::endl;//通过类名访问静态成员变量。
//
//	return 0;
//}

/**
	类的访问限定符及封装
		1.访问说明符：又称为访问限定符，在类的成员说明中定义其后继成员的可访问性。
			a.C++中的访问说明符有"public"、"protected"和"private"三种。
				a'."public"：公有访问权限，该访问说明符之后的各个成员具有公开成员访问，可以在类的内部和外部被访问。
				b'."private"：私有访问权限，该访问说明符之后的各个成员具有私有成员访问，成员在类的内部可以被访问，外部不可以被访问。
				c'."protected"：保护访问权限，该访问说明符之后的各个成员具有保护成员访问，类似于私有访问权限，类外部不可以被访问，但是成员在基类的派生类中可以被访问。(当期阶段暂不讨论)
			b.访问说明符说明
				a'.访问说明符的作用范围是从其出现的位置开始，直到下一个访问说明符出现的位置为止，若没有下一个访问说明符，则到类体结束为止。
				b'.类中的所有成员都拥有对类所能访问的所有名字的访问权。
				c'.以"class"关键词定义的类默认的访问说明符为"private"，而以"struct"关键词定义的类默认的访问说明符为"public"(为了兼容C语言)。
				d'.在程序的任何位置使用成员的名字时都会检查其访问，而且如果它不满足访问规则，那么程序不能编译。
		2.封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
			a.C++中可以通过类将数据和操作数据的方法进行有机结合，并且可以通过访问说明符来隐藏对象内部实现细节，并控制哪些方法可以在类的外部直接被使用，从而实现封装。
*/

////类的访问限定符及封装示例一：公开成员访问，即访问说明符"public"的使用。
//class S
//{
//public://从这里开始，直到下一个访问说明符出现的位置为止或者到类体结束为止，类中的成员都具有公开成员访问。
//	int n = 10;
//
//	enum E
//	{
//		A, B, C
//	};
//
//	struct U
//	{
//	};
//};//类体结束，变量"n"、枚举类型"E"、枚举类型"E"的所有成员、结构体类型"U"都具有公开成员访问。
//
//int main()
//{
//	S s;
//
//	std::cout << "s.n = " << s.n << std::endl;//"s.n"可以在类的外部被访问。
//
//	std::cout << "S::E::A = " << S::E::A << std::endl;//枚举类型"E"的所有成员可以在类的外部被访问。(只列举其中一个成员)
//
//	S::U u;//结构体类型"U"可以在类的外部被访问。
//
//	return 0;
//}

////类的访问限定符及封装示例二：私有访问权限，即访问说明符"private"的使用。
//class S
//{
//private:
//	int n = 10;
//};
//
//int main()
//{
//	S s;
//	//std::cout << "s.n = " << s.n << std::endl;//错误，"s.n"不能在类的外部被访问，因为它具有私有访问权限。
//	return 0;
//}

/**
	类的作用域：在类中声明的名称的作用域是整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。
		1.与类的作用域有关的三个运算符
			a.作用域解析运算符"::"：如果此运算符左侧的查找结果是类名，那么右侧的名字会在该类的作用域中进行查找(可能找到该类或它的基类的成员的声明)，具有例外情况。
			b.成员访问运算符"."：用于对象，提供对它的对象操作数的数据成员或成员函数的访问。
			c.成员指针访问运算符"->"：用于指针，提供对它的指针操作数所指向的类的数据成员或成员函数的访问。
		2.类的成员名存在的四种语境(派生类暂不考虑)
			a.在其自身的类作用域之中。
			b.在对其类的对象(表达式)运用成员访问运算符"."之后。
			c.在对其指向类的对象的指针(表达式)运用成员指针访问运算符"->"之后。
			d.在对其类的名字运用作用域解析运算符"::"之后。
*/

////类的作用域示例：类的成员名存在的四种语境。
//class S
//{
//public:
//	int n = 10;//在其自身的类作用域之中，此类往后成员不再赘述。
//	static int m;
//
//	void f();
//};
//
//int S::m = 20;//在对其类的名字运用作用域解析运算符"::"之后。
//
//void S::f()//在对其类的名字运用作用域解析运算符"::"之后。
//{
//	std::cout << "f()" << std::endl;
//}
//
//int main()
//{
//	S s;
//	S* ps = &s;
//
//	std::cout << "s.n = " << s.n << std::endl;//在对其类的对象(表达式)运用成员访问运算符"."之后。
//	std::cout << "S::m = " << S::m << std::endl;//在对其类的名字运用作用域解析运算符"::"之后。
//	std::cout << "ps->n = " << ps->n << std::endl;//在对其指向类的对象的指针(表达式)运用成员指针访问运算符"->"之后。
//
//	s.f();//在对其类的对象(表达式)运用成员访问运算符"."之后。
//	ps->f();//在对其指向类的对象的指针(表达式)运用成员指针访问运算符"->"之后。
//
//	return 0;
//}

/**
	类的实例化和对象模型
		1.类的实例化：类的实例化是指将类的定义转换为类的对象的过程。
			a.一个类可以实例化出多个对象。
			b.类实例化出的对象，占据着实际的内存空间(栈区或堆区)，存储着类的成员变量。
		2.类的内存分配(对象模型)
			a.定义类时，并不会实际分配内存，只有在实例化对象时，才会分配内存。(不包括类的静态成员)
			b.当类中含有一个或多个静态成员变量声明时，它们将在其定义时于内存中的静态区分配内存，并且此类实例化出的所有对象都共享这些静态成员变量。
			c.类中所定义的函数(包括类体外定义的函数)(不论是静态或是非静态)，它们都存储在内存的代码段中，计算类的大小时，不包括函数的大小。
		3.计算类的大小：实际上是计算使用类所实例化出的对象的所占空间大小。
			a.使用"sizeof"运算符可以计算类或类的对象的大小
				a'.当应用于类类型时，结果是该类的完整对象所占据的字节数，实际上就是计算该类中所有成员变量所占据的字节数(不包括静态成员变量)。
				b'."sizeof"运算符的结果始终非零，即使应用于空类。
			b.空类的大小通常为一个字节(由编译器所决定的)，其并不存储有效数据，而是作为占位，标记着对象的存在，以区分实例化后的对象。
			c.与C语言一样，C++中的类也涉及到内存对齐的规则，这里不再赘述。
*/

////类的实例化和对象模型示例一：共享的静态成员变量。
//class S
//{
//public:
//	static int m;
//};
//
//int S::m = 0;
//
//int main()
//{
//	S s1, s2;
//
//	s1.m = 1;
//	s2.m = 2;
//
//	std::cout << "s1.m = " << s1.m << "\n"
//			  << "s2.m = " << s2.m << "\n"
//			  << "S::m = " << S::m << std::endl;//发现三者的值都是"2"，说明静态成员变量是共享的。
//
//	return 0;
//}

////类的实例化和对象模型示例二：计算类的大小。
//class A
//{
//public:
//	void PrintA()
//	{
//		std::cout << "PrintA()" << std::endl;
//	}
//
//private:
//	char _a;
//	static int _b;
//};
//
//int A::_b = 0;
//
//int main()
//{
//	A a;
//	std::cout << "sizeof(A) = " << sizeof(A) << std::endl;//计算的结果不包含静态成员变量以及函数，结果为：1。
//	std::cout << "sizeof(a) = " << sizeof(a) << std::endl;//发现结果为：1，与上面的结果一致。
//	return 0;
//}

////类的实例化和对象模型示例三：计算空类的大小。
//class A1//类中既有成员变量，又有成员函数。
//{
//public:
//	void f1()
//	{
//	}
//
//private:
//	int _a;
//};
//
//class A2//类中只有成员函数。
//{
//public:
//	void f2()
//	{
//	}
//};
//
//class A3//空类。
//{
//};
//
//int main()
//{
//	std::cout << "sizeof(A1) = " << sizeof(A1) << std::endl;//此类体中既有成员变量，又有成员函数，计算的是成员变量的大小，结果为：4。
//	std::cout << "sizeof(A2) = " << sizeof(A2) << std::endl;//此类体中只有成员函数，等同于空类，结果为：1。
//	std::cout << "sizeof(A3) = " << sizeof(A3) << std::endl;//此类为空类，结果为：1。
//
//	A3 a1, a2;
//	std::cout << "&a1 = " << &a1 << " " << "&a2 = " << &a2 << std::endl;//发现一个空类实例化出的两个对象的地址是不相同的。
//
//	return 0;
//}

////类的实例化和对象模型示例四：计算类的大小(探究类的内存对齐)。
//class A
//{
//public:
//	int _a;
//	char _b;
//	int _c;
//};
//
//int main()
//{
//	//获取编译器的默认对齐数
//	std::cout << "默认对齐数：" << alignof(A) << std::endl;
//
//	//计算类的大小
//	std::cout << "sizeof(A) = " << sizeof(A) << std::endl;
//	//类"A"第一个成员变量类型为"int"，大小为"4"个字节，存放在偏移量为"0"的地址处。
//	//类"A"第二个成员变量类型为"char"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"4"的地址处。
//	//类"A"第三个成员变量类型为"int"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"4"的整数倍的地址处，即偏移量为"8"的地址处。
//	//类"A"的总大小，是当前已存放的总内存大小("12")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"4"的整数倍，即大小为"12"字节。
//
//	//计算类中的所有成员变量的偏移量
//	std::cout << "offsetof(A, _a) = " << offsetof(A, _a) << "\n"
//			  << "offsetof(A, _b) = " << offsetof(A, _b) << "\n"
//			  << "offsetof(A, _c) = " << offsetof(A, _c)
//			  << std::endl;
//
//	return 0;
//}
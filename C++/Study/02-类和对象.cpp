#include <iostream>

/*
	类和对象
		01.面向过程和面向对象的初步认识
		02.类的引入和定义
		03.类的访问限定符及封装
		04.类的作用域
		05.类的实例化和对象模型
		06."this"指针
		07.类的六个默认成员函数
		08.构造函数
		09.析构函数
		10.拷贝构造函数
		11.运算符重载和拷贝赋值运算符
		12."const"成员函数
		13.再谈构造函数
		14."static"成员
		15.友元
		16.内部类
		17.匿名对象
		18."Copy elision"策略和"RVO"优化
		19.再次理解类和对象
*/

/**
	面向过程和面向对象的初步认识
		1.C与C++
			a.C是面向过程的语言，其注重的是过程，即分析解决问题所需的步骤，从而通过函数逐步解决问题。
			b.C++严格意义上是面向过程与面向对象混合型语言，可理解为面向对象的语言，其注重的是对象，即分析解决问题所需的对象，从而通过对象之间的交互来解决问题。
		2.思维上的面向过程和面向对象
			a.无论是面向过程还是面向对象，都是一种思维方式，即分析解决问题所需的步骤或对象，从而通过函数或对象之间的交互来解决问题。
			b.汇编语言是面向机器的语言，也可说是面向细节的语言，其需要通过一条条指令操作来解决问题，是人脑模拟计算机的一种思维方式。
		3.语言上的面向过程和面向对象
			a.面向过程和面向对象并不决定于语言，而是取决于思维，它是一种编程思想，而语言是可以实现这种思想的工具。
			b.C语言并非不可以实现面向对象的思想，仅是在面向对象方面，C语言提供的语法支持较为薄弱，但C语言的结构体、函数指针可以实现面向对象的思想，事实上，使用C语言实现的多数编程框架、库、驱动等都是具有面向对象思想的。
			c.C++在语法层面上提供了对面向对象编程更好的支持，能让使用它的人更加优雅的面向对象编程。
		4.面向对象的三大特征：封装、继承、多态。(随着学习的深入，会逐渐理解这三个特征的含义)
			a.封装：将数据和操作数据的函数封装在一起，形成一个类，通过类的实例化来创建对象，从而实现对数据的操作。
			b.继承：子类继承父类的数据和函数，从而实现代码的复用。
			c.多态：同一函数在不同的对象中有不同的实现，从而实现不同对象对同一函数的不同响应。
*/

/**
	类的引入和定义
		1.C++对C语言结构体的升级
			a.C++对C语言的结构体进行了升级，将其称之为类，其兼容了C语言中结构体的所有用法，并使其具有了面向对象的特征。
			b.C语言中的结构体只允许有变量，不能有函数，而C++中的结构体允许有变量(数据成员)和函数(函数成员)。
			c.C++中将结构体的名称称之为类名，将结构体中的数据成员称之为成员变量或类的属性，将结构体中的函数成员称之为成员函数或类的方法。
			d.使用已经定义的类去说明它的实例变量，称之为对象。
			e.一个对象是类的一个实例，类中具有的成员变量和成员函数，对于对象来说也是对象的属性和对象的方法。
			f.C++使用类实例化对象时，可以直接使用类名与对象名进行实例化，而C语言使用结构体类型定义结构体变量时，须在变量名前添加上"struct"关键词(除非使用"typedef"关键词对结构体类型进行重定义)。
		2."class"关键词
			a.使用"class"关键词定义类的格式如下：
				class 类头名
				{
					类体(类中的成员说明)
				};
			b.除了默认成员访问和默认基类访问之外(将在本章的"类的访问限定符及封装"小节中介绍)，可以认为"class"关键词与"struct"关键词在类的声明上是等同的。
			c.类中的成员变量均是声明，而非定义，因定义变量代表着对变量进行内存分配，而类中的是在类的实例化对象的过程中才会分配内存空间。(仅代表非静态成员变量)
			d.函数的声明代表引入函数的原型，而函数的定义代表将函数的原型与函数体进行关联，并且函数的定义不代表着分配内存。
			e.整个定义都在类的定义内的函数是隐式的内联函数。
			f.C++11前，类体中不可声明的同时给予缺省值于非静态数据成员(除非是常量静态数据成员)，而C++11后，非静态数据成员可以在类体中声明的同时给予缺省值，但其依旧是声明而不是定义。
		3.类的两种定义方式(暂不考虑静态成员函数)
			a.在类体中声明成员变量和定义成员函数。(包括静态成员变量、常量静态成员数据、非静态成员变量)
			b.在类体中声明静态成员变量和成员函数，然后在类体外定义静态成员变量和成员函数。(声明和定义分离的一种体现)
				a'.类体中并不能定义静态成员变量，静态成员变量是随着类的，其存在于内存的静态区，并且静态成员变量属于类级别高于普通成员变量的对象级别，不能随着对象的创建再申请静态成员变量的内存，所以需要单独在类的外部定义。
				b'.在类体外定义静态成员变量或成员函数时，需在静态成员变量定义的变量名或成员函数定义的函数名前加上类名和作用域解析运算符"::"。
		4.关于"struct"关键词和"class"关键词的编程规范
			a.通常情况下仅当只有数据成员时使用"struct"关键词，其它一概使用"class"关键词，因为这两个关键词的含义几乎相同，所以我们为这两个关键词添加我们自己的语义理解，以便为定义的数据类型选择合适的关键词。
			b."class"类体中的成员变量命名是具有多种不同的命名规范的，通常会在成员变量名前加上"m_"前缀或直接以下划线结尾，以区别于普通的变量名。
			c.结构体数据成员与普通变量命名规范一致即可。
*/

////类的引入和定义示例一：使用"struct"关键词定义类。
//struct Rectangle
//{
//	//成员变量
//	int length;
//	int width;
//
//	//成员函数(不同于C语言中的结构体，C++中的结构体允许有函数成员)
//	int Area()
//	{
//		return length * width;
//	}
//};
//
//int main()
//{
//	Rectangle rect;//直接可以使用类名与对象名实例化对象"rect"。
//	rect.length = 10;//通过对象名访问成员变量。
//	rect.width = 20;//通过对象名访问成员变量。
//	std::cout << "Area = " << rect.Area() << std::endl;//通过对象名访问成员函数。
//	return 0;
//}

////类的引入和定义示例二：使用"class"关键词定义类。
//class Rectangle
//{
//public://公有成员访问权限，将在本章的"类的访问限定符及封装"小节中介绍。
//	//成员变量
//	int length;
//	int width;
//
//	//成员函数
//	int Area()
//	{
//		return length * width;
//	}
//};
//
//int main()
//{
//	Rectangle rect;
//	rect.length = 10;
//	rect.width = 20;
//	std::cout << "Area = " << rect.Area() << std::endl;
//	return 0;
//}

////类的引入和定义示例三：在类体外定义的静态成员变量和成员函数。
//class Test
//{
//public:
//	//成员变量
//	int m_a;//声明成员变量，属于对象级别。
//	static int m_b;//声明静态成员变量，属于类级别。
//
//	//成员函数
//	void Func();//声明成员函数，属于对象级别。
//};
//
//int Test::m_b = 10;//在类体外定义已在类中声明的静态成员变量。
//
//void Test::Func()//在类体外定义已在类中声明的成员函数。
//{
//	std::cout << "Func()" << std::endl;
//}
//
//int main()
//{
//	Test test;
//
//	test.m_a = 10;//通过对象名访问成员变量。
//
//	test.Func();//通过对象名访问成员函数。
//
//	std::cout << "test.m_a = " << test.m_a << std::endl;//通过对象名访问成员变量。
//
//	std::cout << "Test::m_b = " << Test::m_b << std::endl;//通过类名访问静态成员变量。
//
//	return 0;
//}

/**
	类的访问限定符及封装
		1.访问说明符：又称为访问限定符，在类的成员说明中定义其后继成员的可访问性。
			a.C++中的访问说明符有"public"、"protected"和"private"三种。
				a'."public"：公有访问权限，该访问说明符之后的各个成员具有公开成员访问，可以在类的内部和外部被访问。
				b'."private"：私有访问权限，该访问说明符之后的各个成员具有私有成员访问，成员在类的内部可以被访问，外部不可以被访问。
				c'."protected"：保护访问权限，该访问说明符之后的各个成员具有保护成员访问，类似于私有访问权限，类外部不可以被访问，但是成员在基类的派生类中可以被访问。(当期阶段暂不讨论)
			b.访问说明符说明
				a'.访问说明符的作用范围是从其出现的位置开始，直到下一个访问说明符出现的位置为止，若没有下一个访问说明符，则到类体结束为止。
				b'.类中的所有成员都拥有对类所能访问的所有名字的访问权。(包括在类中声明的成员函数，并在类外定义的成员函数)
				c'.以"class"关键词定义的类默认的访问说明符为"private"，而以"struct"关键词定义的类默认的访问说明符为"public"(为了兼容C语言)。
				d'.在程序的任何位置使用成员的名字时都会检查其访问，而且如果它不满足访问规则，那么程序不能编译。
		2.封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
			a.C++中可以通过类将数据和操作数据的方法进行有机结合，并且可以通过访问说明符来隐藏对象内部实现细节，并控制哪些方法可以在类的外部直接被使用，从而实现封装。
*/

////类的访问限定符及封装示例一：公开成员访问，即访问说明符"public"的使用。
//class S
//{
//public://从这里开始，直到下一个访问说明符出现的位置为止或者到类体结束为止，类中的成员都具有公开成员访问。
//	int n = 10;
//
//	enum E
//	{
//		A, B, C
//	};
//
//	struct U
//	{
//	};
//};//类体结束，变量"n"、枚举类型"E"、枚举类型"E"的所有成员、结构体类型"U"都具有公开成员访问。
//
//int main()
//{
//	S s;
//
//	std::cout << "s.n = " << s.n << std::endl;//"s.n"可以在类的外部被访问。
//
//	std::cout << "S::E::A = " << S::E::A << std::endl;//枚举类型"E"的所有成员可以在类的外部被访问。(只列举其中一个成员)
//
//	S::U u;//结构体类型"U"可以在类的外部被访问。
//
//	return 0;
//}

////类的访问限定符及封装示例二：私有访问权限，即访问说明符"private"的使用。
//class S
//{
//public:
//	//打印函数
//	void print()
//	{
//		std::cout << "n = " << n << std::endl;//类定义中的成员函数可以访问类中的所有成员。
//	}
//
//private:
//	int n = 10;
//};
//
//int main()
//{
//	S s;
//	//std::cout << "s.n = " << s.n << std::endl;//错误，"s.n"不能在类的外部被访问，因为它具有私有访问权限。
//	s.print();//通过类定义中的公开成员函数"print"来访问类中的私有成员，是Java中常用的方法。
//	return 0;
//}

/**
	类的作用域：在类中声明的名称的作用域是整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。
		1.与类的作用域有关的三个运算符
			a.作用域解析运算符"::"：如果此运算符左侧的查找结果是类名，那么右侧的名字会在该类的作用域中进行查找(可能找到该类或它的基类的成员的声明)，具有例外情况。
			b.成员访问运算符"."：用于访问对象的成员，提供对它的对象操作数的数据成员或成员函数的访问。
			c.成员访问运算符"->"：用于访问指针的成员，提供对它的指针操作数所指向的类的数据成员或成员函数的访问。
		2.类的成员名存在的四种语境(派生类暂不考虑)
			a.在其自身的类作用域之中。
			b.在对其类的对象(表达式)运用成员访问运算符"."之后。
			c.在对其指向类的对象的指针(表达式)运用成员访问运算符"->"之后。
			d.在对其类的名字运用作用域解析运算符"::"之后。
*/

////类的作用域示例：类的成员名存在的四种语境。
//class S
//{
//public:
//	int n = 10;//在其自身的类作用域之中，此类往后成员不再赘述。
//	static int m;
//
//	void f();
//};
//
//int S::m = 20;//在对其类的名字运用作用域解析运算符"::"之后。
//
//void S::f()//在对其类的名字运用作用域解析运算符"::"之后。
//{
//	std::cout << "f()" << std::endl;
//}
//
//int main()
//{
//	S s;
//	S* ps = &s;
//
//	std::cout << "s.n = " << s.n << std::endl;//在对其类的对象(表达式)运用成员访问运算符"."之后。
//	std::cout << "S::m = " << S::m << std::endl;//在对其类的名字运用作用域解析运算符"::"之后。
//	std::cout << "ps->n = " << ps->n << std::endl;//在对其指向类的对象的指针(表达式)运用成员访问运算符"->"之后。
//
//	s.f();//在对其类的对象(表达式)运用成员访问运算符"."之后。
//	ps->f();//在对其指向类的对象的指针(表达式)运用成员访问运算符"->"之后。
//
//	return 0;
//}

/**
	类的实例化和对象模型
		1.类的实例化：类的实例化是指将类的定义转换为类的对象的过程。
			a.一个类可以实例化出多个对象。
			b.类实例化出的对象，占据着实际的内存空间(栈区或堆区)，存储着类的成员变量。
		2.类的内存分配(对象模型)
			a.定义类时，并不会实际分配内存，只有在实例化对象时，才会分配内存。(不包括类的静态成员)
			b.当类中含有一个或多个静态成员变量声明时，它们将在其定义时于内存中的静态区分配内存，并且此类实例化出的所有对象都共享这些静态成员变量。
			c.类中所定义的函数(包括类体外定义的函数)(不论是静态或是非静态)，它们都存储在内存的代码段中，计算类的大小时，不包括函数的大小。
		3.计算类的大小：实际上是计算使用类所实例化出的对象的所占空间大小。
			a.使用"sizeof"运算符可以计算类或类的对象的大小
				a'.当应用于类类型时，结果是该类的完整对象所占据的字节数，实际上就是计算该类中所有成员变量所占据的字节数(不包括静态成员变量)。
				b'.注意："sizeof"运算符的结果始终非零，即使应用于空类。
			b.空类的大小通常为一个字节(由编译器所决定的)，其并不存储有效数据，而是作为占位，标记着对象的存在，以区分实例化后的对象。
			c.与C语言一样，C++中的类也涉及到内存对齐的规则，这里不再赘述。
*/

////类的实例化和对象模型示例一：共享的静态成员变量。
//class S
//{
//public:
//	static int m;
//};
//
//int S::m = 0;
//
//int main()
//{
//	S s1, s2;
//
//	s1.m = 1;
//	s2.m = 2;
//
//	std::cout << "s1.m = " << s1.m << "\n"
//			  << "s2.m = " << s2.m << "\n"
//			  << "S::m = " << S::m << std::endl;//发现三者的值都是"2"，说明静态成员变量是共享的。
//
//	return 0;
//}

////类的实例化和对象模型示例二：计算类的大小。
//class A
//{
//public:
//	void PrintA()
//	{
//		std::cout << "PrintA()" << std::endl;
//	}
//
//private:
//	char _a;
//	static int _b;
//};
//
//int A::_b = 0;
//
//int main()
//{
//	A a;
//	std::cout << "sizeof(A) = " << sizeof(A) << std::endl;//计算的结果不包含静态成员变量以及函数，结果为：1。
//	std::cout << "sizeof(a) = " << sizeof(a) << std::endl;//发现结果为：1，与上面的结果一致。
//	return 0;
//}

////类的实例化和对象模型示例三：计算空类的大小。
//class A1//类中既有成员变量，又有成员函数。
//{
//public:
//	void f1()
//	{
//	}
//
//private:
//	int _a;
//};
//
//class A2//类中只有成员函数。
//{
//public:
//	void f2()
//	{
//	}
//};
//
//class A3//空类。
//{
//};
//
//int main()
//{
//	std::cout << "sizeof(A1) = " << sizeof(A1) << std::endl;//此类体中既有成员变量，又有成员函数，计算的是成员变量的大小，结果为：4。
//	std::cout << "sizeof(A2) = " << sizeof(A2) << std::endl;//此类体中只有成员函数，等同于空类，结果为：1。
//	std::cout << "sizeof(A3) = " << sizeof(A3) << std::endl;//此类为空类，结果为：1。
//
//	A3 a1, a2;
//	std::cout << "&a1 = " << &a1 << " " << "&a2 = " << &a2 << std::endl;//发现一个空类实例化出的两个对象的地址是不相同的。
//
//	return 0;
//}

////类的实例化和对象模型示例四：计算类的大小(探究类的内存对齐)。
//class A
//{
//public:
//	int _a;
//	char _b;
//	int _c;
//};
//
//int main()
//{
//	//获取编译器的默认对齐数
//	std::cout << "默认对齐数：" << alignof(A) << std::endl;
//
//	//计算类的大小
//	std::cout << "sizeof(A) = " << sizeof(A) << std::endl;
//	//类"A"第一个成员变量类型为"int"，大小为"4"个字节，存放在偏移量为"0"的地址处。
//	//类"A"第二个成员变量类型为"char"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"1"的整数倍的地址处，即偏移量为"4"的地址处。
//	//类"A"第三个成员变量类型为"int"，大小为"1"个字节，存放在对齐数(取成员类型大小与默认对齐数的较小值)为"4"的整数倍的地址处，即偏移量为"8"的地址处。
//	//类"A"的总大小，是当前已存放的总内存大小("12")扩展到每个成员的对齐数的最大对齐数的整数倍，也就是对齐数"4"的整数倍，即大小为"12"字节。
//
//	//计算类中的所有成员变量的偏移量
//	std::cout << "offsetof(A, _a) = " << offsetof(A, _a) << "\n"
//			  << "offsetof(A, _b) = " << offsetof(A, _b) << "\n"
//			  << "offsetof(A, _c) = " << offsetof(A, _c) << std::endl;
//
//	return 0;
//}

/**
	"this"指针：纯右值(与右值相同)表达式，它的值是隐式对象形参(在它之上调用非静态成员函数的对象)的地址。
		1.不同对象调用同一个成员函数，编译器如何区分？
			a.编译器会在每个非静态成员函数的形参列表中加上一个隐式的形参，这个形参就是"this"指针，它的值就是调用该成员函数的对象的地址，所以在成员函数中可以通过"this"指针来区分不同对象。
			b.成员函数函数体中对对象的属性的访问或是操作，都是通过"this"指针隐式访问该对象，从而完成对对象的属性进行访问或是操作。
		2."this"指针的特性
			a.在类的成员函数中，"this"指针是指向类的指针，即"类名*"，但"this"指针是不能改变其指向的对象的，故"this"指针的类型是"类名* const"。
			b."this"指针在C++的不同标准下具有不同的出现语境，详见文档。
			c.对象中并不会存储"this"指针，其并不是随着对象的实例化而存在的，而是随着成员函数的调用，作为成员函数的形参接收对象的地址，所以其存在于堆栈或寄存器中(根据调用规定决定)。
			d.通常访问对象的成员变量时，编译器会隐式的使用"this"指针，也可以显式的使用"this"指针，但是显式的使用"this"指针时，必须要加上"->"运算符，并且左操作数为"this"指针，右操作数为成员变量。
			e."this"指针作为非静态成员函数的第一个隐式形参，添加到成员函数的参数列表中，并出现在第一个实际参数之前。
		3.文档：https://zh.cppreference.com/w/cpp/language/this。
*/

////"this"指针示例一：隐含的"this"指针。
//class T
//{
//public:
//	void Print()//其成员函数的形参列表具有一个隐式的形参，即"this"指针。
//	{
//		std::cout << "this = " << this << std::endl;//通过显式的"this"指针打印其存放的值。
//	}
//
//	void foo()
//	{
//		x = 1000;//此行语句等同于"this->x = 1000;"。
//		std::cout << "x = " << x << std::endl;
//		this->x = 5;//显式的使用"this"指针访问成员变量。
//		std::cout << "this->x = " << this->x << std::endl;
//	}
//
//	void foo(int x)//此时的形参"x"与成员变量"x"同名，需要显式的使用"this"指针才能够表示成员变量，否则会被认为是形参。
//	{
//		x = 10;//此时修改的"x"是形参"x"，而不是成员变量"x"。
//		std::cout << "x(形参) = " << x << std::endl;//输出形参"x"的值。
//		std::cout << "this->x = " << this->x << std::endl;//输出成员变量"x"的值。
//	}
//
//private:
//	int x = 0;
//};
//
//int main()
//{
//	T t;
//
//	printf("Print()：\n");
//	std::cout << "&t = " << &t << std::endl;
//	t.Print();//可以发现，"this"指针的值就是调用该成员函数的对象的地址。
//
//	printf("\nfoo()：\n");
//	t.foo();
//
//	printf("\nfoo(int x)：\n");
//	t.foo(0);
//
//	return 0;
//}

////"this"指针示例二：判别以下程序分别会出现什么错误。
//class A
//{
//public:
//	void PrintA()
//	{
//		std::cout << "PrintA()" << std::endl;
//	}
//
//	void PrintB()
//	{
//		std::cout << _a << std::endl;//实际上为"this->_a"，若此时"this"指针的值为空，则会出现空指针解引用的错误(段错误)。
//	}
//
//private:
//	int _a;
//};
//
//int main()
//{
//	A* p = nullptr;
//	p->PrintA();//"p->PrintA()"不发生解引用，因为成员函数的地址并不在对象中；此处将"nullptr"作为实参传递给了成员函数中的"this"指针，程序正常运行。
//	p->PrintB();//"p->PrintA()"依旧不发生解引用，但是"PrintB()"函数中访问了成员变量(进行了解引用)，因此会发生段错误。
//	return 0;
//}

/**
	类的六个默认成员函数
		1.类的六个默认成员函数分别为：默认构造函数、默认拷贝构造函数、默认移动构造函数(C++11)、默认拷贝赋值运算符、默认移动赋值运算符(C++11)、默认析构函数。
			a.在一个什么都没有的类中，将其称之为空类，而此时编译器会为其隐式生成六个默认成员函数，注意编译器也可能无法生成其中的某些默认成员函数。
			b.默认移动构造函数和默认移动赋值运算符是C++11中新增的，用于移动语义。
		2.平凡与非平凡的特殊成员函数(拓展以便于阅读文档)
			a.平凡意味着这些特殊的成员函数用很朴素的方式完成它们的工作，而朴素的方式这个说法对于不同的特殊成员函数有不同的含义。
			b.非平凡意味着是由自己定义的成员函数，即使它什么也不做，也不是平凡的，这就意味着平凡实际上是由编译器隐式定义的。
			c.由编译器隐式生成的特殊成员函数是平凡的，而由用户自己显式定义的特殊成员函数是非平凡的。
*/

/**
	构造函数：构造函数是类的一种特殊的非静态成员函数，用于初始化该类类型的对象。
		1.构造函数的语法格式
			a.构造函数的名字与类名相同，且没有返回值。
			b.构造函数使用成员函数声明符声明，并且其具有多种形式，此小节只演示常见的构造函数，其他形式的构造函数请参考文档。
		2.构造函数的特性
			a.默认构造函数是不需要实参就能调用的构造函数(以空的或为每个形参提供默认实参的参数列表定义)。
			b.当类示例化一个对象时，构造函数将被自动调用，用于初始化该对象，保证了对象的每个数据成员都有一个合适的初始值，并在只在对象整个生命周期内调用一次。
			c.构造函数是可以重载的，并且也可以配合缺省参数使用，但注意只能有一个默认构造函数，若是一个无参的构造函数和全缺省的构造函数同时存在，则当调用时默认构造函数时编译器会报错(二义性问题)。
			d.当类没有显式定义任何默认构造函数时，编译器会自动为其隐式生成一个默认构造函数，而如果当类显式定义了默认构造函数时，编译器将不再为其生成。
			e.由编译器隐式生成的默认构造函数并不会对其基本类型(内置类型)的成员变量进行操作，而对于自定义类型的成员变量，编译器会调用属于它类中的默认构造函数(若此成员变量的类中依旧没有显式定义默认构造函数，则编译器依旧生成默认构造函数，以此往复)。
			f.在本章的"类的引入和定义-2.-f."中我们提到了在类的成员变量声明处给缺省值的方法，编译器在隐式生成默认构造函数中，会使用此值给此成员变量赋初值，但若是显式定义了默认构造函数则会使用此默认构造函数中的值给内置类型的成员变量赋值(若无则自动添加)。
		3.文档
			a.https://zh.cppreference.com/w/cpp/language/constructor。(构造函数与成员初始化列表)
			b.https://zh.cppreference.com/w/cpp/language/default_constructor。(默认构造函数)
*/

////构造函数示例一：在类中显式定义构造函数。
//class A
//{
//public:
//	A(int a, int b)
//	{
//		this->a = a;//为更容易区分形参和成员变量，这里使用"this"指针。
//		this->b = b;
//	}
//
//	void Print()
//	{
//		std::cout << "a = " << a << ", b = " << b << std::endl;
//	}
//
//private:
//	int a;
//	int b;
//};
//
//int main()
//{
//	A a(1, 2);//构造函数能够初始化对象的数据成员。
//	a.Print();//可以发现对象"a"的数据成员已经被初始化。
//	return 0;
//}

////构造函数示例二：无参和带参的构造函数重载。
//class Date
//{
//public:
//	//无参构造函数
//	Date()
//	{
//		_year = 0;
//		_month = 0;
//		_day = 0;
//	}
//
//	//有参构造函数
//	Date(int year, int month, int day)
//	{
//		_year = year;
//		_month = month;
//		_day = day;
//	}
//
//	void Print()
//	{
//		std::cout << _year << "-" << _month << "-" << _day << std::endl;
//	}
//
//private:
//	int _year;
//	int _month;
//	int _day;
//};
//
//int main()
//{
//	Date d1;//此时会直接调用无参构造函数(自动)。
//	Date d2(2002, 8, 30);//此时会直接调用带参的构造函数。
//	//Date d3();//错误，因为这种写法是函数声明(空括号解释为函数声明)，而不是调用无参的构造函数。
//
//	d1.Print();//可以发现对象"d1"的数据成员都已经被无参构造函数初始化为"0"。
//	d2.Print();//可以发现对象"d2"的数据成员都已经被带参构造函数初始化为先前指定的值。
//
//	return 0;
//}

////构造函数示例三：具有二义性的构造函数。
//class A
//{
//public:
//	A()
//	{
//		_a = _b = _c = _d = 0;
//		_pi = nullptr;
//		_pj = nullptr;
//	}
//
//	A(int a = 0, int b = 0, int c = 0, int d = 0, int* pi = nullptr, int* pj = nullptr)
//	{
//		_a = a;
//		_b = b;
//		_c = c;
//		_d = d;
//		_pi = pi;
//		_pj = pj;
//	}
//
//	int _a, _b, _c, _d;
//	int* _pi, * _pj;
//};
//
//int main()
//{
//	//A a1;//错误，对类中"A"的构造函数的调用不明确，因其具有二义性。
//	A a2(1, 2, 3, 4, nullptr, nullptr);//调用全缺省的构造函数。
//	return 0;
//}

////构造函数示例四：编译器自动为类生成的隐式默认构造函数。
//class A
//{
//public:
//	A()//若此构造函数被注释，则编译器依旧会自动生成一个默认构造函数，只会对成员变量"_d"做处理，其余内置类型的成员变量都为随机值。
//	{
//		_a = _b = _c = 0;
//		_d = 0;//若此行被注释，在调用此默认构造函数时，成员变量"_d"的值依旧会被设置成声明处给定的缺省值(反汇编可见)。
//		_pi = nullptr;
//		_pj = nullptr;
//	}
//
//	int _a, _b, _c;
//	int _d = 99999999;//C++11起允许在类中给非静态数据成员指定缺省值。
//	int* _pi, * _pj;
//};
//
//class Date//部分编译器会在此报警告：构造函数不初始化这些字段："_year"、"_month"、"_day"。
//{
//public:
//	void Print()
//	{
//		std::cout << "Print()：" << _year << "-" << _month << "-" << _day << std::endl;
//	}
//
//	A _a;//此类中包含了另一个类的成员变量，编译器会在此类中的默认构造函数调用另一个类的构造函数。
//	int _year;
//	int _month;
//	int _day;
//};
//
//int main()
//{
//	Date d1;//此类中的默认构造函数只会对自定义类型的成员变量调用属于它的默认构造函数。
//
//	d1.Print();//构造函数不初始化这些字段："_year"、"_month"、"_day"，所以这里打印出来的是随机值。
//
//	std::cout << d1._a._a << '\n'
//			  << d1._a._b << '\n'
//			  << d1._a._c << '\n'
//			  << d1._a._d << '\n'
//			  << (d1._a._pi == nullptr) << '\n'
//			  << (d1._a._pj == nullptr) << std::endl;//可以发现，这些成员变量都被构造函数所初始化为对应的值。
//
//	return 0;
//}

/**
	析构函数：析构函数是对象生存期终结时调用的特殊成员函数，其目的是释放对象可能在它的生存期间获得的资源。
		1.析构函数的语法格式
			a.析构函数常见的语法格式为：~ 类名()，并且构造函数的名字与类名相同，且没有返回值和任何参数。
			b.与构造函数一样，析构函数也具有多种形式，此小节只演示常见的析构函数，其他形式的构造函数请参考文档。
		2.析构函数的特性
			a.一个类中只能有一个析构函数，且析构函数不能被重载。
			b.当一个对象的生命周期结束时，其析构函数会被自动调用。
			c.当类没有显式定义任何析构函数，编译器会自动生成为其隐式生成一个默认析构函数，而如果当类显式定义了默认析构函数时，编译器将不再为其生成。
			d.由编译器隐式生成的默认析构函数并不需要对其基本类型(内置类型)的成员变量进行资源清理(直接回收)，但自定义类型的成员变量编译器会调用属于它类中的默认析构函数(若此成员变量的类中依旧没有显式定义默认析构函数，则编译器依旧生成默认析构函数，以此往复)。
		3.文档：https://zh.cppreference.com/w/cpp/language/destructor。
*/

////析构函数示例一：在类中显式定义析构函数。
//class A
//{
//public:
//	A()
//	{
//		_a = _b = _c = _d = 0;
//		_pi = nullptr;
//		_pj = nullptr;
//	}
//
//	~A()//析构函数
//	{
//		std::cout << "~A()：析构函数被调用" << std::endl;
//	}
//
//	int _a, _b, _c, _d;
//	int* _pi, * _pj;
//};
//
//int main()
//{
//	A a1;//调用类"A"中的默认构造函数。
//
//	return 0;//此时对象"a1"的生命周期结束，调用类"A"中的析构函数。
//}

////析构函数示例二：编译器自动为类生成的默认析构函数。
//class Time
//{
//public:
//	~Time()
//	{
//		std::cout << "~Time()：析构函数被调用" << std::endl;
//	}
//
//private:
//	int _hour;
//	int _minute;
//	int _second;
//};
//
//class Date
//{
//private:
//	int _year;
//	int _month;
//	int _day;
//	Time _t;//此类中包含了另一个类的成员变量，编译器会在此类中的默认析构函数调用另一个类的析构函数。(构造函数不再赘述)
//};
//
//int main()
//{
//	Date d;
//	return 0;//此时对象"d"的生命周期结束，调用类"Date"中的析构函数。
//}

/**
	拷贝构造函数：构造函数的一种衍生，每当从同一类型的另一个对象初始化对象(通过直接初始化或复制初始化)时，都会调用拷贝构造函数。
		1.拷贝构造函数的语法格式：类名(类名& 标识符)。(可由"const"和"volatile"组合修饰括号内的类名)(此处为拷贝构造函数的典型声明)
			a.拷贝构造函数的语法格式类似与构造函数，但其首个形参需是以引用(左值)类型的形式出现，并且没有其他形参或是其他形参均有默认值。
			b.此小节只演示常见的拷贝构造函数的声明。
		2.拷贝构造函数的特性
			a.拷贝构造函数是构造函数的一个重载形式。
			b.拷贝构造函数的首个参数必须是以引用(左值)类型，是按照引用传递的方式传递的，若是以值传递的方式传递，则会重复调用拷贝构造函数，造成无限递归调用。
				a'.当进行以同一类型的另一个对象通过直接初始化或复制初始化对象时，编译器会自动调用拷贝构造函数，但是如果拷贝构造函数是以值的形式传递的，当生成一份临时拷贝时就又会触发复制初始化，又调用拷贝构造函数，造成无限递归调用。
				b'.直接初始化详细文档参见：https://zh.cppreference.com/w/cpp/language/direct_initialization
				c'.复制初始化详细文档参见：https://zh.cppreference.com/w/cpp/language/copy_initialization。
			c.当类没有显式定义任何拷贝构造函数时，编译器会自动为其隐式生成一个默认拷贝构造函数，而如果当类显式定义了默认拷贝构造函数时，编译器将不再为其生成。
			d.由编译器隐式生成的默认拷贝构造函数只会对内置类型进行简单的内存拷贝，而对于自定义类型的成员变量，编译器会调用属于它类中的默认拷贝构造函数(若此成员变量的类中依旧没有显式定义默认拷贝构造函数，则编译器依旧生成默认拷贝构造函数，以此往复)。
			e.由编译器隐式生成的默认拷贝构造函数，只会进行简单的内存拷贝，也就是浅拷贝。
				a'.复制实参的每个标量子对象(递归地包含子对象的子对象，以此类推)，且不进行其他动作，不过不需要复制填充字节，甚至只要它们的值相同，每个复制的子对象的对象表示也不必相同，不允许在对象拷贝的过程中做任何额外的操作。
				b'.即通过简单地复制原始对象的所有变量的数据来创建一个对象，若是含有指针，则只会复制指针的值，而不会复制指针所指向的内存空间。
		3.文档：https://zh.cppreference.com/w/cpp/language/copy_constructor。
*/

////拷贝构造函数示例一：在类中显式定义拷贝构造函数。
//struct A
//{
//	//构造函数
//	A()
//	{
//		x_ = y_ = 10;
//	}
//
//	//拷贝构造函数的典型声明
//	A(const A& a)
//	{
//		x_ = a.x_;
//		y_ = a.y_;
//	}
//
//	int x_, y_;
//};
//
//int main()
//{
//	A a1;//调用类"A"中的默认构造函数。
//
//	std::cout << "a1.x_ = " << a1.x_ << '\n' << "a1.y_ = " << a1.y_ << std::endl;//对象"a1"中的成员变量"x_"和"y_"的值都为：10。
//
//	A a2(a1);//使用对象"a1"初始化对象"a2"，调用类"A"中的拷贝构造函数。
//
//	std::cout << "a2.x_ = " << a2.x_ << '\n' << "a2.y_ = " << a2.y_ << std::endl;//对象"a2"中的成员变量"x_"和"y_"的值都为：10。
//
//	A a3 = a1;//另一种初始化对象的方式，使用对象"a1"初始化对象"a3"，调用类"A"中的拷贝构造函数。
//
//	std::cout << "a3.x_ = " << a3.x_ << '\n' << "a3.y_ = " << a3.y_ << std::endl;//对象"a3"中的成员变量"x_"和"y_"的值都为：10。
//
//	return 0;
//}

////拷贝构造函数示例二：以值传递和以引用传递的拷贝构造函数。
//struct A
//{
//	//构造函数
//	A()
//	{
//		x_ = y_ = 10;
//	}
//
//	////错误的拷贝构造函数
//	//A(const A a)//当以值传递的方式传递参数时，生成临时拷贝时又会触发复制初始化，又调用拷贝构造函数，造成无限递归调用，部分编译器会直接报错处理：复制构造函数必须通过引用传递它的第一个参数。
//	//{
//	//	x_ = a.x_;
//	//	y_ = a.y_;
//	//}
//
//	//正确的拷贝构造函数
//	A(const A& a)
//	{
//		x_ = a.x_;
//		y_ = a.y_;
//	}
//
//	int x_, y_;
//};
//
//int main()
//{
//	A a1;//调用类"A"中的默认构造函数。
//
//	A a2(a1);//直接初识化的一种形式，使用对象"a1"初始化对象"a2"，调用类"A"中的拷贝构造函数。
//
//	A a3 = a1;//复制初识化的一种形式，使用对象"a1"初始化对象"a3"，调用类"A"中的拷贝构造函数。
//
//	return 0;
//}

////拷贝构造函数示例三：按值传递和按引用传递的函数，调用拷贝构造函数的时机。
//struct Test
//{
//	int x_;
//
//	Test()
//	{
//		std::cout << "构造函数" << '\n';
//		x_ = 0;
//	}
//
//	Test(const Test& t)
//	{
//		std::cout << "拷贝构造函数" << '\n';
//		x_ = t.x_;
//	}
//};
//
//void Func1(Test x)//按值传递，复制初始化，从另一个对象初始化对象会调用拷贝构造函数。
//{
//	std::cout << "Func1()\n";//完成拷贝构造后，才会打印此句。
//}
//
//void Func2(Test& x)//按引用传递，此处并不会产生临时变量，"x"就是调用此函数传递过来的参数的别名，也就不涉及拷贝构造函数的事情。
//{
//	std::cout << "Func2()\n";//直接打印此句。
//}
//
//int main()
//{
//	Test t1, t2;//调用两次构造函数。
//
//	//分别调用按值传递的函数和按引用传递的函数
//	Func1(t1);//调用"Func1"函数。
//	Func2(t2);//调用"Func2"函数。
//
//	return 0;
//}

////拷贝构造函数示例四：编译器自动为类生成的隐式默认拷贝构造函数。
//struct A
//{
//	//构造函数
//	A()
//	{
//		x_ = y_ = 10;
//	}
//
//	int x_, y_;
//};
//
//int main()
//{
//	A a1;//调用类"A"中的默认构造函数。
//
//	A a2(a1);//此时会调用编译器自动生成的隐式默认拷贝构造函数，将对象"a1"中成员变量的值逐字节拷贝给对象"a2"的成员变量。
//
//	std::cout << "a2.x_ = " << a2.x_ << '\n' << "a2.y_ = " << a2.y_ << std::endl;//对象"a2"中的成员变量"x_"和"y_"的值都为：10。
//
//	return 0;
//}

////拷贝构造函数示例五：编译器自动为类生成的隐式默认拷贝构造函数，并且类中有指针成员变量。
//struct A
//{
//	A()
//	{
//		x_ = y_ = 10;
//		px_ = &x_;
//		py_ = &y_;
//	}
//
//	int x_, y_;
//	int* px_, * py_;
//};
//
//int main()
//{
//	A a1;
//	A a2(a1);
//
//	std::cout << "a1.x_ = " << a1.x_ << '\n'
//			  << "a1.y_ = " << a2.y_ << '\n' << std::endl;//对象"a1"中的成员变量"x_"和"y_"的值都为：10。
//
//	std::cout << "a1.px_ = " << a1.px_ << '\n'
//			  << "a1.py_ = " << a1.py_ << '\n' << std::endl;//对象"a1"中的成员变量"px_"和"py_"的值都是其成员变量"x_"和"y_"的地址。
//
//	std::cout << "a2.x_ = " << a2.x_ << '\n'
//			  << "a2.y_ = " << a2.y_ << '\n' << std::endl;//对象"a2"中的成员变量"x_"和"y_"的值都为：10。
//
//	std::cout << "a2.px_ = " << a2.px_ << '\n'
//			  << "a2.py_ = " << a2.py_ << '\n' << std::endl;//发现对象"a2"中的成员变量"px_"和"py_"的值与对象"a1"中的成员变量"px_"和"py_"的值相同。
//
//	a2.x_ = 100;
//	a2.y_ = 100;
//
//	std::cout << "a1.x_ = " << a1.x_ << '\n'
//			  << "a1.y_ = " << a1.y_ << '\n'
//			  << "a2.x_ = " << a2.x_ << '\n'
//			  << "a2.y_ = " << a2.y_ << '\n' << std::endl;//修改对象"a2"中的成员变量"x_"和"y_"的值，对象"a1"中的成员变量"x_"和"y_"的值并不会改变。
//
//	*(a2.px_) = 20;
//	*(a2.py_) = 30;
//
//	std::cout << "a1.x_ = " << a1.x_ << '\n'
//			  << "a1.y_ = " << a1.y_ << '\n'
//			  << "a2.x_ = " << a2.x_ << '\n'
//			  << "a2.y_ = " << a2.y_ << '\n' << std::endl;//发现对象"a1"的成员变量"x_"和"y_"的值被修改了，而对象"a2"的成员变量"x_"和"y_"的值没有被修改。
//
//	return 0;
//}

////拷贝构造函数示例六：编译器自动为类生成的隐式默认拷贝构造函数，并且类中有指针成员变量，且指针成员变量指向的是堆内存，造成重复释放的错误。(错误示例)
//struct A
//{
//	A()
//	{
//		x_ = 10;
//		px_ = (int*)malloc(sizeof(int) * x_);
//	}
//
//	~A()
//	{
//		free(px_);//若"free"函数的参数"ptr"所指代的内存区域已经被释放，则行为未定义。
//	}
//
//	int x_;
//	int* px_;
//};
//
//int main()
//{
//	A a1;
//	A a2(a1);
//
//	std::cout << "a1.x_ = " << a1.x_ << '\n'
//			  << "a1.y_ = " << a1.px_ << '\n'
//			  << "a2.x_ = " << a2.x_ << '\n'
//			  << "a2.y_ = " << a2.px_ << '\n' << std::endl;
//
//	return 0;//此时对象"a1"和对象"a2"的生命周期结束，会调用各自的析构函数，而析构函数中的"free"函数会分别释放堆内存，但对象"a2"中的成员变量"px_"的值与对象"a1"中的成员变量"px_"的值相同，因此会造成重复释放的错误。
//}

////拷贝构造函数示例七：关于拷贝构造函数示例六的正确示例。
//struct A
//{
//	A()
//	{
//		x_ = 10;
//		px_ = (int*)malloc(sizeof(int) * x_);
//	}
//
//	A(const A& a)
//	{
//		x_ = a.x_;
//		px_ = (int*)malloc(sizeof(int) * x_);
//		memcpy(px_, a.px_, sizeof(int) * x_);
//	}
//
//	~A()
//	{
//		free(px_);
//	}
//
//	int x_;
//	int* px_;
//};
//
//int main()
//{
//	A a1;
//	A a2(a1);
//
//	std::cout << "a1.x_ = " << a1.x_ << '\n'
//			  << "a1.px_ = " << a1.px_ << '\n'
//			  << "a2.x_ = " << a2.x_ << '\n'
//			  << "a2.px_ = " << a2.px_ << '\n' << std::endl;
//
//	return 0;
//}

/**
	运算符重载和拷贝赋值运算符
		1.运算符重载
		2.拷贝赋值运算符
		3.前后置运算符重载
		4.流提取与流插入运算符重载
		5.取地址运算符重载
*/

/***
	运算符重载：即为用户定义类型的操作数定制C++运算符，其将重载的概念扩展到运算符上，允许赋予C++运算符多重含义。
		1.实际上很多C++(包括C语言)运算符已经被重载，例如：将"*"运算符用于地址，将得到存储在该地址处的值，但将它用于两个操作数时，则是执行乘法运算。
		2.重载运算符的语法格式(重载的运算符是具有特殊的函数名的函数)：
			返回值类型 operator 运算符(形参表)
			{
				函数体
			}
		3.运算符重载的限制(不完全列举)
			a.运算符重载不能创建一个新的运算符。
			b.重载的运算符至少有一个操作数拥有类类型或枚举类型。
			c.不能重载特殊的运算符，如："::"作用域解析运算符、"."成员访问运算符、".*"成员访问运算符、"?:"三元条件运算符等。
			d.重载后的运算符的优先级、结合方向或操作数的数量不会变化。
		4.将运算符重载为类的成员函数或非成员函数。
			a.作为类的成员函数重载时，其重载的运算符的形参表中至少有一个形参是类的对象，因为其包含了隐含的"this"指针，故至少有一个形参是类的对象。
			b.作为非成员函数重载时，若要访问类中的私有成员，需要将其声明为友元函数。(友元函数将会在本章的"友元"小节中介绍)
			c.运算符重载函数要么是非静态成员函数，要么是非成员函数，并且至少有一个类型为类、对类的引用、枚举或对枚举的引用的参数。
			d.一些特殊的运算符不能作为非成员函数重载，如："="直接赋值运算符、"()"函数调用运算符、"[]"下标运算符、"->"成员访问运算符。
		5.运算符重载的形参与返回值类型
			a.当运算符重载的形参为值语义时(非引用类型)时，会发生复制初始化，即调用拷贝构造函数。
			b.当运算符重载的返回值类型为引用时，需要注意引用的对象是否会被销毁，如果会被销毁，那么返回的引用就会指向一个无效的内存地址。
		6.关于重载前的运算符和重载后的运算符
			a.重载前用于内置类型的运算符的语义和重载后用于类类型的运算符的语义是一样的，如：对于单目操作符，运算符重载函数是没有形参的，即只有一个操作数。
		7.显式调用运算符重载函数(此点将会在"前后置运算符重载"中给出示例)
			a.当运算符重载为类的成员函数时，可以直接使用运算符，编译器会自动调用，也可以显式的调用运算符重载函数，如"a + b"显式调用类中运算符重载函数：a.operator+(b)。
			b.当运算符重载为非成员函数时，同样可以直接使用，但显式的调用与成员函数不同，如"a + b"显式调用类外运算符重载函数：operator+(a, b)。
			c.调用父类的运算符重载函数情况暂时不考虑。
		8.运算符重载和函数重载的区别
			a.函数重载是具有相同名称但形参列表不同的函数，而运算符重载是对特定已存在的运算符赋予新的语义，以支持用户自定义的类型使用运算符。
			b.函数重载允许以多种方式调用，而运算符重载是允许运算符具有超出其预定义操作含义的新的含义(扩展含义)。
			c.函数重载意味着使用单个名称并赋予它更多的功能，而运算符重载意味着为某个运算符添加额外的功能，以支持用户自定义的类型。
			d.当一个函数被重载时，相同的函数名根据其签名有不同的解释，签名是函数形参列表中的参数类型列表，而当运算符被重载时，运算符具有不同的含义，取决于其操作数的类型。
		9.文档：https://zh.cppreference.com/w/cpp/language/operators。
*/

////运算符重载示例一：运算符重载作为类的成员函数重载。
//class A
//{
//public:
//	A()
//	{
//		x_ = y_ = 0;
//	}
//
//	A(int x, int y)
//	{
//		x_ = x;
//		y_ = y;
//	}
//
//	//重载运算符"+"，使其可以对两个"A"类型的对象进行相加运算。(在类体中定义)
//	A operator+(const A& a) const//此处的"const"限定符将在本章的""const"成员函数"小节介绍，此处只需知道其作用是保证该函数不会修改类的成员变量即可。
//	{
//		A temp;//一个局部的对象，当函数执行完毕后，该对象会被销毁。
//		temp.x_ = x_ + a.x_;
//		temp.y_ = y_ + a.y_;
//		return temp;//该函数的返回值为"A"类型，值返回会生成临时变量，然后将局部对象的值拷贝到临时变量中。
//	}
//
//	//重载运算符"-"，使其可以对两个"A"类型的对象进行相减运算。(在类体中声明，但在类体外定义)
//	A operator-(const A& a) const;
//
//	void print()
//	{
//		std::cout << "x_ = " << x_ << ", y_ = " << y_ << std::endl;
//	}
//
//private://注意此时的成员变量为私有的。
//	int x_, y_;
//};
//
//A A::operator-(const A& a) const//作为类的成员函数，即使在类体外定义，也可以访问类中的私有成员。
//{
//	A temp;
//	temp.x_ = x_ - a.x_;
//	temp.y_ = y_ - a.y_;
//	return temp;
//}
//
//int main()
//{
//	A a1(1, 2);
//	A a2(3, 4);
//
//	(a1 + a2).print();
//	(a1 - a2).print();
//
//	return 0;
//}

////运算符重载示例二：运算符重载作为非成员函数重载。
//class A
//{
//public:
//	A()
//	{
//		x_ = y_ = 0;
//	}
//
//	A(int x, int y)
//	{
//		x_ = x;
//		y_ = y;
//	}
//
//	void print()
//	{
//		std::cout << "x_ = " << x_ << ", y_ = " << y_ << std::endl;
//	}
//
//	int x_, y_;//注意此时的成员变量为公有的，如果将其改为私有的，那么下面的运算符重载函数就无法访问了，这种情况下，只能将运算符重载函数直接定义为类的成员函数或在类中声明为友元函数。
//};
//
////重载运算符"=="，使其可以对两个"A"类型的对象比较是否相等。
//bool operator==(const A& a, const A& b)//注意此时不会有隐含的"this"指针，因为该函数不是类的成员函数。
//{
//	return (a.x_ == b.x_) && (a.y_ == b.y_);
//}
//
//int main()
//{
//	A a1(1, 2);
//	A a2(3, 4);
//	A a3(1, 2);
//
//	std::cout << (a1 == a2) << std::endl;
//	std::cout << (a1 == a3) << std::endl;
//
//	return 0;
//}

////运算符重载示例三：创建一个"Time"类，其具有秒表类似的功能，能够对两个对象的时间进行相加和相减运算。
//class Time
//{
//public:
//	//无参构造函数(用于初始化为默认值)
//	Time()
//	{
//		hour_ = 0, minute_ = 0, second_ = 0;
//	}
//
//	//带参构造函数(用于初始化为设置的时间)
//	Time(int hour, int minute, int second)
//	{
//		hour_ = hour, minute_ = minute, second_ = second;
//	}
//
//	//添加秒数
//	void Add_Second(int second)
//	{
//		second_ += second;
//		if (second_ >= 60)
//		{
//			minute_ += second_ / 60;
//			second_ %= 60;
//		}
//		if (minute_ >= 60)
//		{
//			hour_ += minute_ / 60;
//			minute_ %= 60;
//		}
//	}
//
//	//添加分钟数
//	void Add_Minute(int minute)
//	{
//		minute_ += minute;
//		if (minute_ >= 60)
//		{
//			hour_ += minute_ / 60;
//			minute_ %= 60;
//		}
//	}
//
//	//添加小时数
//	void Add_Hour(int hour)
//	{
//		hour_ += hour;
//	}
//
//	//两个对象的时间相加(重载运算符"+")
//	Time operator+(const Time& t) const
//	{
//		Time temp;
//		temp.hour_ = hour_ + t.hour_;
//		temp.minute_ = minute_ + t.minute_;
//		temp.second_ = second_ + t.second_;
//		if (temp.second_ >= 60)
//		{
//			temp.minute_ += temp.second_ / 60;
//			temp.second_ %= 60;
//		}
//		if (temp.minute_ >= 60)
//		{
//			temp.hour_ += temp.minute_ / 60;
//			temp.minute_ %= 60;
//		}
//		return temp;
//	}
//
//	//两个对象的时间相减(重载运算符"-")
//	Time operator-(const Time& t) const
//	{
//		Time temp;
//		int total_second1 = hour_ * 3600 + minute_ * 60 + second_;
//		int total_second2 = t.hour_ * 3600 + t.minute_ * 60 + t.second_;
//		temp.second_ = total_second1 - total_second2;
//		temp.minute_ = temp.second_ / 60;
//		temp.second_ %= 60;
//		temp.hour_ = temp.minute_ / 60;
//		temp.minute_ %= 60;
//		return temp;
//	}
//
//	//重置时间
//	void Reset(int hour, int minute, int second)
//	{
//		hour_ = hour, minute_ = minute, second_ = second;
//	}
//
//	//显示时间
//	void Show() const
//	{
//		std::cout << hour_ << ":" << minute_ << ":" << second_ << std::endl;
//	}
//
//private:
//	int hour_;
//	int minute_;
//	int second_;
//};
//
//int main()
//{
//	Time cooking_time(1, 30, 0);
//	std::cout << "Cooking time = ";
//	cooking_time.Show();
//
//	Time eating_time(0, 30, 0);
//	std::cout << "Eating time = ";
//	eating_time.Show();
//
//	Time sleep_time(9, 0, 0);
//	std::cout << "Sleep time = ";
//	sleep_time.Show();
//
//	Time study_time(10, 0, 0);
//	std::cout << "Study time = ";
//	study_time.Show();
//
//	Time play_time(3, 0, 0);
//	std::cout << "Play time = ";
//	play_time.Show();
//
//	//计算一天的总时间并显示
//	Time total_time = cooking_time + eating_time + sleep_time + study_time + play_time;
//	std::cout << "Total time = ";
//	total_time.Show();
//
//	//计算学习时间和玩耍时间的差值并显示
//	Time difference_time = study_time - play_time;
//	std::cout << "Difference time = ";
//	difference_time.Show();
//
//	//计算吃饭时间和睡觉时间的差值并显示
//	difference_time = eating_time - sleep_time;
//	std::cout << "Difference time = ";
//	difference_time.Show();
//
//	return 0;
//}

/***
	拷贝赋值运算符：又称为复制赋值运算符，即将"="赋值符号进行运算符重载，是名为"operator="的非模板非静态成员函数。
		1.拷贝赋值运算符的函数常见语法格式：类名& operator=(const 类名& 标识符)。(此处是在不采用复制交换法时的典型声明(拓展))
			a.拷贝赋值运算符接收一个以类类型为参数或以类的引用类型为参数的形参。(均可由"const"和"volatile"组合修饰括号内的类名)
			b.拷贝赋值运算符的返回值类型一般是引用类型。
				a'.拷贝赋值运算符的左操作数对应着"this"指针，因其作为非静态成员函数的第一个隐式形参，并出现在第一个实际参数前。
				b'.为了支持连续赋值，拷贝赋值运算符的返回值类型一般使用引用类型，以提升效率，若是以值语义返回，产生临时对象并调用拷贝构造函数，开销大、效率低。
				c'.拷贝赋值运算符通常返回的是左操作数的引用，若是返回右操作的引用可能会出现意想不到的结果，比如：(a = b) = c，本意是让"a"被赋值为"c"，但实际上是让"b"被赋值为"c"。
			c.此小节只演示常见的拷贝赋值运算符的声明。
		2.拷贝赋值运算符的特性
			a.拷贝赋值运算符必须是一个类的非模板非静态成员函数。(暂时忽略非模板)
			b.当类没有显式定义任何拷贝赋值运算符函数时，编译器会自动为其隐式生成一个默认拷贝赋值运算符函数，而如果当类显式定义了默认拷贝赋值运算符函数时，编译器将不再为其生成。
			c.若拷贝赋值运算符在类外声明并定义，即以非成员函数的形式重载，那么会与编译器在类中隐式生成的拷贝赋值运算符发生冲突，故不能在类外声明并定义拷贝赋值运算符函数。
			d.由编译器隐式生成的拷贝赋值运算符函数是一个内联并且具有公有访问权限的成员函数。
			e.由编译器隐式生成的默认拷贝赋值运算符函数的特性与默认拷贝构造函数函数的特性相同，就不再赘述了，但需要注意的是拷贝赋值运算符函数还可能会造成内存泄漏。
			f.对于规范的拷贝赋值运算符，期待它在自我赋值时不进行操作，并按引用返回左操作数，若不避免拷贝赋值运算符函数的自我赋值，则会导致一些潜在的问题。
			g.要正确区分拷贝构造函数和拷贝赋值运算符函数，其特性相似，但是功能不同。
				a.拷贝构造函数是使用一个已存在的对象来初始化一个新对象，而拷贝赋值运算符函数是将一个已存在的对象赋值给另一个已存在的对象。
		3.文档：https://zh.cppreference.com/w/cpp/language/copy_assignment。
*/

////拷贝赋值运算符示例一：创建拷贝赋值运算符函数以及连续赋值。
//class Time
//{
//public:
//	Time(int hour, int minute, int second)
//	{
//		hour_ = hour;
//		minute_ = minute;
//		second_ = second;
//	}
//
//	void Show() const
//	{
//		std::cout << hour_ << ":" << minute_ << ":" << second_ << std::endl;
//	}
//
//	Time& operator=(const Time& time)
//	{
//		hour_ = time.hour_;
//		minute_ = time.minute_;
//		second_ = time.second_;
//		return *this;//此处返回的是解引用的"this"指针，也就是传递过来的对象本身，而返回值类型是类的引用类型，所以返回的是对象的引用，即对象的别名。
//	}
//
//private:
//	int hour_ = 0;
//	int minute_ = 0;
//	int second_ = 0;
//};
//
//int main()
//{
//	Time time1(12, 0, 0);
//	Time time2(0, 0, 0);
//	Time time3(0, 0, 0);
//
//	time2 = time1;//两个对象进行赋值，调用类中的拷贝赋值运算符函数，经过拷贝赋值运算符函数的处理，两个对象内各个成员变量的值都将相同。
//
//	std::cout << "time1 = ";
//	time1.Show();
//	std::cout << "time2 = ";
//	time2.Show();
//	std::cout << "time3 = ";
//	time3.Show();
//
//	time1 = time2 = time3;//见下面的分析：
//	//连续赋值，根据赋值运算符的结合性，先执行"time2 = time3"，再执行"time1 = time2"。
//	//执行"time2 = time3"时，调用类中的拷贝赋值运算符函数，其"this"指针指向的是"time2"对象，将两个对象处理后，将"time2"对象的引用返回。
//	//"time2 = time3"表达式的值是"time2"对象的引用，实际就是"time2"对象的别名，再将其赋值给"time1"对象，即执行"time1 = time2"。
//	//执行"time1 = time2"时，调用类中的拷贝赋值运算符函数，其"this"指针指向的是"time1"对象，将两个对象处理后，将"time1"对象的引用返回。
//	//执行完毕后，"time1"、"time2"、"time3"三个对象内各个成员变量的值都将相同。
//
//	std::cout << "\ntime1 = ";
//	time1.Show();
//	std::cout << "time2 = ";
//	time2.Show();
//	std::cout << "time3 = ";
//	time3.Show();
//
//	return 0;
//}

////拷贝赋值运算符示例二：编译器自动为类生成的隐式默认拷贝赋值运算符函数，若在类外声明并定义拷贝赋值运算符函数，编译器依旧会生成，导致冲突，此处不演示错误示例。
//class Time
//{
//public:
//	Time(int hour, int minute, int second)
//	{
//		hour_ = hour;
//		minute_ = minute;
//		second_ = second;
//	}
//
//	void Show() const
//	{
//		std::cout << hour_ << ":" << minute_ << ":" << second_ << std::endl;
//	}
//
//private:
//	int hour_ = 0;
//	int minute_ = 0;
//	int second_ = 0;
//};
//
//int main()
//{
//	Time time1(12, 0, 0);
//	Time time2(0, 0, 0);
//	Time time3(0, 0, 0);
//
//	time2 = time1;//此处调用的是由编译器自动生成的隐式默认拷贝赋值运算符函数，将"time1"对象的各个成员变量的值赋值给"time2"对象的各个成员变量。
//
//	std::cout << "time1 = ";
//	time1.Show();
//	std::cout << "time2 = ";
//	time2.Show();
//	std::cout << "time3 = ";
//	time3.Show();
//
//	time1 = time2 = time3;//由编译器自动生成的隐式默认拷贝赋值运算符函数也支持连续赋值。
//
//	std::cout << "\ntime1 = ";
//	time1.Show();
//	std::cout << "time2 = ";
//	time2.Show();
//	std::cout << "time3 = ";
//	time3.Show();
//
//	return 0;
//}

////拷贝赋值运算符示例三：区分拷贝构造函数和拷贝赋值运算符函数。
//class Time
//{
//public:
//	Time(int hour, int minute, int second)
//	{
//		hour_ = hour;
//		minute_ = minute;
//		second_ = second;
//	}
//
//	void Show() const
//	{
//		std::cout << hour_ << ":" << minute_ << ":" << second_ << std::endl;
//	}
//
//	//拷贝构造函数
//	Time(const Time& time)
//	{
//		hour_ = time.hour_;
//		minute_ = time.minute_;
//		second_ = time.second_;
//		std::cout << "拷贝构造函数被调用" << std::endl;
//	}
//
//	//拷贝赋值运算符函数
//	Time& operator=(const Time& time)
//	{
//		hour_ = time.hour_;
//		minute_ = time.minute_;
//		second_ = time.second_;
//		std::cout << "拷贝赋值运算符函数被调用" << std::endl;
//		return *this;
//	}
//
//private:
//	int hour_ = 0;
//	int minute_ = 0;
//	int second_ = 0;
//};
//
//int main()
//{
//	Time time1(12, 0, 0);
//	Time time2(0, 0, 0);
//	Time time3 = time1;//此处调用的是拷贝构造函数，将"time1"对象的各个成员变量的值赋值给"time3"对象的各个成员变量。
//
//	std::cout << "time1 = ";
//	time1.Show();
//	std::cout << "time2 = ";
//	time2.Show();
//	std::cout << "time3 = ";
//	time3.Show();
//
//	time2 = time1;//此处调用的是拷贝赋值运算符函数，将"time1"对象的各个成员变量的值赋值给"time2"对象的各个成员变量。
//
//	std::cout << "time1 = ";
//	time1.Show();
//	std::cout << "time2 = ";
//	time2.Show();
//	std::cout << "time3 = ";
//	time3.Show();
//
//	return 0;
//}

////拷贝赋值运算符示例四：编译器自动为类生成的隐式默认拷贝赋值运算符函数，并且类中有指针成员变量，且指针成员变量指向的是堆内存，造成重复释放和内存泄漏的错误。(错误示例)
//struct A
//{
//	A()
//	{
//		x_ = 10;
//		px_ = (int*)malloc(sizeof(int) * x_);
//		for (int i = 0; i < x_; i++)
//		{
//			px_[i] = i;
//		}
//	}
//
//	~A()
//	{
//		free(px_);
//	}
//
//	int x_;
//	int* px_;
//};
//
//int main()
//{
//	A a1, a2;//调用构造函数，并为每个对象的"px_"成员变量分配了堆内存。
//
//	int* tmp = a2.px_;//记录"a2"对象的"px_"成员变量的值。
//
//	//打印各个对象中"px_"成员变量和"tmp"指针的值。
//	std::cout << "a1.px_ = " << a1.px_ << '\n'
//			  << "a2.px_ = " << a2.px_ << '\n'
//			  << "tmp = " << tmp << '\n' << std::endl;
//
//	//打印"a1"对象中"px_"成员变量指向的堆内存中的值。
//	for (int i = 0; i < a1.x_; i++)
//	{
//		std::cout << "a1.px_[" << i << "] = " << a1.px_[i] << '\n';
//	}
//	std::cout << std::endl;
//
//	//打印"a3"对象中"px_"成员变量指向的堆内存中的值。
//	for (int i = 0; i < a2.x_; i++)
//	{
//		std::cout << "a2.px_[" << i << "] = " << a2.px_[i] << '\n';
//	}
//	std::cout << std::endl;
//
//	a2 = a1;//见下面的分析：
//	//调用由编译器生成的默认拷贝赋值运算符函数，将"a1"对象的各个成员变量的值赋值给"a2"对象的各个成员变量。
//	//"a1"对象中"px_"成员变量的值被直接赋值给"a2"对象中"px_"成员变量，即"a2"对象中"px_"成员变量指向的是"a1"对象中"px_"成员变量指向的堆内存(浅拷贝)。
//	//但"a1"对象中"px_"成员变量指向的堆内存并没有被释放，造成内存泄漏的错误。
//
//	//打印"tmp"指向的堆内存中的值，发现依旧是"a2"对象中"px_"成员变量指向的堆内存中的值，并没有被释放。
//	for (int i = 0; i < a2.x_; ++i)
//	{
//		std::cout << "tmp[" << i << "] = " << tmp[i] << '\n';
//	}
//	std::cout << std::endl;
//
//	//打印各个对象中"px_"成员变量和"tmp"指针的值，发现"a2"对象中"px_"成员变量的值被改变为了"a1"对象中"px_"成员变量的值。
//	std::cout << "a1.px_ = " << a1.px_ << '\n'
//			  << "a2.px_ = " << a2.px_ << '\n'
//			  << "tmp = " << tmp << '\n' << std::endl;
//
//	return 0;//此时对象"a1"和对象"a2"的生命周期结束，调用各自的析构函数，释放"a1"对象和"a2"中"px_"成员变量指向的堆内存，导致堆内存被释放两次，造成重复释放的错误，导致程序崩溃。
//}

////拷贝赋值运算符示例五：关于拷贝赋值运算符示例四的正确示例。
//struct A
//{
//	A()
//	{
//		x_ = 10;
//		px_ = (int*)malloc(sizeof(int) * x_);
//		for (int i = 0; i < x_; i++)
//		{
//			px_[i] = i;
//		}
//	}
//
//	A& operator=(const A& a)
//	{
//		free(px_);
//		std::cout << px_ << std::endl;
//		x_ = a.x_;
//		px_ = (int*)malloc(sizeof(int) * x_);
//		memcpy(px_, a.px_, sizeof(int) * x_);
//		return *this;
//	}
//
//	~A()
//	{
//		free(px_);
//	}
//
//	int x_;
//	int* px_;
//};
//
//int main()
//{
//	A a1, a2;
//
//	std::cout << "a1.px_ = " << a1.px_ << '\n'
//			  << "a2.px_ = " << a2.px_ << std::endl;
//
//	for (int i = 0; i < a1.x_; i++)
//	{
//		std::cout << "a1.px_[" << i << "] = " << a1.px_[i] << '\n';
//	}
//	std::cout << std::endl;
//
//	for (int i = 0; i < a2.x_; i++)
//	{
//		std::cout << "a2.px_[" << i << "] = " << a2.px_[i] << '\n';
//	}
//	std::cout << std::endl;
//
//	a2 = a1;
//
//	std::cout << "a1.px_ = " << a1.px_ << '\n'
//			  << "a2.px_ = " << a2.px_ << std::endl;
//
//	return 0;
//}

////拷贝赋值运算符示例六：拷贝赋值运算符的自赋值问题。
//class Array
//{
//private:
//	int* ptr_;
//	int size_;
//public:
//	Array(int size)
//	{
//		size_ = size;
//		ptr_ = (int*)malloc(sizeof(int) * size_);
//		for (int i = 0; i < size_; i++)
//		{
//			ptr_[i] = i;
//		}
//	}
//
//	Array& operator=(const Array& rhs)
//	{
//		//释放当前对象中的堆内存
//		free(ptr_);
//
//		//重新分配堆内存
//		ptr_ = (int*)malloc(sizeof(int) * rhs.size_);
//
//		//拷贝数据
//		size_ = rhs.size_;
//		for (int i = 0; i < size_; i++)
//			ptr_[i] = rhs.ptr_[i];
//
//		return *this;
//	}
//
//	void print()
//	{
//		for (int i = 0; i < size_; i++)
//		{
//			std::cout << "ptr_[" << i << "] = " << ptr_[i] << '\n';
//		}
//		std::cout << std::endl;
//	}
//};
//
//int main()
//{
//	Array a1(10);
//
//	a1.print();
//
//	a1 = a1;//出现自我赋值的情况，调用拷贝赋值运算符函数，直接把"a1"对象中"ptr_"指针指向的堆内存给释放了，后续的拷贝数据属于未定义行为。
//
//	a1.print();//此时"a1"对象中的"ptr_"指针指向的堆内存已经被释放，再进行访问则是未定义行为。
//
//	return 0;
//}

////拷贝赋值运算符示例七：关于拷贝赋值运算符示例六的正确示例。
//class Array
//{
//private:
//	int* ptr_;
//	int size_;
//public:
//	Array(int size)
//	{
//		size_ = size;
//		ptr_ = (int*)malloc(sizeof(int) * size_);
//		for (int i = 0; i < size_; i++)
//		{
//			ptr_[i] = i;
//		}
//	}
//
//	Array& operator=(const Array& rhs)
//	{
//		//防止自我赋值
//		if (this == &rhs)
//			return *this;
//
//		//释放当前对象中的堆内存
//		free(ptr_);
//
//		//重新分配堆内存
//		ptr_ = (int*)malloc(sizeof(int) * rhs.size_);
//
//		//拷贝数据
//		size_ = rhs.size_;
//		for (int i = 0; i < size_; i++)
//			ptr_[i] = rhs.ptr_[i];
//
//		return *this;
//	}
//
//	void print()
//	{
//		for (int i = 0; i < size_; i++)
//		{
//			std::cout << "ptr_[" << i << "] = " << ptr_[i] << '\n';
//		}
//		std::cout << std::endl;
//	}
//};
//
//int main()
//{
//	Array a1(10);
//
//	a1.print();
//
//	a1 = a1;
//
//	a1.print();
//
//	return 0;
//}

////拷贝赋值运算符示例八：拷贝赋值运算符与拷贝构造函数结合示例。(编译器可能会进行优化，此示例将会在后续再次进行讲解，当前应区分拷贝构造函数与拷贝赋值运算符的区别)
//struct Test
//{
//	int x_;
//
//	Test()
//	{
//		std::cout << "构造函数" << '\n';
//		x_ = 0;
//	}
//
//	Test(const Test& t)
//	{
//		std::cout << "拷贝构造函数" << '\n';
//		x_ = t.x_;
//	}
//
//	Test& operator=(const Test& t)
//	{
//		std::cout << "拷贝赋值运算符函数" << '\n';
//		x_ = t.x_;
//		std::cout << "this = " << this << '\n';
//		return *this;
//	}
//};
//
//void Func1(Test x)//按值传递，从另一个对象初始化对象会调用拷贝构造函数，调用拷贝构造函数。
//{
//	std::cout << "Func1\n";//完成拷贝构造后，才会打印此句。
//}
//
//void Func2(Test& x)//按引用传递，"x"就是调用此函数传递过来的参数的别名，也就不涉及拷贝构造函数的事情。
//{
//	std::cout << "Func2\n";//直接打印此句。
//}
//
//Test Func3(Test& x)
//{
//	std::cout << "Func3\n";//直接打印此句。
//	Test tmp;//此处会调用构造函数。
//	return tmp;//以值的形式返回。
//}
//
//Test& Func4(Test& x)
//{
//	std::cout << "Func4\n";//直接打印此句。
//	return x;//"x"是一个对象的引用，即对象的别名，此处返回值类型是类的引用类型，返回"x"十分合理。
//}
//
//////错误的"Func4"函数
////Test& Func4()
////{
////	std::cout << "Func4\n";//直接打印此句。
////	Test tmp;//此处会调用构造函数。
////	return tmp;//编译器会报警告或错误，因为此时的"tmp"对象是个局部对象，这个对象在离开此函数会被销毁，返回的引用就会指向一个无效的内存地址。
////}
//
//int main()
//{
//	Test t1, t2, t3, t4;//调用四次构造函数。
//
//	std::cout << "----------------" << std::endl;
//
//	//分别调用按值传递的函数和按引用传递的函数
//	Func1(t1);//调用"Func1"函数，调用拷贝构造函数。
//	Func2(t2);//调用"Func2"函数，不会调用拷贝构造函数。
//
//	std::cout << "----------------" << std::endl;
//
//	//分别调用以值语义返回的函数和以引用返回的函数
//	Func3(t3);//调用"Func3"函数，以值语义返回会产生中间值临时对象，临时对象的初始化会调用拷贝构造函数。(编译器可能会进行优化)
//	Func4(t4);//调用"Func4"函数，引用返回不会产生中间值临时对象，故不会调用拷贝构造函数。
//
//	std::cout << "----------------" << std::endl;
//
//	//调用"Func3"函数和"Func4"函数，并以其返回值初始化对象。
//	Test t5 = Func3(t3);//调用"Func3"函数，完成后将其返回值用来进行复制初始化，调用拷贝构造函数。(编译器可能会进行优化)
//	Test t6 = Func4(t3);//调用"Func4"函数，此处返回的是"t3"对象的引用，实际就是"t3"对象的别名，再以其初始化"t6"对象，将调用拷贝构造函数。
//
//	std::cout << "----------------" << std::endl;
//
//	//探究拷贝赋值运算符函数中的"this"指针是否是左操作数的地址。
//	std::cout << "&t1 = " << &t1 << '\n';
//	t1 = t4;//调用拷贝赋值运算符函数。
//	std::cout << "&t2 = " << &t2 << '\n';
//	t2 = t4;//调用拷贝赋值运算符函数。
//	//可以发现"this"指针指向的就是拷贝赋值运算符的左操作数的地址。
//
//	std::cout << "----------------" << std::endl;
//
//	//调用"Func3"函数和"Func4"函数，并以其返回值赋值给已存在的对象。
//	t1 = Func3(t3);//调用"Func3"函数，完成后将其返回值用来进行赋值，调用拷贝赋值运算符函数。(编译器可能会进行优化("tmp"可能会被直接返回，而不是返回临时对象))
//	t2 = Func4(t3);//调用"Func4"函数，此处返回的是"t3"对象的引用，实际就是"t3"对象的别名，再以其赋值给"t2"对象，将调用拷贝赋值运算符函数。
//
//	std::cout << "----------------" << std::endl;
//
//	//连续赋值，通过改动拷贝赋值运算符函数的形参列表以及返回值类型，观察程序运行的变化。
//	t1 = t2 = t3 = t4;
//
//	std::cout << "----------------" << std::endl;
//
//	return 0;
//}

/***
	前后置运算符重载：前后置运算符分为前置自增、前置自减、后置自增和后置自减，它们都可被重载，并且后置的自增与自减运算符优先级高于前置的自增与自减运算符。
		1.内置类型的前后置运算符
			a.对于内置类型来说，内建运算符的前置版本返回引用，而后置版本返回值。
				a'.前置自增与前置自减运算符：增加或减小对象的值，并返回到其结果的引用。
				b'.后置自增与后置自减：创建对象的副本，增加或减小对象的值，并返回自增或自减前的副本。
			b.内建前后置运算符的操作数(表达式)必须是算术类型或是指向完整定义的对象类型的指针类型，并且是可修改左值(非"const"修饰)。
			c.表达式"++x"严格等价于"x += 1"，而表达式"--x"严格等价于"x -= 1"。
			d.表达式"x++"对于如同"x += 1"一般修改其操作数的值，而表达式"x--"如同"x -= 1"一般修改其操作数的值，但结果是操作数原值的纯右值副本(不可修改)(副作用)。
			e.所有针对算术运算符定义的算术转换规则和指针算术规则都适用于前后置运算符，并由此确定表达式的返回类型和是否发生应用到操作数的隐式转换。
			f.不同标准下的前后置运算符的改动(拓展)
				a'.C++17前：可对"bool"类型进行自增运算(不能自减)，即如果自增运算符(包括前置和后置)的操作数为"bool"类型，则它被设为"true"(不涉及上述的"x += 1")。(C++17起弃用)
				b'.C++17起：内建前置自增或自减运算符的操作数表达式必须是非布尔类型的算术类型。
				c'.C++20起：以"volatile"限定符修饰的非类类型左值为这些运算符的内建版本的操作数是被弃用的。
		2.自定义类型的前后置运算符：即用户定义重载的前后置运算符。
			a.对于用户定义重载的前后置运算符，一般遵循内置类型的返回模式，从而使用户定义的前后置运算符可以与内建版本以相同的方式使用。(用户定义能以任何类型为返回类型(包括"void"类型))
			b.定义重载时，如何区分运算符的前置和后置版本？
				a'."int"形参是用于区别运算符的前置和后置版本的空设形参，也被称为占位形参，其值不会被使用，若使用了此占位形参，则表示定义的是后置版本的运算符。
				b'.在调用用户定义的后置运算符时，该形参中传递的值始终为零，但是你也可以显式的调用它并改动传递的值，比如：关于"a"对象的"a.operator++(2)"或"operator++(a, 2)"。
				c'.添加了"int"形参占位形参，就构成了函数重载，编译器就能够区分前置和后置版本的运算符。
		3.文档：https://zh.cppreference.com/w/cpp/language/operator_incdec。
*/

////前后置运算符重载示例一：内置类型的前后置运算符。
//int main()
//{
//	int n1 = 1;
//	int n2 = ++n1;
//	int n3 = ++ ++n1;
//	int n4 = n1++;
//	//int n5 = n1++ ++;//错误：表达式不可被赋值。
//	//int n6 = n1 + ++n1;//未定义行为。
//	std::cout << "n1 = " << n1 << '\n'
//			  << "n2 = " << n2 << '\n'
//			  << "n3 = " << n3 << '\n'
//			  << "n4 = " << n4 << '\n';
//}

////前后置运算符重载示例二：自定义类型的前后置运算符。
//class Test
//{
//public:
//	Test(int i = 0)
//	{
//		m_i = i;
//	}
//
//	//前置自增运算符重载。
//	Test& operator++()//隐含的"this"指针。
//	{
//		m_i += 1;
//		return *this;
//	}
//
//	//后置自增运算符重载。
//	Test operator++(int)//形参列表中的"int"形参是用于区别运算符的前置和后置版本的空设形参，也被称为占位形参，其值不会被使用。
//	{
//		Test temp = *this;
//		m_i += 1;
//		return temp;
//	}
//
//	int m_i;
//};
//
////前置自减运算符重载。
//Test& operator--(Test& t)//此函数不属于类的成员函数，因此需要显式把要传递的对象作为参数。
//{
//	t.m_i -= 1;//若"Test"类中的"m_i"成员变量是私有的，则需要将此函数声明为"Test"类的友元函数或直接定义为类的成员函数。
//	return t;
//}
//
////后置自减运算符重载。
//Test operator--(Test& t, int)
//{
//	Test tmp(t);
//	t.m_i -= 1;
//	return tmp;
//}
//
//int main()
//{
//	Test t1;
//
//	//使用前后置运算符，将返回的值用于初识化另一个对象。
//	Test t2 = ++t1;
//	Test t3 = t1++;
//	Test t4 = --t1;
//	Test t5 = t1--;
//
//	//打印结果
//	std::cout << "t1.m_i = " << t1.m_i << '\n'
//			  << "t2.m_i = " << t2.m_i << '\n'
//			  << "t3.m_i = " << t3.m_i << '\n'
//			  << "t4.m_i = " << t4.m_i << '\n'
//			  << "t5.m_i = " << t5.m_i << '\n' << std::endl;
//
//	//显式调用类中的前置自增运算符
//	std::cout << "t1.m_i = " << t1.m_i << '\n'
//			  << "t1.operator++().m_i = " << t1.operator++().m_i << '\n'
//			  << "t1.m_i = " << t1.m_i << '\n'
//			  << std::endl;//"t1.operator++().m_i"等价于"++t1"，因其并没有传递"int"形参，所以是前置自增运算符。
//
//	//显式调用类中的后置自增运算符
//	std::cout << "t1.m_i = " << t1.m_i << '\n'
//			  << "t1.operator++(2).m_i = " << t1.operator++(2).m_i << '\n'
//			  << "t1.m_i = " << t1.m_i << '\n'
//			  << std::endl;//"t1.operator++(2).m_i"等价于"t1++"，其中"2"作为实参传递给了占位形参"int"，并且传递任何值都不会影响运算结果，因其值不会被使用。
//
//	//显式调用类外的前置自减运算符
//	std::cout << "t1.m_i = " << t1.m_i << '\n'
//			  << "operator--(t1).m_i = " << operator--(t1).m_i << '\n'
//			  << "t1.m_i = " << t1.m_i << '\n'
//			  << std::endl;//"operator--(t1).m_i"等价于"--t1"，因其并没有传递"int"形参，所以是前置自减运算符。
//
//	//显式调用类外的后置自减运算符
//	std::cout << "t1.m_i = " << t1.m_i << '\n'
//			  << "operator--(t1, 2).m_i = " << operator--(t1, 2).m_i << '\n'
//			  << "t1.m_i = " << t1.m_i << '\n'
//			  << std::endl;//"operator--(t1, 2).m_i"等价于"t1--"。
//
//	return 0;
//}

/***
	流提取与流插入运算符重载
		1."std::cin"和"std::cout"：存在于"iostream"头文件中的两个全局对象，分别用于从标准输入设备读取数据和向标准输出设备输出数据。
			a.头文件"iostream"中包含了"istream"和"ostream"头文件，其中分别定义了"std::istream"和"std::ostream"类。
			b."std::cin"和"std::cout"在头文件"iostream"中被声明(由"extern")，是由"std::istream"和"std::ostream"类创建的两个全局对象。
		2.">>"流提取运算符和"<<"流插入运算符
			a.标准库中，移位运算符通常会因"I/O"流而重载，以其作为左运算数和返回类型，这种运算符被称为流提取和流插入运算符。
			b.流提取运算符">>"：从输入流提取值，指从标准输入流(键盘)中提取值，将其依次赋值给符号右侧的操作数(左至右)。
			c.流插入运算符"<<"：插入数据到流，指将数据插入到标准输出流(控制台)中，将符号右侧的操作数(左至右)依次插入到输出流中。
			d.标准库通过函数重载与运算符重载，将移位操作符运算符重载为流提取和流插入运算符，再通过函数重载使其支持内置类型。
		3.重载">>"流提取运算符和"<<"流插入运算符，使其支持用户自定义类型。
			a.规定将"std::istream&"或"std::ostream&"类分别作为"operator>>"与"operator<<"函数的左侧形参与返回值类型，将用户定义的类型作为右侧形参。
			b.根据"a."中的规定，重载"operator>>"与"operator<<"函数需为非成员函数，因"this"指针总是作为非静态成员函数的第一个隐式形参，否则不符合使用习惯。
				a'.当流提取与流插入运算符重载函数被定义成非成员函数时，其第一个形参需为"std::istream&"或"std::ostream&"类的引用，否则不符合使用习惯。
				b'.当流提取与流插入运算符重载函数被定义成非成员函数时，若要访问类中的私有成员，需将其声明为此类的友元函数，或将类中的私有成员声明为公有成员(会使封装性变得无意义)，或在类中定义一个公有成员函数从而访问。
			c.">>"流提取运算符和"<<"流插入运算符的重载的常见函数原型：
				std::istream& operator>>(std::istream& in, 类名& obj);
				std::ostream& operator<<(std::ostream& out, const 类名& obj);
			d.当把流提取与流插入运算符重载函数定义在头文件中时(这也不仅仅是此函数的问题，只要是在头文件中定义的全局变量或全局函数都会出现此问题)，可能会出现重复定义的错误，因为头文件在多处源文件中包含，导致链接错误。
				a.第一种常用解决方法：将全局函数或全局变量定义在源文件中，而不是头文件中，即声明和定义分离。
				b.第二种非主流解决方法：由C语言继承而来，加上"static"关键词，使得此函数或变量只在当前源文件中可见，而不会在其他源文件中可见，即将外部链接改为内部链接，并且其具有静态或线程存储期。
				c.第三种小妙招解决方法：加上"inline"关键词，使带外部连接的"inline"函数或变量(C++17起才具有内联变量)(例如不声明为 "static")拥有额外属性。
					a'.使得此函数或变量在程序中可以有多于一次定义，只要每个定义都出现在不同翻译单元中(对于非静态的内联函数和变量(C++17起)且所有定义等同即可。
					b'.它必须在每个翻译单元中都被声明为"inline"。
					c'.它在每个翻译单元中都拥有相同的地址。
				d.第四种不常用解决方法：使用匿名命名空间解决，类似于"static"关键词的解决方案，即将全局变量或全局函数放在匿名命名空间中，使得每个文件都有自己的一份定义，而不会出现重复定义的错误。
					a'.C++11前：匿名命名空间中的名字可以声明为具有外部连接，但从其他的翻译单元无法访问它们，因为它的命名空间名是自己独有的。
					b'.C++11起：匿名空间以及在匿名空间内直接或间接声明的所有命名空间都具有内部链接，这意味着在匿名空间内声明的任何名称都具有内部链接。
*/

////流提取与流插入运算符重载示例：重载"operator>>"与"operator<<"函数，使其支持用户自定义类型。
//class MyClass
//{
//public:
//	//构造函数
//	MyClass(int i = 0, int j = 0)
//	{
//		i_ = i;
//		j_ = j;
//	}
//
//	//友元函数的声明：注意此处的友元声明并不是代表着此函数是此类的成员函数，而是代表着此函数可以访问此类的私有成员，将在本章的"友元"小节进行详细介绍。
//	friend std::ostream& operator<<(std::ostream& out, const MyClass& obj);//将"<<"流插入运算符重载函数声明为此类的友元函数。
//
//	friend std::istream& operator>>(std::istream& in, MyClass& obj);//将">>"流提取运算符重载函数声明为此类的友元函数。
//
//private:
//	int i_;
//	int j_;
//};
//
////流提取运算符重载函数的定义
//std::ostream& operator<<(std::ostream& out, const MyClass& obj)//此处"out"是"std::ostream"类的对象的引用，而"obj"是"MyClass"类的对象的常引用。
//{
//	//方式一
//	out << obj.i_ << " " << obj.j_;//将"obj"中的私有成员"i_"与"j_"从左至右依次插入到"out"中，也就是依次在标准输出流(控制台)中显示。
//	return out;//返回引用"out"，以便于连续使用流插入运算符。
//
//	////方式二
//	//return out << obj.i_ << " " << obj.j_ << std::endl;
//}
//
////流插入运算符重载函数的定义
//std::istream& operator>>(std::istream& in, MyClass& obj)//此处"in"是"std::istream"类的对象的引用，而"obj"是"MyClass"类的对象的引用。
//{
//	//方式一
//	in >> obj.i_ >> obj.j_;//将"obj"中的私有成员"i_"与"j_"从左至右依次从"in"中提取出来，也就是依次从标准输入流(键盘)中提取出来并赋值。
//	return in;//返回引用"in"，以便于连续使用流提取运算符。
//
//	////方式二
//	//return in >> obj.i_ >> obj.j_;//原理是一样的，返回的依旧是引用"in"。
//}
//
//int main()
//{
//	MyClass obj;
//	std::cout << "请输入两个整数：" << std::endl;
//	std::cin >> obj;
//	std::cout << "您输入的两个整数是：" << std::endl;
//	std::cout << obj << std::endl;
//	return 0;
//}

/***
	取地址运算符重载：即将一元运算符"&"取地址运算符进行重载，其可被区分为是否被"const"限定符限定非静态成员函数两种，较为罕见。
		1."operator&"重载函数的一些用法
			a.在微软的"CComPtrBase"类(智能指针类)中，具有声明：T** operator&() throw();。
				a'.原有的取地址运算符"&"的功能是返回一个指向对象的指针，而重载后的取地址运算符"&"的功能是返回"CComPtrBase"类的对象指向的对象的地址。
			b."Boost.Spirit"是第三方"Boost"库中一个用于C++的文本格式解析器和输出生成的库，它将取地址运算符重载定义为适用于自己的语义。
				a'.相关资料：https://www.boost.org/doc/libs/1_80_0/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html。
				b'.简而言之，其库中的"&"符号与取地址没有任何关系。
			c.取出对象地址时返回"nullptr"，具有不允许取出此类对象地址的语义。
		2.重载此运算符是十分危险的行为！
*/

////取地址运算符重载示例
//class Test
//{
//public:
//	Test(int i = 0)
//	{
//		i_ = i;
//	}
//
//	int* operator&() const
//	{
//		return nullptr;//取出对象地址时返回"nullptr"，具有不允许取出此类对象地址的语义。
//	}
//
//private:
//	int i_;
//};
//
//int main()
//{
//	Test obj(10);
//
//	int* p = &obj;
//
//	std::cout << (p == nullptr) << std::endl;
//
//	//std::cout << *p << std::endl;//错误，取出的地址是"nullptr"，所以不能解引用。
//
//	return 0;
//}

/**
	"const"成员函数：由"const"限定的成员函数，属于非静态成员函数中的一类。(构造函数、析构函数和转换函数的声明语法是特殊的，以下规则可能不适用于这些函数)
		1.概念
			a.非静态成员函数可以带有"cv"限定符序列(由"const"和"volatile"进行组合产生的四种序列)声明，这些限定符在函数声明中的形参列表之后出现。
			b.带有不同"cv"限定符(或无限定)的函数具有不同类型，从而可以相互重载。
			c.在具有"cv"限定符的函数体内，"this"指针具有同样的限定符，其限定符修饰的是"*this"，即限定"this"指针的指向的内容，如：非静态成员函数带有"const"限定符序列，则表示"this"指针指向的内容不能被修改。
			d.和常引用一样，同样涉及权限相关问题：在指针和引用赋值中，权限可以缩小或平移，但是不能放大。(因非静态成员函数具有"this"指针)
			e.如果在具有"const"限定符的成员函数中，只能正常地调用其他有"const"限定符的成员函数，而不能调用没有"const"限定符的成员函数，也就是曾说的权限问题，但它是可以被绕过的。
			f.绕过具有"const"限定符的成员函数调用无const"限定符的成员函数的权限问题(拓展)
				a'.在具有"const"限定符的成员函数中，可以调用没有"const"限定符的成员函数，但是必须通过"const_cast"进行"cv"限定的类型转换，如：const_cast<MyClass*>(this)->func();。(但这个对象不能是"const"对象)
				b'.在具有"const"限定符的成员函数中，可以调用没有"const"限定符的成员函数，但是必须不涉及"this"指针的访问路径。
*/

////"const"成员函数示例一：创建"const"成员函数和非"const"成员函数，并体现对象调用成员函数的权限问题。
//class MyClass
//{
//public:
//	MyClass(int i = 0, int j = 0)
//	{
//		i_ = i;
//		j_ = j;
//	}
//
//	//无"const"限定符的成员函数(若注释此函数，则同样正常运行)
//	void func()//此处隐含的"this"指针为：MyClass* const this，其"this"指针内的内容可以被修改，但是"this"指针的指向不能被修改。
//	{
//		std::cout << "func()" << std::endl;
//		this->i_ = 100;//"this"指针指向的内容可以被修改。
//		//this = nullptr;//错误，"this"指针的指向不能被修改。
//	}
//
//	//带有"const"限定符的成员函数(若注释此函数，则"main"函数中的"obj2.func()"会报错)
//	void func() const//此处隐含的"this"指针为：const MyClass* const this，其"this"指针内的内容和"this"指针的指向都不能被修改。
//	{
//		std::cout << "func() const" << std::endl;
//		//this->i_ = 100;//错误，"this"指针指向的内容不能被修改。
//		//this = nullptr;//错误，"this"指针的指向不能被修改。
//	}
//
//private:
//	int i_;
//	int j_;
//};
//
//int main()
//{
//	MyClass obj1;
//	const MyClass obj2(1, 2);
//
//	obj1.func();//此处调用的是无"const"限定符修饰的"func"函数，它也可以调用有"const"限定符修饰的"func"函数，因为权限可以被缩小或平移。
//	obj2.func();//此处调用的是有"const"限定符修饰的"func"函数，但它不可以调用没有"const"限定符修饰的"func"函数，因为权限不能被放大。
//
//	return 0;
//}

////"const"成员函数示例二：绕过具有"const"限定符的成员函数调用无const"限定符的成员函数的权限问题。(拓展)
//struct type
//{
//	int i = 0;
//
//	//无"const"限定符的成员函数
//	void test()
//	{
//		std::cout << "\ntest()\n" << std::endl;
//	}
//
//	//通过"const_cast"关键词绕过具有"const"限定符的成员函数无法调用没有"const"限定符的成员函数的限制
//	void f1(int v) const
//	{
//		//this->i = v;//错误：无法分配给"const"成员函数"f"中的非静态数据成员。
//		const_cast<type*>(this)->i = v;//只要该对象不是"const"对象，就可以通过"const_cast"将"this"指针转换为非"const"指针，从而绕过"const"限定符的限制。
//		const_cast<type*>(this)->test();
//	}
//
//	//通过不涉及"this"指针的访问路径绕过具有"const"限定符的成员函数无法调用没有"const"限定符的成员函数的限制
//	void f2(type& t_other) const
//	{
//		t_other.test();//并不涉及"this"指针，因此不受"const"限定符的限制，可以调用没有"const"限定符的成员函数。
//	}
//};
//
//int main()
//{
//	//"const_cast"的一个简单示例
//	int i = 0;
//	const int& rci = i;
//	const_cast<int&>(rci) = 5;//"const_cast"可以将"const"引用转换为非"const"引用，从而绕过"const"限定符的限制。
//	std::cout << "i = " << i << '\n';//输出：i = 5。
//
//	//绕过具有"const"限定符的成员函数无法赋值的限制
//	type t;
//	t.f1(10);//如果"t"对象的类型为"const type"，那么此处是未定义行为。
//	std::cout << "t.i = " << t.i << '\n';//输出：t.i = 10。
//
//	//通过"const_cast"关键词绕过具有"const"限定符的成员函数无法调用没有"const"限定符的成员函数的限制
//	const type ct1;
//	ct1.f1(20);
//	std::cout << "ct.i = " << ct1.i << '\n';//输出：ct1.i = 20。
//
//	//通过不涉及"this"指针的访问路径绕过具有"const"限定符的成员函数无法调用没有"const"限定符的成员函数的限制
//	type ct2;
//	type ct3;
//	ct2.f2(ct3);
//}

/**
	再谈构造函数
		1.成员初始化器列表
		2."explicit"关键词
		3.委托构造函数(C++11)(拓展)
*/

/***
	成员初始化器列表：在类的构造函数定义中，成员初始化器列表指定各个直接基类、虚基类和非静态数据成员的初始化器。(暂不考虑基类和虚基类)
		1.任何构造函数的函数定义的函数体可以在花括号之前包含成员初始化器列表，其语法是冒号字符后随一个或多个"成员初始化器"的逗号字符分隔列表，其中每个成员名称后随由括号括起来的表达式或初始值。
		2.典型的带有成员初始化器列表的构造函数语法形式是：类名(形参列表(可选)) : 成员初始化器列表 { 函数体 }。
			a.其中成员初始化器的典型语法是：类或标识符(表达式列表(可选))。(成员初始化器列表中的成员初始化器的语法形式)
				a'.此典型语法表明了使用直接初始化，或当表达式列表为空时使用值初始化，从而初始化类或标识符所指名的成员。
				b'.值初识化详细文档参见：https://zh.cppreference.com/w/cpp/language/value_initialization。
				c'.类或标识符表示任何指名非静态数据成员的标识符，或任何指名该类自身(对于委托构造函数)、直接基类或虚基类的类型名。(仅理解非静态数据成员即可)
				d'.表达式列表表示作为给成员的参数的逗号分隔列表，可以为空(某些情况下不能为空)。(你可能会疑惑为什么还是以逗号分隔的列表，想想如果此类的成员包含另一个类的成员变量该如何使用成员初始化器)
		3.在构造函数的函数体中，给成员变量赋值的操作并不能称之将成员变量初始化，其目的只是给成员变量赋值，并且其能够多次赋值，而初始化过程实际上只能进行一次(即初始化只能初始化一次)，即每个成员仅能在成员初始化器列表中出现一次。
		4.在开始执行组成构造函数体的复合语句之前，所有非静态数据成员的初始化均已结束，也代表着函数体中仅仅是对成员变量的赋值操作。
		5.引用成员不能绑定到成员初始化器列表中的临时量，假如"v"为一个引用成员，则"v(0)"是非法的。
		6.初始化顺序(简要)：以类中成员的声明顺序，初始化各个非静态成员，然后执行构造函数体。(列表中的成员初始化器的顺序是不相关的)
		7.如果调用的构造函数中没有成员初始化器列表，或者没有指出某个非静态成员变量的成员初始化器，那么编译器将为其执行默认初始化。
			a.具有自动和动态存储期的非类变量的默认初始化产生具有不确定值的对象(静态和线程局部对象进行的是零初始化)。
			b.对于不能默认初始化的非静态数据成员，例如引用和"const"限定的类型的成员，必须指定成员初始化器。(没有默认构造函数的自定义类型的成员变量也必须指定成员初始化器)
			c.使用由默认初始化任何非类类型的变量所取得的不确定的值是未定义行为。(具有例外情况(一般是对于"unsigned char"类型))
		8.默认成员初始化器：C++11标准起，非静态数据成员可以在类体中声明的同时给予缺省值，曾在"类的引入和定义"中提到过，实际上它也是成员初始化的一种方式。
			a.成员初始化的两种方式
				a'.非静态数据成员初始化方式一：在构造函数的成员初始化器列表中初始化。
				b'.非静态数据成员初始化方式二：通过默认成员初始化器初始化，它是成员声明中包含的花括号或等号初始化器，并在成员初始化器列表中忽略该成员的情况下得到使用。
			b.如果成员拥有默认成员初始化器，并且在构造函数的成员初始化器列表中也有出现，那么对该构造函数忽略默认成员初始化器，以成员初始化器列表中的初始化器为准。
			c.还记得位域吗？在C++20前，位域只能通过成员初始化器列表初始化，而不能通过默认成员初始化器初始化，C++20标准起，位域也可以通过默认成员初始化器初始化。
			d.数组类型的成员并不能从默认成员初始化器中推导出数组的长度，因此你需要显式地指定数组的长度。
			e.与成员初始化器列表一样，在默认成员初始化器中，引用成员也不能绑定到临时量。
		9.聚合初始化和列表初始化(C++11)(此处为拓展，目前只需会理解代码即可)
			a.聚合初始化：从初始化器列表初始化聚合体。(简要说明)
				a'.在C++11前，允许使用花括号对数组或结构体对象进行统一的列表初始值设定初始化，实际上这种初始化方式被称之为聚合初始化。
				b'.聚合体分为数组类型和符合特定条件的类类型，这些类类型被称为聚合类。
				c'.当聚合初始化时初始化器列表中的初始化子句多于聚合体中的元素时，报错。
				d'.若以空的初始化器列表初始化边界未知的数组时，报错。
				e'.文档：https://zh.cppreference.com/w/cpp/language/aggregate_initialization。
			b.列表初始化：从"花括号初始化器列表"初始化对象。(简要说明)
				a'.C++11起，扩大了使用花括号的范围，使其允许使用花括号对所有的内置类型和用户自定义的类型进行列表初始化，并且将聚合初始化作为了列表初始化的一种特殊形式。
				b'.列表初始化可区分为直接列表初始化和复制列表初始化。
				c'.列表初始化是多种初始化的一种合并，通过不同的情况，可以得到不同的初始化方式。
				d'.可在成员初始化器中使用花括号初始化器列表初始化，初始化类或标识符所指名的成员，并且当花括号列表为空时进行值初始化，而在初始化聚合体时进行聚合初始化。
				e'.文档：https://zh.cppreference.com/w/cpp/language/list_initialization。
*/

////成员初始化器列表示例一：成员初始化器列表的使用。
//struct Test
//{
//	//以下是成员变量的声明，初识化的顺序也是根据此处的声明顺序来的。
//	int a_;
//	int b_;
//
//	//默认构造函数
//	Test() : a_(10), b_(20)//在构造函数的函数体的花括号之前，按照成员变量的声明顺序，使用成员初始化器列表初始化成员，并且此处有两个成员初始化器。
//	{
//		//执行完成员初始化器列表之后，才会执行函数体中的代码，此时的成员"a_"和"b_"已被初始化。
//		a_ = 10;//此处为赋值，并不是初始化。
//		a_ = 10;//可以被多次赋值。
//	}
//
//	//带参数的构造函数
//	Test(int a, int b) : a_(a), b_(b)//将形参"a"和形参"b"用于初始化成员变量"a_"和成员变量"b_"。
//	{
//
//	}
//};
//
//int main()
//{
//	Test t1;//调用默认构造函数。
//
//	std::cout << "t1.a_ = " << t1.a_ << " t1.b_ = " << t1.b_ << std::endl;//成功被初始化。
//
//	Test t2(20, 50);//调用带参数的构造函数。
//
//	std::cout << "t2.a_ = " << t2.a_ << " t2.b_ = " << t2.b_ << std::endl;//成功被初始化。
//
//	return 0;
//}

////成员初始化器列表示例二：成员初始化器中的表达式。
//struct T1
//{
//	int a_;
//	int b_;
//
//	//默认构造函数
//	T1() : a_(0), b_(0)
//	{
//	}
//
//	//带参数的构造函数
//	T1(int a, int b) : a_(a), b_(b)
//	{
//	}
//};
//
//struct T2
//{
//	T1 x_;
//	T1 y_;
//
//	//默认构造函数
//	T2() : x_()//此处成员初始化器的表达式为空表达式，调用属于"x_"成员变量类型的默认构造函数。
//			, y_(5, 5)//表达式可以是具有逗号分隔的列表，调用属于"y_"成员变量类型的带参数的构造函数。
//	{
//	}
//};
//
//int main()
//{
//	T2 t;
//
//	std::cout << "t.x_.a_ = " << t.x_.a_ << " t.x_.b_ = " << t.x_.b_ << std::endl;
//	std::cout << "t.y_.a_ = " << t.y_.a_ << " t.y_.b_ = " << t.y_.b_ << std::endl;
//
//	return 0;
//}

////成员初始化器列表示例三：需要指定成员初始化器的成员变量。
//struct T1
//{
//	int a_;
//	int b_;
//
//	//带参数的构造函数
//	T1(int a, int b) : a_(a), b_(b)
//	{
//	}
//};
//
//struct T2
//{
//	//以下是能够进行默认初始化的成员变量。
//	int a_;
//
//	//以下是不能够进行默认初始化的成员变量。
//	int& x_;//引用成员变量。
//	T1 y_;//类类型成员变量。
//	const int z_;//常量成员变量。
//
//	////错误的默认构造函数，不能进行默认初始化的成员变量必须指定初始化方式。
//	//T2() : y_()//自定义类型成员变量"y_"并没有关于它的默认构造函数，不能进行默认初始化，必须显式指定构造函数初始化。
//	//{
//	//}
//
//	//正确的默认构造函数
//	T2() : x_(a_), y_(0, 0), z_(0)
//	{
//		a_ = 0;//在成员初始化器列表并没有指定关于成员变量"a_"的成员初始化器，但是它是能够进行默认初始化的成员变量。
//	}
//};
//
//int main()
//{
//	T2 t;
//
//	std::cout << "t.a_ = " << t.a_ << std::endl;
//	std::cout << "t.x_ = " << t.x_ << std::endl;
//	std::cout << "t.y_.a_ = " << t.y_.a_ << " t.y_.b_ = " << t.y_.b_ << std::endl;
//	std::cout << "t.z_ = " << t.z_ << std::endl;
//
//	return 0;
//}

////成员初始化器列表示例四：绑定到成员初始化器列表中的临时量的引用成员。
//struct T
//{
//	int x_;
//	int& cx_;
//
//	////错误的构造函数，因为成员变量"cx_"是引用类型，不能绑定到临时量上。
//	//T() : x_(0), cx_(0)
//	//{
//	//}
//
//	//正确的构造函数
//	T() : x_(0), cx_(x_)
//	{
//	}
//};
//
//int main()
//{
//	T t;
//
//	std::cout << "t.x_ = " << t.x_ << std::endl;
//	std::cout << "t.cx_ = " << t.cx_ << std::endl;
//
//	return 0;
//}

////成员初始化器列表示例五：默认成员初始化器。(C++11起)
//int x = 0;
//
//struct S
//{
//	int n = ++x;//默认成员初始化器，此处依旧是声明，初始化将在构造函数中的成员初始化列表中进行。
//	//int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };//错误：不能从默认成员初始值设定项推导出数组长度
//	//const int& a = 1;//错误，此处将临时量"1"绑定到了成员变量"a"上。
//
//	//默认构造函数
//	S()
//	{
//	}
//
//	//带参数的构造函数
//	S(int num1)
//	{
//	}
//
//	//带参数的构造函数
//	S(int num1, int num2) : n(100)
//	{
//	}
//};
//
//int main()
//{
//	//测试是否运行默认初始化器
//	std::cout << x << '\n';//结果为：0。
//	S s1;
//	std::cout << x << '\n';//结果为：1。(运行默认初始化器)
//	S s2(0);
//	std::cout << x << '\n';//结果为：2。(运行默认初始化器)
//	S s3(0, 0);
//	std::cout << x << '\n';//结果为：2。(没有运行默认初始化器，成员变量出现在构造函数的成员初始化器列表中，忽略默认初始化器)
//
//	//输出成员变量的值
//	std::cout << "s1.n = " << s1.n << std::endl;
//	std::cout << "s2.n = " << s2.n << std::endl;
//	std::cout << "s3.n = " << s3.n << std::endl;//忽略默认初始化器，将以成员初始化器列表中的值为准。
//
//	return 0;
//}

////成员初始化器列表示例六：聚合初始化和列表初始化的使用。
//struct S//此处为聚合类。
//{
//	int n;
//	int arr[10];
//
//	void print()
//	{
//		std::cout << "n = " << n << std::endl;
//		std::cout << "arr = ";
//		for (int i = 0; i < 10; ++i)
//		{
//			std::cout << arr[i] << " ";
//		}
//		std::cout << std::endl;
//	}
//};
//
//struct T//此处为非聚合类。
//{
//	int n;
//	int arr[10];
//
//	//默认构造函数
//	T() : n(10), arr{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }//"arr"成员变量使用了花括号初始化器列表。
//	{
//	}
//
//	//带参数的构造函数
//	T(int num1) : n(10), arr{ num1 }//"arr"成员变量使用了花括号初始化器列表。
//	{
//	}
//
//	void print()
//	{
//		std::cout << "n = " << n << std::endl;
//		std::cout << "arr = ";
//		for (int i = 0; i < 10; ++i)
//		{
//			std::cout << arr[i] << " ";
//		}
//		std::cout << std::endl;
//	}
//
//};
//
//int main()
//{
//	int arr[10] = { 1 };//此处为直接使用聚合初始化。
//	//char x[4] = { 'a', 's', 'd', 'f', 0 };//错误，聚合初始化时初始化器列表中的初始化子句多于聚合体中的元素。
//	//int y[] = {};//错误，聚合初始化时以空的初始化器列表初始化边界未知的数组。
//
//	//输出"arr"数组的值
//	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); ++i)
//	{
//		std::cout << arr[i] << ' ';
//	}
//	std::cout << std::endl;
//
//	S s1 = { 10, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }};//初始化对象时使用花括号初始化器列表，此处为复制列表初始化中的聚合初始化。
//	S s2{ 10, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }};//初始化对象时使用花括号初始化器列表，此处为直接列表初始化中的聚合初始化。
//
//	//输出"S"类的对象成员变量"n"及"arr"的值
//	s1.print();
//	s2.print();
//
//	T t1;//默认初始化，调用默认构造函数。
//	T t2{};//直接列表初始化，花括号初始化器列表的列表为空，且此类是拥有默认构造函数的类类型，进行值初始化。
//	T t3{ 10 };//直接列表初始化，使用带参数的构造函数初始化对象。
//	T t4 = { 10 };//复制列表初始化，使用带参数的构造函数初始化对象。
//
//	//输出"T"类对象成员变量"n"及"arr"的值
//	t1.print();
//	t2.print();
//	t3.print();
//	t4.print();
//
//	return 0;
//}

/***
	"explicit"关键词：在构造函数的声明说明符序列处给出的说明符，用于指定构造函数为显式，即它不能用于隐式转换和复制初始化。
		1."explicit"说明符将会在类定义之内的构造函数的声明说明符序列中出现。(根据标准迭代，C++11起它并不仅仅只能在构造函数中出现，但暂不做讨论)
		2.声明时不带函数说明符"explicit"的拥有单个无默认值形参的构造函数被称作转换构造函数。(拥有单个无默认值形参仅适用于C++11前，代表着C++11后只要不带"explicit"说明符的构造函数都是转换构造函数，现只讨论当C++11前的情况)
			a.当实例化对象时，给出明确的参数时会在构造函数中进行直接初始化，但并不排除使用一些与对象类型不相符的值进行初始化(比如使用等号时)，这种情况下属于复制初始化。
			b.复制初始化中，具有了隐式转换类型的特性，即如果能以表达式复制初始化目标类型类型对象，那么可以隐式转换表达式到目标类型。
			c.转换构造函数指定了一个从它的实参类型(如果存在实参)到它的类类型的隐式转换，也就是说当你将一个能够隐式转换的表达式以复制初始化的形式初始化一个对象时，转换构造函数会进行隐式转换，从而完成初始化对象。
			d.隐式声明的及用户定义的非显式拷贝构造函数与移动构造函数也是转换构造函数。(移动构造函数暂不讨论)
		3."explicit"关键字限定了这种隐式转换和复制初始化初始化对象的行为，意味着只能用于显式转换和直接初始化。
		4.大白话
			a'.你在定义构造函数的时候，如果不带"explicit"说明符，那么构造函数就是转换构造函数，如果你带了"explicit"说明符，那么你的构造函数就不是转换构造函数。
			b'.如果你的构造函数是转换构造函数，那么你就可以使用隐式类型转换这个特性，用一些能进行隐式类型转换的值以复制初始化的方式初始化对象。
			c'.而如果你的构造函数不是转换构造函数，那么你就只能规规矩矩的用直接初始化的方式初始化对象，复制初始化就不需要考虑了。
*/

////"explicit"关键词示例
//struct A
//{
//	//转换构造函数(C++11起)
//	A()
//	{
//	}
//
//	//转换构造函数
//	A(int)
//	{
//	}
//};
//
//struct B
//{
//	explicit B()
//	{
//	}
//
//	explicit B(int)
//	{
//	}
//
//	explicit B(int, int)
//	{
//	}
//};
//
//int main()
//{
//	A a1 = 1;//复制初始化，调用"A(int)"转换构造函数。
//	A a2(2);//直接初始化，调用"A(int)"转换构造函数。
//
//	//B b1 = 1;//错误，"B(int)"是"explicit"的，不能用于复制初始化。
//	B b2(2);//直接初始化，调用"B(int)"转换构造函数。
//	B b3;//默认初始化，调用"B()"转换构造函数。
//
//	return 0;
//}

/***
	委托构造函数(C++11)：如果类自身的名字在初始化器列表中作为类或标识符出现，那么该列表只能由这一个成员初始化器组成，这种构造函数被称为委托构造函数。(拓展)
		1.委托构造函数的初始化列表中，仅有的成员所选择的构造函数是目标构造函数。
		2.调用委托构造函数时，首先会选择最合适的目标构造函数并执行，然后控制返回到委托构造函数并执行其函数体。
		3.委托构造函数不能递归。
		4.委托构造函数的作用：减少重复代码、降低错误可能、增强可读性和可维护性等。
		5.大白话
			a.当一个类的名字出现在了构造函数的成员初始化列表中，那么这个构造函数就是委托构造函数，并且它的初始化列表中只能有一个成员初始化器。
			b.通常有些成员的初识化需要不同的构造函数，但剩下的成员在不同的构造函数的初始化逻辑基本相同，这样就会有很多重复的代码。
			c.而委托构造函数可以将那些重复要干的事情交给目标构造函数，那么委托构造函数就只需要做一些特殊的事情就可以了。
*/

////委托构造函数示例：未使用委托构造函数的类和使用委托构造函数的类对比。(简单的示例(仅用于观察))
//class A
//{
//public:
//	int max;
//	int min;
//	int middle;
//
//	A()
//	{
//	}
//
//	//以下是三个构造函数，每个构造函数都有一些特殊的初始化逻辑，但是剩下的初始化逻辑都是一样的。
//	A(int my_max)
//	{
//		max = my_max > 0 ? my_max : 10;
//	}
//
//	A(int my_max, int my_min)
//	{
//		max = my_max > 0 ? my_max : 10;
//		min = my_min > 0 && my_min < max ? my_min : 1;
//	}
//
//	A(int my_max, int my_min, int my_middle)
//	{
//		max = my_max > 0 ? my_max : 10;
//		min = my_min > 0 && my_min < max ? my_min : 1;
//		middle = my_middle < max && my_middle > min ? my_middle : 5;
//	}
//};
//
//class B
//{
//public:
//	int max;
//	int min;
//	int middle;
//
//	//以下是三个构造函数，经过委托构造函数的改造，重复的操作被委托给了目标构造函数，委托构造函数只需要做一些特殊的事情就可以了。
//	B(int my_max)
//	{
//		max = my_max > 0 ? my_max : 10;
//	}
//
//	B(int my_max, int my_min) : B(my_max)
//	{
//		min = my_min > 0 && my_min < max ? my_min : 1;
//	}
//
//	B(int my_max, int my_min, int my_middle) : B(my_max, my_min)
//	{
//		middle = my_middle < max && my_middle > min ? my_middle : 5;
//	}
//};

/**
	"static"成员：静态成员，此处讨论的是关于类的静态成员。
 		1.静态成员
 			a."static"关键词可以在成员的声明说明符列表中的任意位置出现，通常在声明说明符的最前面。
 			b.静态数据成员和静态成员函数的名字不能与所在的类名相同。
 			c.类的静态成员不与类的对象关联：它们是具有静态存储期的独立变量或者常规函数。
 				a'.静态存储期指这类变量的内存空间在程序开始时分配，并在程序结束时销毁。
 				b'.静态存储期的变量只存在一个实例。
 			d."static"关键词只会用于静态成员在类定义中的声明，而不用于该静态成员的定义。
 			e.类体内的声明不是定义，且可以将成员声明为除"void"之外的不完整类型，但具有特殊情况。
 				a'.如果声明使用了"constexpr"说明符，则该成员必须声明为拥有完整类型。
 				b'.C++17起，如果声明使用了"inline"说明符，则该成员必须声明为拥有完整类型。
 			f.静态成员遵循类成员访问规则。
 			g.若在不同作用域使用此静态成员，则必须使用作用域运算符来指明该成员所属的类，代表着其依旧受类作用域的限制。(仍然遵循类成员的访问规则)
		2.静态成员函数
			a.静态成员函数不关联到任何对象，并且它们没有"this"指针，只能访问静态成员，存在于内存的代码段中。
			b.静态成员函数不能是虚函数，并且不能是由"const"及"volatile"限定符修饰的。
			c.静态成员函数是类级别而不是对象级别的，其地址能存储常规的函数指针中，但不能存储在成员函数指针中。
		3.静态数据变量
			a.静态数据变量不关联到任何对象，但它们的值共享于类的所有对象。
			b.即使不定义类的任何对象它们也存在于内存的静态区中。
			c.静态数据变量的生命周期是整个程序的生命周期，即整个程序中只有一个拥有静态存储期的静态数据变量实例。
			d.不能由"mutable"关键词修饰。
			e.如果类自身具有外部连接，那么类的静态数据变量也具有外部连接，局部类(定义于函数内部的类)和无名类，包括无名类的成员类，不能拥有静态数据变量。
			f.在类中不能定义静态数据变量，需要在类中声明，然后在类外定义，但具有例外情况：
				a'.C++17起，静态数据变量可以声明为"inline"，并且其可以在类定义中定义，而且可以指定初始化器。
		4.常量静态变量
			a.若整型或枚举类型的静态数据成员被"const"限定符修饰，那么它能以其中的每个表达式均为常量表达式的初始化器直接在类定义内初始化，但依旧不是定义。
			b.对于常量静态变量的初始化方式，在不同标准下具有不同规则。
		5.文档：https://zh.cppreference.com/w/cpp/language/static。
*/

////"static"成员示例一：静态成员的定义和访问方式。
//struct X
//{
//	static void f();//声明静态成员函数。
//	static int n;//声明静态数据变量。
//};
//
////定义"X"类的静态成员变量"n"
//int X::n = 7;//定义时可不使用"static"关键词。
//
////定义"X"类的静态成员函数"f"
//void X::f()
//{
//	n = 1;//静态成员变量"n"在此作用域可以直接使用，因其属于类作用域，不需要限定名。
//}
//
//void g()
//{
//	//不同作用域下需要使用属于静态成员的类作为限定名访问
//	X::n;
//	X::f();
//}
//
//int main()
//{
//	g();
//	return 0;
//}

////"static"成员示例二：计算程序中创建出了多少个类对象。
//class X
//{
//public:
//	X()
//	{
//		++count_;
//	}
//
//	X(const X& t)
//	{
//		++count_;
//	}
//
//	static int Count()
//	{
//		return count_;
//	}
//
//private:
//	static int count_;
//	int a;
//};
//
//int X::count_ = 0;
//
//int main()
//{
//	std::cout << X::Count() << std::endl;
//	X a1, a2;
//	X a3(a1);
//	std::cout << X::Count() << std::endl;
//	return 0;
//}

////"static"成员示例三：静态成员声明为不完整类型。
//struct X;
//
//struct Y
//{
//	static int arr[];//声明不完整类型的静态数据成员。
//	static X x;//声明不完整类型的静态数据成员。
//	static Y y;//声明不完整类型的静态数据成员。
//};
//
//int main()
//{
//	Y y1;//程序正常运行。
//	return 0;
//}

////"static"成员示例四：常量静态变量。
//struct X
//{
//	static const int x = 0;//常量静态变量，此处依旧是声明，而不是定义。
//	inline static int y = 10;//C++17起，常量静态变量可以声明为"inline"，并且其可以在类定义中定义，而且可以指定初始化器。
//};
//
//int main()
//{
//	std::cout << X::x << std::endl;//访问常量静态变量。
//	std::cout << X::y << std::endl;//访问常量静态变量。
//	return 0;
//}

/**
	友元：即友元声明，友元声明在类体内出现，并向一个函数或另一个类授予对包含友元声明的类的私有及受保护成员的访问权。
		1.友元函数
			a.在类中将函数以"friend"关键词声明为友元函数。
			b.友元函数可访问类的私有和保护成员，不受访问说明符的限制，但它不是类的成员函数。
			c.友元函数可以在类定义的任何地方声明，访问说明符的位置对于友元函数的含义没有任何区别。
			d.一个函数可以是多个类的友元函数。
			e.友元函数的调用与普通函数的调用相同。
			f.友元函数声明中不允许使用存储类说明符。
		2.友元类
			a.在类定义中，存在有以"friend"关键词指定的类名，称为友元类。
			b.友元类中的成员函数能够访问类的私有和保护成员，不受访问说明符的限制。
			c.友元类声明不能定义新的类。
		3.友元关系
			a.友元关系不具有传递性，即如果类"A"是类"B"的友元，类"B"是类"C"的友元，但不说明类"A"是类"C"的友元，可理解为你朋友的朋友不是你的朋友。
			b.友元关系不具有继承性，可理解为你朋友的孩子不是你的朋友。
			c.友元关系是单向的，即类"A"是类"B"的友元，不代表类"B"是类"A"的友元。
*/

////友元示例一：友元函数。
//class A
//{
//public:
//	A(int a = 0) : a(a)
//	{
//	}
//
//private:
//	//私有成员变量
//	int a;
//
//	//友元函数声明
//	friend void printA(A& a);//位置无关，不受访问说明符的限制。
//};
//
////友元函数定义
//void printA(A& a)
//{
//	std::cout << a.a << std::endl;
//}
//
//int main()
//{
//	A a(10);
//	printA(a);//友元函数调用，与普通函数调用相同。
//	return 0;
//}

////友元示例二：友元类。
//class A
//{
//public:
//	A(int a = 0) : a(a)
//	{
//	}
//
//private:
//	//私有成员变量
//	int a;
//
//	//友元类声明
//	friend class B;//友元类"B"，类"B"中的成员函数能够访问类"A"的私有和保护成员，不受访问说明符的限制。
//};
//
//class B
//{
//public:
//	void printA(A& a)
//	{
//		std::cout << a.a << std::endl;
//	}
//};
//
//int main()
//{
//	A a(10);
//	B b;
//	b.printA(a);
//	return 0;
//}

////友元示例三：友元关系中的传递性。
//class A
//{
//public:
//	A(int a = 0) : a(a)
//	{
//	}
//
//private:
//	int a;
//
//	friend class B;//友元类"B"，类"B"中的成员函数能够访问类"A"的私有和保护成员，不受访问说明符的限制。
//};
//
//class B
//{
//public:
//	void print(A& a)
//	{
//		std::cout << a.a << std::endl;
//	}
//
//private:
//	friend class C;//友元类"C"，类"C"中的成员函数能够访问类"B"的私有和保护成员，不受访问说明符的限制。
//};
//
//class C
//{
//public:
//	void print(A& a)
//	{
//		//std::cout << a.a << std::endl;//错误，你朋友的朋友不是你的朋友。
//	}
//};
//
//int main()
//{
//	A a(10);
//	B b;
//	b.print(a);
//	return 0;
//}

/**
	内部类：如果一个类声明(定义)在另一个类的内部，这个类就叫做内部类，又称为嵌套类。
		1.内部类和外围类
			a.内部类的名字在它的外围类作用域中存在，而且从内部类的成员函数中进行名字查找会在检测内部类的作用域后访问外围类的作用域。
			b.内部类可以访问外围类可以访问的所有名称(即使被访问限定符限制)，但它在其他方面是独立的，并且没有特殊访问外围类"this"指针的权限。
			c.在内部类中定义的友元函数对外围类的成员没有特殊访问权，但来自在内部类中定义的成员函数体内的查找能找到内部类的私有成员。
			d.不同标准下的内部类的访问规则
				a'.C++11前的内部类只能使用外围类中的类型名、静态成员及枚举项。
				b'.C++11起的内部类能使用外围类的所有成员。
			e.内部类是一个独立的类，它不属于外部类。
			f.外围类对于内部类没有特殊的访问权限。
			g.内部类可以先在外围类的体内中先声明(称之为前置声明)，并在之后定义(在外围类的体内或体外均可)。
		2.对于内部类的访问会受到外围类的访问说明符的限制。
*/

////内部类示例一：内部类和外围类。
//int x, y;
//
//class A//外围类。
//{
//	int x;
//	static int s;
//public:
//	struct B//内部类。
//	{
//		void f(int i)
//		{
//			//x = i;//错误：使用嵌套类型"B"中"A"的非静态数据成员"x"。(不能通过"this"指针访问外围类的非静态成员)
//			s = i;//正确，可以赋值给静态数据成员"s"。
//			::x = i;//可以赋值给全局变量"x"。
//			y = i;//可以赋值给全局变量"y"。
//		}
//
//		void g(A* p, int i)
//		{
//			p->x = i;//正确，可以这样访问外围类"A"的非静态数据成员"x"。
//		}
//
//		void h(A& a, int i)
//		{
//			a.x = i;//正确，可以这样访问外围类"A"的非静态数据成员"x"。
//		}
//	};
//};
//
//int A::s = 10;
//
//int main()
//{
//	A a;
//	A::B b;
//
//	b.f(10);
//	b.g(&a, 20);
//	b.h(a, 30);
//
//	return 0;
//}

////内部类示例二：分离内部类。
//class A
//{
//private:
//	static int k;
//	int h = 0;
//public:
//	class B;//此处为前置声明。
//	class C;//此处为前置声明。
//
//	class B//内部类"B"在此处定义。
//	{
//	};
//};
//
//int A::k = 10;
//
//class A::C//内部类"C"在此处定义。
//{
//public:
//	void foo(const A& a)
//	{
//		std::cout << a.h << std::endl;
//		std::cout << a.k << std::endl;
//	}
//};
//
//int main()
//{
//	A a;
//	A::B b;
//	A::C c;
//	c.foo(a);
//	return 0;
//}

////内部类示例三：访问限制。
//class enclose
//{
//	struct nested//私有成员。
//	{
//		void g()
//		{
//		}
//	};
//
//public:
//	static nested f()
//	{
//		nested n;
//		return n;
//	}
//};
//
//int main()
//{
//	//enclose::nested n1 = e.f(); //错误，类"nested"是私有的。
//	enclose::f().g();//正确，没有通过"nested"访问。
//	auto n2 = enclose::f();//正确，没有通过"nested"访问。
//	n2.g();//正确，没有通过"nested"访问。
//	return 0;
//}

/**
	匿名对象：又称为临时对象，匿名对象是没有任何名称的对象。
		1.匿名对象的生命周期
			a.匿名对象的生命周期是从创建开始，到当前语句结束，仅有一行，除非将其绑定到常量左值引用上。
			b.若匿名对象被绑定，则延长临时对象的生命周期以匹配引用的生命周期。
		2.匿名对象具有常性。
		3.出现场景
			a.函数返回值语义时，产生匿名对象。
			b.传递参数时，若传递的是一个对象(传值调用)，则会产生匿名对象。
		4.匿名对象可能会被优化掉。
*/

////匿名对象示例：显式创建匿名对象。
//class A
//{
//public:
//	A(int a = 0) : _a(a)
//	{
//		std::cout << "A(int)" << std::endl;
//	}
//
//	~A()
//	{
//		std::cout << "~A()" << std::endl;
//	}
//
//	int _a;
//};
//
//A f()
//{
//	std::cout << "f()" << std::endl;
//	return A(10);//此处为显式创建匿名对象，调用构造函数，再以返回值语义的方式返回。
//}
//
//int main()
//{
//	//A a();//错误，函数声明。
//
//	//创建具名对象
//	A a1(10);
//
//	std::cout << "----------------" << std::endl;
//
//	//创建匿名对象
//	A(10);//正确，但是匿名对象会被立即销毁。
//
//	std::cout << "----------------" << std::endl;
//
//	f();//调用"f"函数，返回一个匿名对象，若不绑定，则匿名对象会被立即销毁。
//
//	std::cout << "----------------" << std::endl;
//
//	std::cout << f()._a << std::endl;//创建一个匿名对象，并访问匿名对象的成员，随后被销毁。
//
//	std::cout << "----------------" << std::endl;
//
//	return 0;//此时具名对象的生命周期结束，调用其类中的析构函数。
//}
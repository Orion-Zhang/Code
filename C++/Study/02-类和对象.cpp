#include <iostream>

/*
	类和对象
		01.面向过程和面向对象的初步认识
		02.类的引入和定义
		03.类的访问限定符及封装
		04.类的作用域
		05.类的实例化
		06.类的对象大小的计算
		07.类成员函数的"this"指针
		08.类的六个默认成员函数
		09.构造函数
		10.析构函数
		11.拷贝构造函数
		12.赋值运算符重载
		13."const"成员函数
		14.取地址及"const"取地址操作符重载
		15.再谈构造函数
		16."static"成员
		17.友元
		18.内部类
		19.匿名对象
		20.拷贝对象时的一些编译器优化
		21.再次理解封装
*/

/**
	面向过程和面向对象的初步认识
		1.C与C++
			a.C是面向过程的语言，其注重的是过程，即分析解决问题所需的步骤，从而通过函数逐步解决问题。
			b.C++严格意义上是面向过程与面向对象混合型语言，可理解为面向对象的语言，其注重的是对象，即分析解决问题所需的对象，从而通过对象之间的交互来解决问题。
		2.思维上的面向过程和面向对象
			a.无论是面向过程还是面向对象，都是一种思维方式，即分析解决问题所需的步骤或对象，从而通过函数或对象之间的交互来解决问题。
			b.汇编语言是面向机器的语言，也可说是面向细节的语言，其需要通过一条条指令操作来解决问题，是人脑模拟计算机的一种思维方式。
		3.语言上的面向过程和面向对象
			a.面向过程和面向对象并不决定于语言，而是取决于思维，是一种编程思想，而语言是可以实现这种思想的工具。
			b.C语言并非不可以实现面向对象的思想，仅是在面向对象方面，C语言提供的语法支持较为薄弱，但C语言的结构体、函数指针可以实现面向对象的思想，事实上，使用C语言实现的多数编程框架、库、驱动等都是具有面向对象思想的。
			c.C++在语法层面上提供了对面向对象编程更好的支持，能让使用它的人更加优雅的面向对象编程。
		4.面向对象的三大特性：封装、继承、多态。(封装将在本章的"03"小节介绍，而其它特性将会在之后的章节中介绍)(并非仅有这三大特性)
*/

/**
	类的引入和定义
		1.C++对C语言结构体的升级
			a.C++升级了C语言的结构体，其兼容了C语言中结构体的所有用法，并使其具有了面向对象的特征，称之为类。
			b.C语言中的结构体只允许有变量(数据成员)，不能有函数(函数成员)，而C++中的结构体允许有变量(数据成员)和函数(函数成员)。
			c.C++中将结构体的名称称之为类名，将结构体中的数据成员称之为成员变量或类的属性，将结构体中的函数成员称之为成员函数或类的方法。
			d.对象是指类的实例，使用已经定义的类去说明它的实例变量，即通过类创建的变量，称之为对象。
			e.一个对象是类的一个实例，类中具有的成员变量和成员函数，对于对象来说也是对象的属性和对象的方法。
			f.C++使用类实例化对象时是可以直接使用类名加对象名实例化的，而C语言使用结构体类型定义结构体变量时，必须在变量名前加上"struct"关键词(除非使用"typedef"关键词)。
		2."class"关键词
			a.使用"class"关键词定义类的格式如下：
				class 类头名
				{
					成员说明(类体)
				};
			b.除了默认成员访问和默认基类访问之外(将在本章的"03"小节中介绍)，可以认为"class"关键词与"struct"关键词在类的声明上是等同的。
		3.类的两种定义方式
			a.在类体中直接定义成员变量和成员函数。
			b.在类体中声明静态成员变量和成员函数，然后在类体外定义静态成员变量和成员函数。(暂不考虑静态成员函数)(声明和定义分离的一种体现)
				a'.类体中并不能直接定义静态成员变量，因为定义需要分配内存，静态成员变量是随着类的，静态成员变量属于类级别高于普通成员变量的对象级别，不能随着对象的创建再申请静态成员变量的内存，所以需要单独在类的外部定义。
				b'.在类体外定义静态成员变量或成员函数时，需在静态成员变量定义的变量名或成员函数定义的函数名前加上类名和作用域解析运算符"::"。
		4."struct"关键词和"class"关键词的编程规范(不一定遵守)
			a.通常情况下仅当只有数据成员时使用"struct"关键词，其它一概使用"class"关键词，因为这两个关键词的含义几乎相同，所以我们为这两个关键字添加我们自己的语义理解，以便为定义的数据类型选择合适的关键字。
			b."class"类体中的成员变量命名是具有多种不同的命名规范的，通常会在成员变量名前加上"m_"前缀或直接以下划线结尾，以区别于普通的变量名。
			c.结构体数据成员与普通变量命名规范一致即可。
*/

////类的引入和定义示例一：使用"struct"关键词定义类。
//struct Rectangle
//{
//	//成员变量
//	int length;
//	int width;
//
//	//成员函数(不同于C语言中的结构体，C++中的结构体允许有函数成员)
//	int Area()
//	{
//		return length * width;
//	}
//};
//
//int main()
//{
//	Rectangle rect;//直接可以使用类名加对象名实例化对象"rect"。
//	rect.length = 10;//通过对象名访问成员变量。
//	rect.width = 20;//通过对象名访问成员变量。
//	std::cout << "Area = " << rect.Area() << std::endl;//通过对象名访问成员函数。
//	return 0;
//}

////类的引入和定义示例二：使用"class"关键词定义类。
//class Rectangle
//{
//public://公有成员访问权限，将在本章的"03"小节中介绍。
//	//成员变量
//	int length;
//	int width;
//
//	//成员函数
//	int Area()
//	{
//		return length * width;
//	}
//};
//
//int main()
//{
//	Rectangle rect;
//	rect.length = 10;
//	rect.width = 20;
//	std::cout << "Area = " << rect.Area() << std::endl;
//	return 0;
//}

////类的引入和定义示例三：在类体外定义的静态成员变量和成员函数。
//class Test
//{
//public:
//	//成员变量
//	int m_a;//声明并定义成员变量，属于对象级别。
//	static int m_b;//声明静态成员变量，属于类级别。
//
//	//成员函数
//	void Func();//声明成员函数，属于对象级别。
//};
//
//int Test::m_b = 10;//在类体外定义已在类中声明的静态成员变量。
//
//void Test::Func()//在类体外定义已在类中声明的成员函数。
//{
//	std::cout << "Func()" << std::endl;
//}
//
//int main()
//{
//	Test test;
//
//	test.m_a = 10;//通过对象名访问成员变量。
//
//	test.Func();//通过对象名访问成员函数。
//
//	std::cout << "test.m_a = " << test.m_a << std::endl;//通过对象名访问成员变量。
//
//	std::cout << "Test::m_b = " << Test::m_b << std::endl;//通过类名访问静态成员变量。
//
//	return 0;
//}

/**
	类的访问限定符及封装
		1.访问说明符：又称为访问限定符，在类的成员说明中定义其后继成员的可访问性。
			a.C++中的访问说明符有"public"、"protected"和"private"三种。
				a'."public"：公有访问权限，该访问说明符之后的各个成员具有公开成员访问，可以在类的内部和外部被访问。
				b'."private"：私有访问权限，该访问说明符之后的各个成员具有私有成员访问，成员在类的内部可以被访问，外部不可以被访问。
				c'."protected"：保护访问权限，该访问说明符之后的各个成员具有保护成员访问，类似于私有访问权限，类外部不可以被访问，但是成员在基类的派生类中可以被访问。(当期阶段暂不讨论)
			b.访问说明符说明
				a'.访问说明符的作用范围是从其出现的位置开始，直到下一个访问说明符出现的位置为止，若没有下一个访问说明符，则到类体结束为止。
				b'.类中的所有成员都拥有对类所能访问的所有名字的访问权。
				c'.以"class"关键词定义的类默认的访问说明符为"private"，而以"struct"关键词定义的类默认的访问说明符为"public"(为了兼容C语言)。
				d'.在程序的任何位置使用成员的名字时都会检查其访问，而且如果它不满足访问规则，那么程序不能编译。
		2.封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。
			a.C++中可以通过类将数据和操作数据的方法进行有机结合，并且可以通过访问说明符来隐藏对象内部实现细节，并控制哪些方法可以在类的外部直接被使用，从而实现封装。
*/

////类的访问限定符及封装示例一：公开成员访问，即访问说明符"public"的使用。
//class S
//{
//public://从这里开始，直到下一个访问说明符出现的位置为止或者到类体结束为止，类中的成员都具有公开成员访问。
//	int n = 10;
//
//	enum E
//	{
//		A, B, C
//	};
//
//	struct U
//	{
//	};
//};//类体结束，变量"n"、枚举类型"E"、枚举类型"E"的所有成员、结构体类型"U"都具有公开成员访问。
//
//int main()
//{
//	S s;
//
//	std::cout << "s.n = " << s.n << std::endl;//"s.n"可以在类的外部被访问。
//
//	std::cout << "S::E::A = " << S::E::A << std::endl;//枚举类型"E"的所有成员可以在类的外部被访问。(只列举其中一个成员)
//
//	S::U u;//结构体类型"U"可以在类的外部被访问。
//
//	return 0;
//}

////类的访问限定符及封装示例二：私有访问权限，即访问说明符"private"的使用。
//class S
//{
//private:
//	int n = 10;
//};
//
//int main()
//{
//	S s;
//	//std::cout << "s.n = " << s.n << std::endl;//错误，"s.n"不能在类的外部被访问，因为它具有私有访问权限。
//	return 0;
//}
#include <iostream>

/*
	模板进阶
		1.非类型模板参数
		2.类模板的特化
		3.模板的分离式编译
*/

/**
	非类型模板参数
*/

/**
	类模板的特化
*/

/**
	模板的分离式编译
		1.关于模板的实例化
			a.在要求完整对象类型的语境中引用某个类模板特化时，或在要求函数定义存在的语境中引用某个函数模板特化时，除非模板已经被显式特化或显式实例化，否则模板即被实例化(模板代码被实际编译)。
			b.模板的定义必须在隐式实例化点可见，这也模板库通常都在头文件中提供所有模板定义的原因。
			c.模板只有实例化才会被实际编译，即产生具体类型的代码。
		2.编译阶段下编译器对模板的处理
			a.预处理器翻译单元与翻译单元
				a'.在进行编译前，预处理器会对源文件进行预处理操作，其主要包括将源文件展开，递归地将所有的"#include"指令替换为指令中声明的实际文件，而这一步骤将产生预处理翻译单元。
				b'.进一步的步骤包括对"#define"指令进行宏展开，以及对"#ifdef"指令进行条件编译，等等；这将使预处理翻译单元转换为翻译单元，翻译单元是预处理器的输出结果，即经过预处理后的源文件。
				c'.编译器根据翻译单元生成一个目标文件，而后就可以进一步处理和进入链接阶段(可能与其他目标文件一起)以形成可执行程序。
			b.编译器处理C++源文件时，可将此阶段称为编译阶段，以下是关于模板的编译阶段的说明：
				a'.进行编译时，编译器会将各个预处理记号转换成记号，将所有记号当作一个翻译单元进行语法和语义分析并进行翻译。
				b'.此后编译器会检验每个翻译单元，产生所要求的模板实例化的列表，其中包括显式实例化所要求的实例化；随后定位模板定义，并进行所要求的实例化，以产生实例化单元。
				c'.而后将翻译单元、实例化单元和为满足外部引用所需的库组件交由链接器，进入链接阶段，进而汇集成一个程序映像，它含有在它的执行环境中执行所需的信息。
				d'.一些编译器不实现实例化单元，而是简单地在进行编译时编译每个模板实例化，将代码存储在它所显式或隐式要求的对象文件中，然后由链接器在链接阶段将这些编译后的实例化合二为一。
		3.模板在分离式编译环境下产生的问题
			a.在分离式编译的环境下，编译器编译当前的翻译单元时，并不知道另一翻译单元的存在，而当遇到模板的声明或实例化时，在没有模板的定义下，其只能假设模板的定义在另一翻译单元中(产生具有外部链接的未决符号)，并不会实例化模板，而是交由链接器处理。
			b.当编译器遇到模板的定义时，若是在当前翻译单元下有模板的实例化，那么编译器才会实例化模板，进而产生具体类型的代码，但若是没有模板的实例化，那么编译器则不会实例化模板，这将导致模板代码无法被实际编译。
			c.若模板未被实例化，也就代表着模板代码没能转化为具体类型的代码，即模板代码未被实际编译，这将导致链接器在解析先前产生的具有外部链接的未决符号时，无法找到该模板的具体实现，从而导致链接失败。
		4.解决模板在分离式编译环境下产生的问题
			a.在模板定义处，显式实例化模板，从而解决模板代码未被实际编译的问题。
			b.将模板的声明和定义放在同一个翻译单元中，从而解决模板代码未被实际编译的问题。
*/
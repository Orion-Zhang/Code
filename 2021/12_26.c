#include <stdio.h>
#include <string.h>
#include <Windows.h>

//一维数组：一组相同类型元素的集合。
//	1.数组的创建方式：type_t arr_name [const_n]。
//		a.type_t：数组的元素类型。
//		b.arr_name：数组的名字。
//		c.const_n：常量表达式，用来指定数组的大小（大于零）。
//	2.变长数组：于C99标准中支持了变长数组的概念（即“const_n”可以为变量表达式）。
//	3.数组的初始化：在创建数组的同时给数组的内容一些合理初始值（初始化）。
//		a.完全初始化
//		b.不完全初始化
//	4.数组的使用
//		a.[]：下标引用操作符。
//		b.数组是使用下标来访问的，下标是从0开始的。
//		c.数组的大小可以通过计算得到。
//	5.一维数组在内存中的存储
//		a.数组在内存中是连续存放的。
//		b.随着数组下标的增长，元素的地址也在有规律的递增。

////一维数组初始化示例
//int main()
//{
//	//整型数组
//	int arr1[] = { 1,2,3 };//完全初始化：根据后面的内容初始化元素个数。
//	int arr2[5] = { 1,2,3 };//不完全初始化：未初始化的内容补充为“0”。
//	
//	//字符数组
//	char ch1[] = { 'A','o','k','i' };//根据后面的内容初始化元素个数（4个），没有“\0”，故打印出乱码。
//	char ch2[5] = { 'A','o','k','i' };//指定了数组的大小，未初始化的内容会自动补充“\0”，故打印出“Aoki”。
//	char ch3[] = "Aoki";//字符串会隐藏“\0”，故元素个数为5个，故打印出“Aoki”。
//	char ch4[4] = "Aoki";//指定数组的大小，没有了“\0”，故打印出乱码。
//	
//	return 0;
//}

////一维数组使用示例
//int main()
//{
//	int arr[11] = { 0 };
//	arr[5] = 6;//[]：下标引用操作符。
//	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

////一维数组在内存中的存储示例
//int main()
//{
//	int arr1[10] = { 0 };
//	for (int i = 0; i < sizeof(arr1) / sizeof(arr1[0]); i++)
//	{
//		printf("&arr[%d] = %p\n", i, &arr1[i]);//%p：打印地址（十六进制）；随着数组下标的增长，地址也在有规律的递增。
//	}
//	
//	int arr2[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr2;//数组名是数组首元素的地址。
//	for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0]); i++)
//	{
//		printf("%d ", *p);//正是因为数组在内存中是连续存放的，所以才能访问到元素。
//		p++;//看数组的元素类型推出地址加几（4）。
//	}
//	
//	return 0;
//}

//二维数组
//	1.二维数组的创建:type_t arr_name [x][y]。
//		a.type_t：数组的元素类型。
//		b.arr_name：数组的名字。
//		c.一个二维数组可以被认为是一个带有x行和y列的表格。
//	2.二维数组的初始化：多维数组可以通过在括号内为每行指定值来进行初始化。
//	3.二维数组的使用：二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的，同时行索引和列索引都是从0开始的。
//	4.二维数组在内存中的存储
//		a.二维数组在内存中也是连续存储的。
//		b.因为二维数组在内存中是连续存储的，所以必须确定列数，否则不知道一行有几个元素（第二行不知道放在哪里），故行索引可以被省略，列索引不行。

////二维数组初始化示例
//int main()
//{
//	int arr1[3][4] = { {0,1,2,3},{4,5,6,7},{8,9,10,11} };//内部嵌套的括号是可选的，于下行的二维数组初始化相同。
//	int arr2[3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };//完全初始化
//	int arr3[3][4] = { 0,1,2,3,4,5,6,7 };//不完全初始化：未初始化的内容补充为“0”。
//	int arr4[3][4] = { {0,1},{4,5},{8,9} };//不完全初始化；等同于”int arr4[3][4] = { 0,1,0,0,4,5,0,0,8,9,0,0 };“。
//	int arr5[][4] = { {0,1},{4,5},{8,9} };//行是可以省略的，会自动根据初始化内容确定。
//	return 0;
//}

////二维数组的使用
//int main()
//{
//	int arr[3][4] = { {0,1},{4,5},{8,9} };
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			printf("arr[%d][%d]=%d\t", i, j, arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}

////二维数组在内存中的存储
//int main()
//{
//	int arr1[][4] = { {0,1},{4,5},{8,9} };//见78行解释。
//	for (int i = 0; i < 3; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			printf("&arr1[%d][%d]=%p\n", i, j, &arr1[i][j]);//可以分析出二维数组在内存中也是连续存储的。
//		}
//	}
//
//	int arr2[][4] = { {0,1},{4,5},{8,9} };
//	int* p = &arr2[0][0];
//	for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0][0]); i++)
//	{
//		printf("%d ", *p);//正是因为数组在内存中是连续存放的，所以才能访问到元素。
//		p++;//看数组的元素类型推出地址加几（4）。
//	}
//
//	return 0;
//}

////数组越界访问：数组的下标如果小于0或者大于n-1，即数组越界访问（超出了数组合法空间的访问）。
//int main()
//{
//	printf("↓如下为一维数组的越界访问例子↓\n");
//	int arr1[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (int i = 0; i <= 10; i++)
//	{
//		printf("arr1[%d]=%d\n", i, arr1[i]);//当i等于10的时，即越界访问。
//	}
//	system("pause");
//	system("cls");
//	printf("↓如下为二维数组的越界访问例子↓\n");
//	int arr2[3][4] = { {0,1},{4,5},{8,9} };
//	for (int i = 0; i <= 3; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			printf("arr2[%d][%d]=%d\t", i, j, arr2[i][j]);//当i等于3的时，即越界访问。
//		}
//		printf("\n");
//	}
//	return 0;
//}

//数组作为函数参数
//	1.冒泡排序：当数组传参的时候，实际上只是把数组的首元素的地址传递过去了。
//	2.数组名：数组名是数组首元素的地址。
//		a.”sizeof(数组名)“：计算整个数组的大小（数组名表示整个数组）。
//		b.”&数组名“：取出的是数组的地址（数组名表示整个数组）。

////冒泡排序例子
//void bubble_sort(int arr[], int sz)
//{
//	for (int i = 0; i < sz-1; i++)
//	{
//		for (int j = 0; j < sz - 1 - i; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//			}
//		}
//	}
//}
//int main()
//{
//	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	bubble_sort(arr, sz);
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}

//数组名传参测试
//int main()
//{
//	int arr1[10] = { 1,2,3,4,5 };
//	printf("%p\n", arr1);
//	printf("%p\n", &arr1[0]);
//	printf("%d\n", *arr1);
//
//	int arr2[10] = { 0 };
//	printf("%p\n", &arr2);//取出的是数组的地址。
//	printf("%d\n", (unsigned int)sizeof(arr2));//计算的是整个数组的大小。
//
//	return 0;
//}
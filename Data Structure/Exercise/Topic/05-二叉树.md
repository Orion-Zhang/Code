# 2022-08-06

## 第 1 题（单选题）

下列关于堆的叙述错误的是：（ ）

**A** .堆是一种完全二叉树

**B** .堆通常使用顺序表存储

**C** .小堆指的是左右孩子结点都比根结点小的堆

**D** .堆的删除是将尾部结点放到队顶后执行向下调整算法

## 第 2 题（单选题）

下列关键字序列中，序列（ ）是堆。

**A** .{16，72，31，23，94，53}

**B** .{94，23，31，72，16，53}

**C** .{16，53，23，94，31，72}

**D** .{16，23，53，31，94，72}

## 第 3 题（单选题）

下列关于向下调整算法的说法正确的是：（ ）

**A** .构建堆的时候要对每个结点都执行一次

**B** .删除操作时要执行一次

**C** .插入操作时要执行一次

**D** .以上说法都不正确

## 第 4 题（单选题）

在一个堆中，根节点从0开始编号，下标为 i（i > 0） 的结点的左右孩子结点及父结点的下标分别是：（ ）

**A** .2 i、2 i + 1、i /2

**B** .2i、2i + 1、(i - 1)/2

**C** .2i + 1、2i + 2、(i - 1)/2

**D** .2i + 1、2i + 2、i/2-1

## 第 5 题（编程题）

***堆的实现：实现堆的增删查改等接口函数为一个项目。***

# 2022-08-08

## 第 1 题（单选题）

将一个顺序表利用向下调整的方式整理成堆的时间复杂度为：（ ）

**A** .O(nlogn)

**B** .O(logn)

**C** .O(1)

**D** .O(n)

## 第 2 题（编程题）

***堆排序的实现：实现对数组进行堆排序。***

**要求：**

1. 使用函数实现。
2. 函数声明：`void HeapSort(int* a, int n);`。

## 第 3 题（编程题）

***二叉树的实现：实现普通二叉树的递归与非递归遍历、各种节点数量等接口函数为一个项目。***

# 2022-08-09

## 第 1 题（单选题）

在用树表示的目录结构中，从根目录到任何数据文件，有（ ）通道

**A** .唯一一条

**B** .二条

**C** .三条

**D** .不一定

## 第 2 题（单选题）

在一颗度为3的树中，度为3的结点有2个，度为2的结点有1个，度为1的结点有2个，则叶子结点有（ ）个

**A** .4

**B** .5

**C** .6

**D** .7

## 第 3 题（单选题）

一颗拥有1000个结点的树度为4，则它的最小深度是：（ ）

**A** .5

**B** .6

**C** .7

**D** .8

## 第 4 题（单选题）

下列关于二叉树的叙述错误的是：（ ）

**A** .二叉树指的是深度为 2 的树

**B** .一个 n 个结点的二叉树将拥有 n-1 条边

**C** .一颗深度为 h 的满二叉树拥有 2^h-1 个结点（根结点深度为1）

**D** .二叉树有二叉链和三叉链两种表示方式

## 第 5 题（单选题）

一颗完全二叉树有1001个结点，其叶子结点的个数是：（ ）

**A** .251

**B** .500

**C** .501

**D** .不能确定

## 第 6 题（单选题）

在一颗完全二叉树中，某一个结点没有其左孩子，则该结点一定（ ）

**A** .是根结点

**B** .是叶结点

**C** .是分支结点

**D** .在倒数第二层

## 第 7 题（单选题）

设一棵二叉树中有3个叶子结点，有8个度为1的结点，则该二叉树中总的结点数为（ ）个

**A** .11

**B** .12

**C** .13

**D** .14

## 第 8 题（单选题）

下列关于树的叙述正确的是：（ ）

**A** .树中可以有环

**B** .树的度是指所有结点中度最小的结点的度

**C** .树的深度指的是结点数最多的那一层的深度

**D** .树的根结点是所有结点的祖先结点

## 第 9 题（单选题）

已知某二叉树的中序遍历序列为JGDHKBAELIMCF，后序遍历序列为JGKHDBLMIEFCA，则其前序遍历序列为：（ ）

**A** .ABDGHJKCEFILM

**B** .ABDGJHKCEILMF

**C** .ABDHKGJCEILMF

**D** .ABDGJHKCEIMLF

## 第 10 题（单选题）

已知某二叉树的前序遍历序列为ABDEC，中序遍历序列为BDEAC，则该二叉树（ ）

**A** .是满二叉树

**B** .是完全二叉树，不是满二叉树

**C** .不是完全二叉树

**D** .是所有的结点都没有右子树的二叉树

## 第 11 题（单选题）

设某种二叉树有如下特点：每个结点要么是叶子结点，要么有2棵子树。假如一棵这样的二叉树中有m（m>0）个叶子结点，那么该二叉树上的结点总数为：（ ）

**A** .2m+1

**B** .2(m-1)

**C** .2m-1

**D** .2m

## 第 12 题（单选题）

设根结点的深度为1，则一个拥有n个结点的二叉树的深度一定在（ ）区间内

**A** .[log(n + 1)，n]

**B** .[logn，n]

**C** .[log(n + 1)，n - 1]

**D** .[log(n + 1)，n + 1]

## 第 13 题（单选题）

对任意一颗二叉树，设N0、N1、N2分别是度为0、1、2的结点数，则下列式子中一定正确的是：（ ）

**A** .N0 = N2 + 1

**B** .N1 = N0 + 1

**C** .N2 = N0 + 1

**D** .N2 = N1 + 1

## 第 14 题（单选题）

有n个元素的完全二叉树的深度是：（ ）

**A** .nlogn

**B** .nlogn+1

**C** .logn

**D** .logn+1

## 第 15 题（单选题）

一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（ ）

**A** .所有的结点均无左孩子

**B** .所有的结点均无右孩子

**C** .只有一个叶子结点

**D** .至多只有一个结点

# 2022-08-11

## 第 1 题（编程题）

[***144. 二叉树的前序遍历***](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

## 第 2 题（编程题）

[***965. 单值二叉树***](https://leetcode.cn/problems/univalued-binary-tree/)

## 第 3 题（编程题）

[***104. 二叉树的最大深度***](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

## 第 4 题（编程题）

[***226. 翻转二叉树***](https://leetcode.cn/problems/invert-binary-tree/)

## 第 5 题（编程题）

[***100. 相同的树***](https://leetcode.cn/problems/same-tree/)

## 第 6 题（编程题）

[***101. 对称二叉树***](https://leetcode.cn/problems/symmetric-tree/)

## 第 7 题（编程题）

[***572. 另一棵树的子树***](https://leetcode.cn/problems/subtree-of-another-tree/)

## 第 8 题（编程题）

[***110. 平衡二叉树***](https://leetcode.cn/problems/balanced-binary-tree/)

# 2022-08-12

## 第 1 题（单选题）

已知某二叉树的前序遍历序列为5 7 4 9 6 2 1，中序遍历序列为4 7 5 6 9 1 2，则其后序遍历序列为：（ ）

**A** .4 2 5 7 6 9 1

**B** .4 2 7 5 6 9 1

**C** .4 7 6 1 2 9 5

**D** .4 7 2 9 5 6 1

## 第 2 题（单选题）

二叉树的（ ）遍历相当于广度优先遍历，（ ）遍历相当于深度优先遍历

**A** .前序 中序

**B** .中序 前序

**C** .层序 后序

**D** .层序 前序

## 第 3 题（单选题）

如果一颗二叉树的前序遍历的结果是ABCD，则满足条件的不同的二叉树有（ ）种

**A** .13

**B** .14

**C** .15

**D** .16

## 第 4 题（编程题）

[***KY11-二叉树遍历***](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef)

